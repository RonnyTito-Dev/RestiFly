
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model RestaurantConfig
 * 
 */
export type RestaurantConfig = $Result.DefaultSelection<Prisma.$RestaurantConfigPayload>
/**
 * Model Theme
 * 
 */
export type Theme = $Result.DefaultSelection<Prisma.$ThemePayload>
/**
 * Model DocumentType
 * 
 */
export type DocumentType = $Result.DefaultSelection<Prisma.$DocumentTypePayload>
/**
 * Model AccountStatus
 * 
 */
export type AccountStatus = $Result.DefaultSelection<Prisma.$AccountStatusPayload>
/**
 * Model PermissionCategory
 * 
 */
export type PermissionCategory = $Result.DefaultSelection<Prisma.$PermissionCategoryPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CashBox
 * 
 */
export type CashBox = $Result.DefaultSelection<Prisma.$CashBoxPayload>
/**
 * Model TableStatus
 * 
 */
export type TableStatus = $Result.DefaultSelection<Prisma.$TableStatusPayload>
/**
 * Model RestaurantZone
 * 
 */
export type RestaurantZone = $Result.DefaultSelection<Prisma.$RestaurantZonePayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model CombineTable
 * 
 */
export type CombineTable = $Result.DefaultSelection<Prisma.$CombineTablePayload>
/**
 * Model CombineTableItem
 * 
 */
export type CombineTableItem = $Result.DefaultSelection<Prisma.$CombineTableItemPayload>
/**
 * Model TableSession
 * 
 */
export type TableSession = $Result.DefaultSelection<Prisma.$TableSessionPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model ProductStatus
 * 
 */
export type ProductStatus = $Result.DefaultSelection<Prisma.$ProductStatusPayload>
/**
 * Model ProductType
 * 
 */
export type ProductType = $Result.DefaultSelection<Prisma.$ProductTypePayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model OrderStatus
 * 
 */
export type OrderStatus = $Result.DefaultSelection<Prisma.$OrderStatusPayload>
/**
 * Model OrderItemStatus
 * 
 */
export type OrderItemStatus = $Result.DefaultSelection<Prisma.$OrderItemStatusPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model InventoryMovementType
 * 
 */
export type InventoryMovementType = $Result.DefaultSelection<Prisma.$InventoryMovementTypePayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model InventoryMovement
 * 
 */
export type InventoryMovement = $Result.DefaultSelection<Prisma.$InventoryMovementPayload>
/**
 * Model OrderSequence
 * 
 */
export type OrderSequence = $Result.DefaultSelection<Prisma.$OrderSequencePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more RestaurantConfigs
 * const restaurantConfigs = await prisma.restaurantConfig.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more RestaurantConfigs
   * const restaurantConfigs = await prisma.restaurantConfig.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.restaurantConfig`: Exposes CRUD operations for the **RestaurantConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantConfigs
    * const restaurantConfigs = await prisma.restaurantConfig.findMany()
    * ```
    */
  get restaurantConfig(): Prisma.RestaurantConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.theme`: Exposes CRUD operations for the **Theme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themes
    * const themes = await prisma.theme.findMany()
    * ```
    */
  get theme(): Prisma.ThemeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentType`: Exposes CRUD operations for the **DocumentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTypes
    * const documentTypes = await prisma.documentType.findMany()
    * ```
    */
  get documentType(): Prisma.DocumentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountStatus`: Exposes CRUD operations for the **AccountStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountStatuses
    * const accountStatuses = await prisma.accountStatus.findMany()
    * ```
    */
  get accountStatus(): Prisma.AccountStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissionCategory`: Exposes CRUD operations for the **PermissionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissionCategories
    * const permissionCategories = await prisma.permissionCategory.findMany()
    * ```
    */
  get permissionCategory(): Prisma.PermissionCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashBox`: Exposes CRUD operations for the **CashBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashBoxes
    * const cashBoxes = await prisma.cashBox.findMany()
    * ```
    */
  get cashBox(): Prisma.CashBoxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tableStatus`: Exposes CRUD operations for the **TableStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableStatuses
    * const tableStatuses = await prisma.tableStatus.findMany()
    * ```
    */
  get tableStatus(): Prisma.TableStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.restaurantZone`: Exposes CRUD operations for the **RestaurantZone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RestaurantZones
    * const restaurantZones = await prisma.restaurantZone.findMany()
    * ```
    */
  get restaurantZone(): Prisma.RestaurantZoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combineTable`: Exposes CRUD operations for the **CombineTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombineTables
    * const combineTables = await prisma.combineTable.findMany()
    * ```
    */
  get combineTable(): Prisma.CombineTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combineTableItem`: Exposes CRUD operations for the **CombineTableItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombineTableItems
    * const combineTableItems = await prisma.combineTableItem.findMany()
    * ```
    */
  get combineTableItem(): Prisma.CombineTableItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tableSession`: Exposes CRUD operations for the **TableSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableSessions
    * const tableSessions = await prisma.tableSession.findMany()
    * ```
    */
  get tableSession(): Prisma.TableSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productStatus`: Exposes CRUD operations for the **ProductStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductStatuses
    * const productStatuses = await prisma.productStatus.findMany()
    * ```
    */
  get productStatus(): Prisma.ProductStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productType`: Exposes CRUD operations for the **ProductType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTypes
    * const productTypes = await prisma.productType.findMany()
    * ```
    */
  get productType(): Prisma.ProductTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStatus`: Exposes CRUD operations for the **OrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatuses
    * const orderStatuses = await prisma.orderStatus.findMany()
    * ```
    */
  get orderStatus(): Prisma.OrderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItemStatus`: Exposes CRUD operations for the **OrderItemStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItemStatuses
    * const orderItemStatuses = await prisma.orderItemStatus.findMany()
    * ```
    */
  get orderItemStatus(): Prisma.OrderItemStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovementType`: Exposes CRUD operations for the **InventoryMovementType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovementTypes
    * const inventoryMovementTypes = await prisma.inventoryMovementType.findMany()
    * ```
    */
  get inventoryMovementType(): Prisma.InventoryMovementTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryMovement`: Exposes CRUD operations for the **InventoryMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryMovements
    * const inventoryMovements = await prisma.inventoryMovement.findMany()
    * ```
    */
  get inventoryMovement(): Prisma.InventoryMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderSequence`: Exposes CRUD operations for the **OrderSequence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderSequences
    * const orderSequences = await prisma.orderSequence.findMany()
    * ```
    */
  get orderSequence(): Prisma.OrderSequenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    RestaurantConfig: 'RestaurantConfig',
    Theme: 'Theme',
    DocumentType: 'DocumentType',
    AccountStatus: 'AccountStatus',
    PermissionCategory: 'PermissionCategory',
    Permission: 'Permission',
    Role: 'Role',
    RolePermission: 'RolePermission',
    User: 'User',
    Session: 'Session',
    Customer: 'Customer',
    CashBox: 'CashBox',
    TableStatus: 'TableStatus',
    RestaurantZone: 'RestaurantZone',
    Table: 'Table',
    CombineTable: 'CombineTable',
    CombineTableItem: 'CombineTableItem',
    TableSession: 'TableSession',
    Image: 'Image',
    Brand: 'Brand',
    ProductStatus: 'ProductStatus',
    ProductType: 'ProductType',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    OrderStatus: 'OrderStatus',
    OrderItemStatus: 'OrderItemStatus',
    Order: 'Order',
    OrderItem: 'OrderItem',
    PaymentMethod: 'PaymentMethod',
    Payment: 'Payment',
    InventoryMovementType: 'InventoryMovementType',
    Inventory: 'Inventory',
    InventoryMovement: 'InventoryMovement',
    OrderSequence: 'OrderSequence',
    Log: 'Log'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "restaurantConfig" | "theme" | "documentType" | "accountStatus" | "permissionCategory" | "permission" | "role" | "rolePermission" | "user" | "session" | "customer" | "cashBox" | "tableStatus" | "restaurantZone" | "table" | "combineTable" | "combineTableItem" | "tableSession" | "image" | "brand" | "productStatus" | "productType" | "productCategory" | "product" | "orderStatus" | "orderItemStatus" | "order" | "orderItem" | "paymentMethod" | "payment" | "inventoryMovementType" | "inventory" | "inventoryMovement" | "orderSequence" | "log"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      RestaurantConfig: {
        payload: Prisma.$RestaurantConfigPayload<ExtArgs>
        fields: Prisma.RestaurantConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          findFirst: {
            args: Prisma.RestaurantConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          findMany: {
            args: Prisma.RestaurantConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>[]
          }
          create: {
            args: Prisma.RestaurantConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          createMany: {
            args: Prisma.RestaurantConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RestaurantConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          update: {
            args: Prisma.RestaurantConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          deleteMany: {
            args: Prisma.RestaurantConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantConfigPayload>
          }
          aggregate: {
            args: Prisma.RestaurantConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantConfig>
          }
          groupBy: {
            args: Prisma.RestaurantConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantConfigCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantConfigCountAggregateOutputType> | number
          }
        }
      }
      Theme: {
        payload: Prisma.$ThemePayload<ExtArgs>
        fields: Prisma.ThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findFirst: {
            args: Prisma.ThemeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findMany: {
            args: Prisma.ThemeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          create: {
            args: Prisma.ThemeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          createMany: {
            args: Prisma.ThemeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ThemeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          update: {
            args: Prisma.ThemeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          deleteMany: {
            args: Prisma.ThemeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ThemeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          aggregate: {
            args: Prisma.ThemeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTheme>
          }
          groupBy: {
            args: Prisma.ThemeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeCountAggregateOutputType> | number
          }
        }
      }
      DocumentType: {
        payload: Prisma.$DocumentTypePayload<ExtArgs>
        fields: Prisma.DocumentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          findFirst: {
            args: Prisma.DocumentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          findMany: {
            args: Prisma.DocumentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
          }
          create: {
            args: Prisma.DocumentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          createMany: {
            args: Prisma.DocumentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DocumentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          update: {
            args: Prisma.DocumentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          deleteMany: {
            args: Prisma.DocumentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTypePayload>
          }
          aggregate: {
            args: Prisma.DocumentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentType>
          }
          groupBy: {
            args: Prisma.DocumentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTypeCountAggregateOutputType> | number
          }
        }
      }
      AccountStatus: {
        payload: Prisma.$AccountStatusPayload<ExtArgs>
        fields: Prisma.AccountStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          findFirst: {
            args: Prisma.AccountStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          findMany: {
            args: Prisma.AccountStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>[]
          }
          create: {
            args: Prisma.AccountStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          createMany: {
            args: Prisma.AccountStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          update: {
            args: Prisma.AccountStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          deleteMany: {
            args: Prisma.AccountStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountStatusPayload>
          }
          aggregate: {
            args: Prisma.AccountStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountStatus>
          }
          groupBy: {
            args: Prisma.AccountStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountStatusCountArgs<ExtArgs>
            result: $Utils.Optional<AccountStatusCountAggregateOutputType> | number
          }
        }
      }
      PermissionCategory: {
        payload: Prisma.$PermissionCategoryPayload<ExtArgs>
        fields: Prisma.PermissionCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          findFirst: {
            args: Prisma.PermissionCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          findMany: {
            args: Prisma.PermissionCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>[]
          }
          create: {
            args: Prisma.PermissionCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          createMany: {
            args: Prisma.PermissionCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          update: {
            args: Prisma.PermissionCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PermissionCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
          }
          aggregate: {
            args: Prisma.PermissionCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissionCategory>
          }
          groupBy: {
            args: Prisma.PermissionCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCategoryCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CashBox: {
        payload: Prisma.$CashBoxPayload<ExtArgs>
        fields: Prisma.CashBoxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashBoxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashBoxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          findFirst: {
            args: Prisma.CashBoxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashBoxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          findMany: {
            args: Prisma.CashBoxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>[]
          }
          create: {
            args: Prisma.CashBoxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          createMany: {
            args: Prisma.CashBoxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CashBoxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          update: {
            args: Prisma.CashBoxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          deleteMany: {
            args: Prisma.CashBoxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashBoxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashBoxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashBoxPayload>
          }
          aggregate: {
            args: Prisma.CashBoxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashBox>
          }
          groupBy: {
            args: Prisma.CashBoxGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashBoxGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashBoxCountArgs<ExtArgs>
            result: $Utils.Optional<CashBoxCountAggregateOutputType> | number
          }
        }
      }
      TableStatus: {
        payload: Prisma.$TableStatusPayload<ExtArgs>
        fields: Prisma.TableStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          findFirst: {
            args: Prisma.TableStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          findMany: {
            args: Prisma.TableStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>[]
          }
          create: {
            args: Prisma.TableStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          createMany: {
            args: Prisma.TableStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TableStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          update: {
            args: Prisma.TableStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          deleteMany: {
            args: Prisma.TableStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableStatusPayload>
          }
          aggregate: {
            args: Prisma.TableStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTableStatus>
          }
          groupBy: {
            args: Prisma.TableStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableStatusCountArgs<ExtArgs>
            result: $Utils.Optional<TableStatusCountAggregateOutputType> | number
          }
        }
      }
      RestaurantZone: {
        payload: Prisma.$RestaurantZonePayload<ExtArgs>
        fields: Prisma.RestaurantZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RestaurantZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RestaurantZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          findFirst: {
            args: Prisma.RestaurantZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RestaurantZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          findMany: {
            args: Prisma.RestaurantZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>[]
          }
          create: {
            args: Prisma.RestaurantZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          createMany: {
            args: Prisma.RestaurantZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RestaurantZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          update: {
            args: Prisma.RestaurantZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          deleteMany: {
            args: Prisma.RestaurantZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RestaurantZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RestaurantZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RestaurantZonePayload>
          }
          aggregate: {
            args: Prisma.RestaurantZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRestaurantZone>
          }
          groupBy: {
            args: Prisma.RestaurantZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<RestaurantZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.RestaurantZoneCountArgs<ExtArgs>
            result: $Utils.Optional<RestaurantZoneCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      CombineTable: {
        payload: Prisma.$CombineTablePayload<ExtArgs>
        fields: Prisma.CombineTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombineTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombineTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          findFirst: {
            args: Prisma.CombineTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombineTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          findMany: {
            args: Prisma.CombineTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>[]
          }
          create: {
            args: Prisma.CombineTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          createMany: {
            args: Prisma.CombineTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CombineTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          update: {
            args: Prisma.CombineTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          deleteMany: {
            args: Prisma.CombineTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombineTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CombineTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTablePayload>
          }
          aggregate: {
            args: Prisma.CombineTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombineTable>
          }
          groupBy: {
            args: Prisma.CombineTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombineTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombineTableCountArgs<ExtArgs>
            result: $Utils.Optional<CombineTableCountAggregateOutputType> | number
          }
        }
      }
      CombineTableItem: {
        payload: Prisma.$CombineTableItemPayload<ExtArgs>
        fields: Prisma.CombineTableItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombineTableItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombineTableItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          findFirst: {
            args: Prisma.CombineTableItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombineTableItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          findMany: {
            args: Prisma.CombineTableItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>[]
          }
          create: {
            args: Prisma.CombineTableItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          createMany: {
            args: Prisma.CombineTableItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CombineTableItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          update: {
            args: Prisma.CombineTableItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          deleteMany: {
            args: Prisma.CombineTableItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombineTableItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CombineTableItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombineTableItemPayload>
          }
          aggregate: {
            args: Prisma.CombineTableItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombineTableItem>
          }
          groupBy: {
            args: Prisma.CombineTableItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombineTableItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombineTableItemCountArgs<ExtArgs>
            result: $Utils.Optional<CombineTableItemCountAggregateOutputType> | number
          }
        }
      }
      TableSession: {
        payload: Prisma.$TableSessionPayload<ExtArgs>
        fields: Prisma.TableSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          findFirst: {
            args: Prisma.TableSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          findMany: {
            args: Prisma.TableSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>[]
          }
          create: {
            args: Prisma.TableSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          createMany: {
            args: Prisma.TableSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TableSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          update: {
            args: Prisma.TableSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          deleteMany: {
            args: Prisma.TableSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TableSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableSessionPayload>
          }
          aggregate: {
            args: Prisma.TableSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTableSession>
          }
          groupBy: {
            args: Prisma.TableSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TableSessionCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      ProductStatus: {
        payload: Prisma.$ProductStatusPayload<ExtArgs>
        fields: Prisma.ProductStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          findFirst: {
            args: Prisma.ProductStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          findMany: {
            args: Prisma.ProductStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>[]
          }
          create: {
            args: Prisma.ProductStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          createMany: {
            args: Prisma.ProductStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          update: {
            args: Prisma.ProductStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          deleteMany: {
            args: Prisma.ProductStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductStatusPayload>
          }
          aggregate: {
            args: Prisma.ProductStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductStatus>
          }
          groupBy: {
            args: Prisma.ProductStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ProductStatusCountAggregateOutputType> | number
          }
        }
      }
      ProductType: {
        payload: Prisma.$ProductTypePayload<ExtArgs>
        fields: Prisma.ProductTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          findFirst: {
            args: Prisma.ProductTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          findMany: {
            args: Prisma.ProductTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>[]
          }
          create: {
            args: Prisma.ProductTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          createMany: {
            args: Prisma.ProductTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          update: {
            args: Prisma.ProductTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          deleteMany: {
            args: Prisma.ProductTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          aggregate: {
            args: Prisma.ProductTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductType>
          }
          groupBy: {
            args: Prisma.ProductTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTypeCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      OrderStatus: {
        payload: Prisma.$OrderStatusPayload<ExtArgs>
        fields: Prisma.OrderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findMany: {
            args: Prisma.OrderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          create: {
            args: Prisma.OrderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          createMany: {
            args: Prisma.OrderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          update: {
            args: Prisma.OrderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatus>
          }
          groupBy: {
            args: Prisma.OrderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusCountAggregateOutputType> | number
          }
        }
      }
      OrderItemStatus: {
        payload: Prisma.$OrderItemStatusPayload<ExtArgs>
        fields: Prisma.OrderItemStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          findFirst: {
            args: Prisma.OrderItemStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          findMany: {
            args: Prisma.OrderItemStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>[]
          }
          create: {
            args: Prisma.OrderItemStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          createMany: {
            args: Prisma.OrderItemStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          update: {
            args: Prisma.OrderItemStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemStatusPayload>
          }
          aggregate: {
            args: Prisma.OrderItemStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItemStatus>
          }
          groupBy: {
            args: Prisma.OrderItemStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemStatusCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovementType: {
        payload: Prisma.$InventoryMovementTypePayload<ExtArgs>
        fields: Prisma.InventoryMovementTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          findMany: {
            args: Prisma.InventoryMovementTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>[]
          }
          create: {
            args: Prisma.InventoryMovementTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          createMany: {
            args: Prisma.InventoryMovementTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryMovementTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          update: {
            args: Prisma.InventoryMovementTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryMovementTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementTypePayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovementType>
          }
          groupBy: {
            args: Prisma.InventoryMovementTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementTypeCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementTypeCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      InventoryMovement: {
        payload: Prisma.$InventoryMovementPayload<ExtArgs>
        fields: Prisma.InventoryMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findFirst: {
            args: Prisma.InventoryMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          findMany: {
            args: Prisma.InventoryMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>[]
          }
          create: {
            args: Prisma.InventoryMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          createMany: {
            args: Prisma.InventoryMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InventoryMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          update: {
            args: Prisma.InventoryMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          deleteMany: {
            args: Prisma.InventoryMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryMovementPayload>
          }
          aggregate: {
            args: Prisma.InventoryMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryMovement>
          }
          groupBy: {
            args: Prisma.InventoryMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryMovementCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryMovementCountAggregateOutputType> | number
          }
        }
      }
      OrderSequence: {
        payload: Prisma.$OrderSequencePayload<ExtArgs>
        fields: Prisma.OrderSequenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderSequenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderSequenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          findFirst: {
            args: Prisma.OrderSequenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderSequenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          findMany: {
            args: Prisma.OrderSequenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>[]
          }
          create: {
            args: Prisma.OrderSequenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          createMany: {
            args: Prisma.OrderSequenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderSequenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          update: {
            args: Prisma.OrderSequenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          deleteMany: {
            args: Prisma.OrderSequenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderSequenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderSequenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          aggregate: {
            args: Prisma.OrderSequenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderSequence>
          }
          groupBy: {
            args: Prisma.OrderSequenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderSequenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderSequenceCountArgs<ExtArgs>
            result: $Utils.Optional<OrderSequenceCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    restaurantConfig?: RestaurantConfigOmit
    theme?: ThemeOmit
    documentType?: DocumentTypeOmit
    accountStatus?: AccountStatusOmit
    permissionCategory?: PermissionCategoryOmit
    permission?: PermissionOmit
    role?: RoleOmit
    rolePermission?: RolePermissionOmit
    user?: UserOmit
    session?: SessionOmit
    customer?: CustomerOmit
    cashBox?: CashBoxOmit
    tableStatus?: TableStatusOmit
    restaurantZone?: RestaurantZoneOmit
    table?: TableOmit
    combineTable?: CombineTableOmit
    combineTableItem?: CombineTableItemOmit
    tableSession?: TableSessionOmit
    image?: ImageOmit
    brand?: BrandOmit
    productStatus?: ProductStatusOmit
    productType?: ProductTypeOmit
    productCategory?: ProductCategoryOmit
    product?: ProductOmit
    orderStatus?: OrderStatusOmit
    orderItemStatus?: OrderItemStatusOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    paymentMethod?: PaymentMethodOmit
    payment?: PaymentOmit
    inventoryMovementType?: InventoryMovementTypeOmit
    inventory?: InventoryOmit
    inventoryMovement?: InventoryMovementOmit
    orderSequence?: OrderSequenceOmit
    log?: LogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ThemeCountOutputType
   */

  export type ThemeCountOutputType = {
    usersUsingThisTheme: number
    customerUsingThisTheme: number
  }

  export type ThemeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usersUsingThisTheme?: boolean | ThemeCountOutputTypeCountUsersUsingThisThemeArgs
    customerUsingThisTheme?: boolean | ThemeCountOutputTypeCountCustomerUsingThisThemeArgs
  }

  // Custom InputTypes
  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeCountOutputType
     */
    select?: ThemeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountUsersUsingThisThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountCustomerUsingThisThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type DocumentTypeCountOutputType
   */

  export type DocumentTypeCountOutputType = {
    customers: number
    users: number
  }

  export type DocumentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | DocumentTypeCountOutputTypeCountCustomersArgs
    users?: boolean | DocumentTypeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTypeCountOutputType
     */
    select?: DocumentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * DocumentTypeCountOutputType without action
   */
  export type DocumentTypeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AccountStatusCountOutputType
   */

  export type AccountStatusCountOutputType = {
    users: number
    customers: number
  }

  export type AccountStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AccountStatusCountOutputTypeCountUsersArgs
    customers?: boolean | AccountStatusCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * AccountStatusCountOutputType without action
   */
  export type AccountStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatusCountOutputType
     */
    select?: AccountStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountStatusCountOutputType without action
   */
  export type AccountStatusCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AccountStatusCountOutputType without action
   */
  export type AccountStatusCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type PermissionCategoryCountOutputType
   */

  export type PermissionCategoryCountOutputType = {
    permissions: number
  }

  export type PermissionCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | PermissionCategoryCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCategoryCountOutputType without action
   */
  export type PermissionCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategoryCountOutputType
     */
    select?: PermissionCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCategoryCountOutputType without action
   */
  export type PermissionCategoryCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolePermissions: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | PermissionCountOutputTypeCountRolePermissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolePermissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | RoleCountOutputTypeCountRolePermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    openedCashBoxes: number
    closedCashBoxes: number
    inventoryMovements: number
    logs: number
    sessions: number
    combinedTables: number
    releasedTables: number
    tablesSessionOpened: number
    tablesSessionClosed: number
    ordersCreated: number
    ordersClosed: number
    createdThemes: number
    paymentsReceived: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    openedCashBoxes?: boolean | UserCountOutputTypeCountOpenedCashBoxesArgs
    closedCashBoxes?: boolean | UserCountOutputTypeCountClosedCashBoxesArgs
    inventoryMovements?: boolean | UserCountOutputTypeCountInventoryMovementsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    combinedTables?: boolean | UserCountOutputTypeCountCombinedTablesArgs
    releasedTables?: boolean | UserCountOutputTypeCountReleasedTablesArgs
    tablesSessionOpened?: boolean | UserCountOutputTypeCountTablesSessionOpenedArgs
    tablesSessionClosed?: boolean | UserCountOutputTypeCountTablesSessionClosedArgs
    ordersCreated?: boolean | UserCountOutputTypeCountOrdersCreatedArgs
    ordersClosed?: boolean | UserCountOutputTypeCountOrdersClosedArgs
    createdThemes?: boolean | UserCountOutputTypeCountCreatedThemesArgs
    paymentsReceived?: boolean | UserCountOutputTypeCountPaymentsReceivedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpenedCashBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashBoxWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClosedCashBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashBoxWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCombinedTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReleasedTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTablesSessionOpenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTablesSessionClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedThemesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sessions: number
    orders: number
    logs: number
    paymentsMade: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | CustomerCountOutputTypeCountSessionsArgs
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
    logs?: boolean | CustomerCountOutputTypeCountLogsArgs
    paymentsMade?: boolean | CustomerCountOutputTypeCountPaymentsMadeArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPaymentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type CashBoxCountOutputType
   */

  export type CashBoxCountOutputType = {
    payments: number
  }

  export type CashBoxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | CashBoxCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CashBoxCountOutputType without action
   */
  export type CashBoxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBoxCountOutputType
     */
    select?: CashBoxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashBoxCountOutputType without action
   */
  export type CashBoxCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type TableStatusCountOutputType
   */

  export type TableStatusCountOutputType = {
    tables: number
  }

  export type TableStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | TableStatusCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * TableStatusCountOutputType without action
   */
  export type TableStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatusCountOutputType
     */
    select?: TableStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableStatusCountOutputType without action
   */
  export type TableStatusCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type RestaurantZoneCountOutputType
   */

  export type RestaurantZoneCountOutputType = {
    tables: number
  }

  export type RestaurantZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | RestaurantZoneCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * RestaurantZoneCountOutputType without action
   */
  export type RestaurantZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZoneCountOutputType
     */
    select?: RestaurantZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RestaurantZoneCountOutputType without action
   */
  export type RestaurantZoneCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    tableSessions: number
    combineTableItems: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tableSessions?: boolean | TableCountOutputTypeCountTableSessionsArgs
    combineTableItems?: boolean | TableCountOutputTypeCountCombineTableItemsArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountTableSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableSessionWhereInput
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountCombineTableItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableItemWhereInput
  }


  /**
   * Count Type CombineTableCountOutputType
   */

  export type CombineTableCountOutputType = {
    tables: number
    tableSessions: number
  }

  export type CombineTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | CombineTableCountOutputTypeCountTablesArgs
    tableSessions?: boolean | CombineTableCountOutputTypeCountTableSessionsArgs
  }

  // Custom InputTypes
  /**
   * CombineTableCountOutputType without action
   */
  export type CombineTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableCountOutputType
     */
    select?: CombineTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CombineTableCountOutputType without action
   */
  export type CombineTableCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableItemWhereInput
  }

  /**
   * CombineTableCountOutputType without action
   */
  export type CombineTableCountOutputTypeCountTableSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableSessionWhereInput
  }


  /**
   * Count Type TableSessionCountOutputType
   */

  export type TableSessionCountOutputType = {
    orders: number
  }

  export type TableSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TableSessionCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * TableSessionCountOutputType without action
   */
  export type TableSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSessionCountOutputType
     */
    select?: TableSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableSessionCountOutputType without action
   */
  export type TableSessionCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    products: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BrandCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductStatusCountOutputType
   */

  export type ProductStatusCountOutputType = {
    products: number
  }

  export type ProductStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductStatusCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductStatusCountOutputType without action
   */
  export type ProductStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatusCountOutputType
     */
    select?: ProductStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductStatusCountOutputType without action
   */
  export type ProductStatusCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductTypeCountOutputType
   */

  export type ProductTypeCountOutputType = {
    products: number
  }

  export type ProductTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductTypeCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeCountOutputType
     */
    select?: ProductTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCategoryCountOutputType
   */

  export type ProductCategoryCountOutputType = {
    products: number
  }

  export type ProductCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategoryCountOutputType
     */
    select?: ProductCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCategoryCountOutputType without action
   */
  export type ProductCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inventories: number
    orderItems: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventories?: boolean | ProductCountOutputTypeCountInventoriesArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderStatusCountOutputType
   */

  export type OrderStatusCountOutputType = {
    orders: number
  }

  export type OrderStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatusCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusCountOutputType
     */
    select?: OrderStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OrderItemStatusCountOutputType
   */

  export type OrderItemStatusCountOutputType = {
    orderItems: number
  }

  export type OrderItemStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderItemStatusCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderItemStatusCountOutputType without action
   */
  export type OrderItemStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatusCountOutputType
     */
    select?: OrderItemStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemStatusCountOutputType without action
   */
  export type OrderItemStatusCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    payments: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethodCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type InventoryMovementTypeCountOutputType
   */

  export type InventoryMovementTypeCountOutputType = {
    movements: number
  }

  export type InventoryMovementTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | InventoryMovementTypeCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * InventoryMovementTypeCountOutputType without action
   */
  export type InventoryMovementTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementTypeCountOutputType
     */
    select?: InventoryMovementTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryMovementTypeCountOutputType without action
   */
  export type InventoryMovementTypeCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    inventoryMovements: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryMovements?: boolean | InventoryCountOutputTypeCountInventoryMovementsArgs
  }

  // Custom InputTypes
  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountInventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model RestaurantConfig
   */

  export type AggregateRestaurantConfig = {
    _count: RestaurantConfigCountAggregateOutputType | null
    _avg: RestaurantConfigAvgAggregateOutputType | null
    _sum: RestaurantConfigSumAggregateOutputType | null
    _min: RestaurantConfigMinAggregateOutputType | null
    _max: RestaurantConfigMaxAggregateOutputType | null
  }

  export type RestaurantConfigAvgAggregateOutputType = {
    id: number | null
    activeLogoId: number | null
    taxRate: Decimal | null
  }

  export type RestaurantConfigSumAggregateOutputType = {
    id: number | null
    activeLogoId: number | null
    taxRate: Decimal | null
  }

  export type RestaurantConfigMinAggregateOutputType = {
    id: number | null
    name: string | null
    activeLogoId: number | null
    currency: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxName: string | null
    taxIncluded: boolean | null
    taxType: string | null
    taxRate: Decimal | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RestaurantConfigMaxAggregateOutputType = {
    id: number | null
    name: string | null
    activeLogoId: number | null
    currency: string | null
    address: string | null
    phone: string | null
    email: string | null
    taxName: string | null
    taxIncluded: boolean | null
    taxType: string | null
    taxRate: Decimal | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RestaurantConfigCountAggregateOutputType = {
    id: number
    name: number
    activeLogoId: number
    currency: number
    address: number
    phone: number
    email: number
    taxName: number
    taxIncluded: number
    taxType: number
    taxRate: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type RestaurantConfigAvgAggregateInputType = {
    id?: true
    activeLogoId?: true
    taxRate?: true
  }

  export type RestaurantConfigSumAggregateInputType = {
    id?: true
    activeLogoId?: true
    taxRate?: true
  }

  export type RestaurantConfigMinAggregateInputType = {
    id?: true
    name?: true
    activeLogoId?: true
    currency?: true
    address?: true
    phone?: true
    email?: true
    taxName?: true
    taxIncluded?: true
    taxType?: true
    taxRate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RestaurantConfigMaxAggregateInputType = {
    id?: true
    name?: true
    activeLogoId?: true
    currency?: true
    address?: true
    phone?: true
    email?: true
    taxName?: true
    taxIncluded?: true
    taxType?: true
    taxRate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RestaurantConfigCountAggregateInputType = {
    id?: true
    name?: true
    activeLogoId?: true
    currency?: true
    address?: true
    phone?: true
    email?: true
    taxName?: true
    taxIncluded?: true
    taxType?: true
    taxRate?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type RestaurantConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantConfig to aggregate.
     */
    where?: RestaurantConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantConfigs to fetch.
     */
    orderBy?: RestaurantConfigOrderByWithRelationInput | RestaurantConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantConfigs
    **/
    _count?: true | RestaurantConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RestaurantConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RestaurantConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantConfigMaxAggregateInputType
  }

  export type GetRestaurantConfigAggregateType<T extends RestaurantConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantConfig[P]>
      : GetScalarType<T[P], AggregateRestaurantConfig[P]>
  }




  export type RestaurantConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantConfigWhereInput
    orderBy?: RestaurantConfigOrderByWithAggregationInput | RestaurantConfigOrderByWithAggregationInput[]
    by: RestaurantConfigScalarFieldEnum[] | RestaurantConfigScalarFieldEnum
    having?: RestaurantConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantConfigCountAggregateInputType | true
    _avg?: RestaurantConfigAvgAggregateInputType
    _sum?: RestaurantConfigSumAggregateInputType
    _min?: RestaurantConfigMinAggregateInputType
    _max?: RestaurantConfigMaxAggregateInputType
  }

  export type RestaurantConfigGroupByOutputType = {
    id: number
    name: string
    activeLogoId: number | null
    currency: string
    address: string | null
    phone: string | null
    email: string | null
    taxName: string | null
    taxIncluded: boolean
    taxType: string | null
    taxRate: Decimal | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: RestaurantConfigCountAggregateOutputType | null
    _avg: RestaurantConfigAvgAggregateOutputType | null
    _sum: RestaurantConfigSumAggregateOutputType | null
    _min: RestaurantConfigMinAggregateOutputType | null
    _max: RestaurantConfigMaxAggregateOutputType | null
  }

  type GetRestaurantConfigGroupByPayload<T extends RestaurantConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantConfigGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantConfigGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    activeLogoId?: boolean
    currency?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxName?: boolean
    taxIncluded?: boolean
    taxType?: boolean
    taxRate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["restaurantConfig"]>



  export type RestaurantConfigSelectScalar = {
    id?: boolean
    name?: boolean
    activeLogoId?: boolean
    currency?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    taxName?: boolean
    taxIncluded?: boolean
    taxType?: boolean
    taxRate?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type RestaurantConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "activeLogoId" | "currency" | "address" | "phone" | "email" | "taxName" | "taxIncluded" | "taxType" | "taxRate" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["restaurantConfig"]>

  export type $RestaurantConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      activeLogoId: number | null
      currency: string
      address: string | null
      phone: string | null
      email: string | null
      taxName: string | null
      taxIncluded: boolean
      taxType: string | null
      taxRate: Prisma.Decimal | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["restaurantConfig"]>
    composites: {}
  }

  type RestaurantConfigGetPayload<S extends boolean | null | undefined | RestaurantConfigDefaultArgs> = $Result.GetResult<Prisma.$RestaurantConfigPayload, S>

  type RestaurantConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantConfigCountAggregateInputType | true
    }

  export interface RestaurantConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantConfig'], meta: { name: 'RestaurantConfig' } }
    /**
     * Find zero or one RestaurantConfig that matches the filter.
     * @param {RestaurantConfigFindUniqueArgs} args - Arguments to find a RestaurantConfig
     * @example
     * // Get one RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantConfigFindUniqueArgs>(args: SelectSubset<T, RestaurantConfigFindUniqueArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantConfigFindUniqueOrThrowArgs} args - Arguments to find a RestaurantConfig
     * @example
     * // Get one RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigFindFirstArgs} args - Arguments to find a RestaurantConfig
     * @example
     * // Get one RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantConfigFindFirstArgs>(args?: SelectSubset<T, RestaurantConfigFindFirstArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigFindFirstOrThrowArgs} args - Arguments to find a RestaurantConfig
     * @example
     * // Get one RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantConfigs
     * const restaurantConfigs = await prisma.restaurantConfig.findMany()
     * 
     * // Get first 10 RestaurantConfigs
     * const restaurantConfigs = await prisma.restaurantConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const restaurantConfigWithIdOnly = await prisma.restaurantConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RestaurantConfigFindManyArgs>(args?: SelectSubset<T, RestaurantConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantConfig.
     * @param {RestaurantConfigCreateArgs} args - Arguments to create a RestaurantConfig.
     * @example
     * // Create one RestaurantConfig
     * const RestaurantConfig = await prisma.restaurantConfig.create({
     *   data: {
     *     // ... data to create a RestaurantConfig
     *   }
     * })
     * 
     */
    create<T extends RestaurantConfigCreateArgs>(args: SelectSubset<T, RestaurantConfigCreateArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantConfigs.
     * @param {RestaurantConfigCreateManyArgs} args - Arguments to create many RestaurantConfigs.
     * @example
     * // Create many RestaurantConfigs
     * const restaurantConfig = await prisma.restaurantConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantConfigCreateManyArgs>(args?: SelectSubset<T, RestaurantConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RestaurantConfig.
     * @param {RestaurantConfigDeleteArgs} args - Arguments to delete one RestaurantConfig.
     * @example
     * // Delete one RestaurantConfig
     * const RestaurantConfig = await prisma.restaurantConfig.delete({
     *   where: {
     *     // ... filter to delete one RestaurantConfig
     *   }
     * })
     * 
     */
    delete<T extends RestaurantConfigDeleteArgs>(args: SelectSubset<T, RestaurantConfigDeleteArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantConfig.
     * @param {RestaurantConfigUpdateArgs} args - Arguments to update one RestaurantConfig.
     * @example
     * // Update one RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantConfigUpdateArgs>(args: SelectSubset<T, RestaurantConfigUpdateArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantConfigs.
     * @param {RestaurantConfigDeleteManyArgs} args - Arguments to filter RestaurantConfigs to delete.
     * @example
     * // Delete a few RestaurantConfigs
     * const { count } = await prisma.restaurantConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantConfigDeleteManyArgs>(args?: SelectSubset<T, RestaurantConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantConfigs
     * const restaurantConfig = await prisma.restaurantConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantConfigUpdateManyArgs>(args: SelectSubset<T, RestaurantConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RestaurantConfig.
     * @param {RestaurantConfigUpsertArgs} args - Arguments to update or create a RestaurantConfig.
     * @example
     * // Update or create a RestaurantConfig
     * const restaurantConfig = await prisma.restaurantConfig.upsert({
     *   create: {
     *     // ... data to create a RestaurantConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantConfig we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantConfigUpsertArgs>(args: SelectSubset<T, RestaurantConfigUpsertArgs<ExtArgs>>): Prisma__RestaurantConfigClient<$Result.GetResult<Prisma.$RestaurantConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigCountArgs} args - Arguments to filter RestaurantConfigs to count.
     * @example
     * // Count the number of RestaurantConfigs
     * const count = await prisma.restaurantConfig.count({
     *   where: {
     *     // ... the filter for the RestaurantConfigs we want to count
     *   }
     * })
    **/
    count<T extends RestaurantConfigCountArgs>(
      args?: Subset<T, RestaurantConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantConfigAggregateArgs>(args: Subset<T, RestaurantConfigAggregateArgs>): Prisma.PrismaPromise<GetRestaurantConfigAggregateType<T>>

    /**
     * Group by RestaurantConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantConfigGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantConfig model
   */
  readonly fields: RestaurantConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantConfig model
   */
  interface RestaurantConfigFieldRefs {
    readonly id: FieldRef<"RestaurantConfig", 'Int'>
    readonly name: FieldRef<"RestaurantConfig", 'String'>
    readonly activeLogoId: FieldRef<"RestaurantConfig", 'Int'>
    readonly currency: FieldRef<"RestaurantConfig", 'String'>
    readonly address: FieldRef<"RestaurantConfig", 'String'>
    readonly phone: FieldRef<"RestaurantConfig", 'String'>
    readonly email: FieldRef<"RestaurantConfig", 'String'>
    readonly taxName: FieldRef<"RestaurantConfig", 'String'>
    readonly taxIncluded: FieldRef<"RestaurantConfig", 'Boolean'>
    readonly taxType: FieldRef<"RestaurantConfig", 'String'>
    readonly taxRate: FieldRef<"RestaurantConfig", 'Decimal'>
    readonly createdAt: FieldRef<"RestaurantConfig", 'DateTime'>
    readonly createdBy: FieldRef<"RestaurantConfig", 'String'>
    readonly updatedAt: FieldRef<"RestaurantConfig", 'DateTime'>
    readonly updatedBy: FieldRef<"RestaurantConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantConfig findUnique
   */
  export type RestaurantConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter, which RestaurantConfig to fetch.
     */
    where: RestaurantConfigWhereUniqueInput
  }

  /**
   * RestaurantConfig findUniqueOrThrow
   */
  export type RestaurantConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter, which RestaurantConfig to fetch.
     */
    where: RestaurantConfigWhereUniqueInput
  }

  /**
   * RestaurantConfig findFirst
   */
  export type RestaurantConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter, which RestaurantConfig to fetch.
     */
    where?: RestaurantConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantConfigs to fetch.
     */
    orderBy?: RestaurantConfigOrderByWithRelationInput | RestaurantConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantConfigs.
     */
    cursor?: RestaurantConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantConfigs.
     */
    distinct?: RestaurantConfigScalarFieldEnum | RestaurantConfigScalarFieldEnum[]
  }

  /**
   * RestaurantConfig findFirstOrThrow
   */
  export type RestaurantConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter, which RestaurantConfig to fetch.
     */
    where?: RestaurantConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantConfigs to fetch.
     */
    orderBy?: RestaurantConfigOrderByWithRelationInput | RestaurantConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantConfigs.
     */
    cursor?: RestaurantConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantConfigs.
     */
    distinct?: RestaurantConfigScalarFieldEnum | RestaurantConfigScalarFieldEnum[]
  }

  /**
   * RestaurantConfig findMany
   */
  export type RestaurantConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter, which RestaurantConfigs to fetch.
     */
    where?: RestaurantConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantConfigs to fetch.
     */
    orderBy?: RestaurantConfigOrderByWithRelationInput | RestaurantConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantConfigs.
     */
    cursor?: RestaurantConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantConfigs.
     */
    skip?: number
    distinct?: RestaurantConfigScalarFieldEnum | RestaurantConfigScalarFieldEnum[]
  }

  /**
   * RestaurantConfig create
   */
  export type RestaurantConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a RestaurantConfig.
     */
    data: XOR<RestaurantConfigCreateInput, RestaurantConfigUncheckedCreateInput>
  }

  /**
   * RestaurantConfig createMany
   */
  export type RestaurantConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantConfigs.
     */
    data: RestaurantConfigCreateManyInput | RestaurantConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RestaurantConfig update
   */
  export type RestaurantConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a RestaurantConfig.
     */
    data: XOR<RestaurantConfigUpdateInput, RestaurantConfigUncheckedUpdateInput>
    /**
     * Choose, which RestaurantConfig to update.
     */
    where: RestaurantConfigWhereUniqueInput
  }

  /**
   * RestaurantConfig updateMany
   */
  export type RestaurantConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantConfigs.
     */
    data: XOR<RestaurantConfigUpdateManyMutationInput, RestaurantConfigUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantConfigs to update
     */
    where?: RestaurantConfigWhereInput
    /**
     * Limit how many RestaurantConfigs to update.
     */
    limit?: number
  }

  /**
   * RestaurantConfig upsert
   */
  export type RestaurantConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the RestaurantConfig to update in case it exists.
     */
    where: RestaurantConfigWhereUniqueInput
    /**
     * In case the RestaurantConfig found by the `where` argument doesn't exist, create a new RestaurantConfig with this data.
     */
    create: XOR<RestaurantConfigCreateInput, RestaurantConfigUncheckedCreateInput>
    /**
     * In case the RestaurantConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantConfigUpdateInput, RestaurantConfigUncheckedUpdateInput>
  }

  /**
   * RestaurantConfig delete
   */
  export type RestaurantConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
    /**
     * Filter which RestaurantConfig to delete.
     */
    where: RestaurantConfigWhereUniqueInput
  }

  /**
   * RestaurantConfig deleteMany
   */
  export type RestaurantConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantConfigs to delete
     */
    where?: RestaurantConfigWhereInput
    /**
     * Limit how many RestaurantConfigs to delete.
     */
    limit?: number
  }

  /**
   * RestaurantConfig without action
   */
  export type RestaurantConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantConfig
     */
    select?: RestaurantConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantConfig
     */
    omit?: RestaurantConfigOmit<ExtArgs> | null
  }


  /**
   * Model Theme
   */

  export type AggregateTheme = {
    _count: ThemeCountAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  export type ThemeMinAggregateOutputType = {
    name: string | null
    primaryColor: string | null
    secondaryColor: string | null
    accentColor: string | null
    neutralColor: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    createdUserDocument: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ThemeMaxAggregateOutputType = {
    name: string | null
    primaryColor: string | null
    secondaryColor: string | null
    accentColor: string | null
    neutralColor: string | null
    isSystem: boolean | null
    isPublic: boolean | null
    createdUserDocument: string | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ThemeCountAggregateOutputType = {
    name: number
    primaryColor: number
    secondaryColor: number
    accentColor: number
    neutralColor: number
    isSystem: number
    isPublic: number
    createdUserDocument: number
    createdAt: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ThemeMinAggregateInputType = {
    name?: true
    primaryColor?: true
    secondaryColor?: true
    accentColor?: true
    neutralColor?: true
    isSystem?: true
    isPublic?: true
    createdUserDocument?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ThemeMaxAggregateInputType = {
    name?: true
    primaryColor?: true
    secondaryColor?: true
    accentColor?: true
    neutralColor?: true
    isSystem?: true
    isPublic?: true
    createdUserDocument?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ThemeCountAggregateInputType = {
    name?: true
    primaryColor?: true
    secondaryColor?: true
    accentColor?: true
    neutralColor?: true
    isSystem?: true
    isPublic?: true
    createdUserDocument?: true
    createdAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ThemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theme to aggregate.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themes
    **/
    _count?: true | ThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMaxAggregateInputType
  }

  export type GetThemeAggregateType<T extends ThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheme[P]>
      : GetScalarType<T[P], AggregateTheme[P]>
  }




  export type ThemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithAggregationInput | ThemeOrderByWithAggregationInput[]
    by: ThemeScalarFieldEnum[] | ThemeScalarFieldEnum
    having?: ThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeCountAggregateInputType | true
    _min?: ThemeMinAggregateInputType
    _max?: ThemeMaxAggregateInputType
  }

  export type ThemeGroupByOutputType = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem: boolean
    isPublic: boolean
    createdUserDocument: string | null
    createdAt: Date
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: ThemeCountAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  type GetThemeGroupByPayload<T extends ThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    accentColor?: boolean
    neutralColor?: boolean
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    user?: boolean | Theme$userArgs<ExtArgs>
    usersUsingThisTheme?: boolean | Theme$usersUsingThisThemeArgs<ExtArgs>
    customerUsingThisTheme?: boolean | Theme$customerUsingThisThemeArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["theme"]>



  export type ThemeSelectScalar = {
    name?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    accentColor?: boolean
    neutralColor?: boolean
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ThemeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "primaryColor" | "secondaryColor" | "accentColor" | "neutralColor" | "isSystem" | "isPublic" | "createdUserDocument" | "createdAt" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["theme"]>
  export type ThemeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Theme$userArgs<ExtArgs>
    usersUsingThisTheme?: boolean | Theme$usersUsingThisThemeArgs<ExtArgs>
    customerUsingThisTheme?: boolean | Theme$customerUsingThisThemeArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ThemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Theme"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      usersUsingThisTheme: Prisma.$UserPayload<ExtArgs>[]
      customerUsingThisTheme: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      primaryColor: string
      secondaryColor: string
      accentColor: string
      neutralColor: string
      isSystem: boolean
      isPublic: boolean
      createdUserDocument: string | null
      createdAt: Date
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["theme"]>
    composites: {}
  }

  type ThemeGetPayload<S extends boolean | null | undefined | ThemeDefaultArgs> = $Result.GetResult<Prisma.$ThemePayload, S>

  type ThemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeCountAggregateInputType | true
    }

  export interface ThemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theme'], meta: { name: 'Theme' } }
    /**
     * Find zero or one Theme that matches the filter.
     * @param {ThemeFindUniqueArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeFindUniqueArgs>(args: SelectSubset<T, ThemeFindUniqueArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Theme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeFindUniqueOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeFindFirstArgs>(args?: SelectSubset<T, ThemeFindFirstArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Themes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themes
     * const themes = await prisma.theme.findMany()
     * 
     * // Get first 10 Themes
     * const themes = await prisma.theme.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const themeWithNameOnly = await prisma.theme.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ThemeFindManyArgs>(args?: SelectSubset<T, ThemeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Theme.
     * @param {ThemeCreateArgs} args - Arguments to create a Theme.
     * @example
     * // Create one Theme
     * const Theme = await prisma.theme.create({
     *   data: {
     *     // ... data to create a Theme
     *   }
     * })
     * 
     */
    create<T extends ThemeCreateArgs>(args: SelectSubset<T, ThemeCreateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Themes.
     * @param {ThemeCreateManyArgs} args - Arguments to create many Themes.
     * @example
     * // Create many Themes
     * const theme = await prisma.theme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeCreateManyArgs>(args?: SelectSubset<T, ThemeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Theme.
     * @param {ThemeDeleteArgs} args - Arguments to delete one Theme.
     * @example
     * // Delete one Theme
     * const Theme = await prisma.theme.delete({
     *   where: {
     *     // ... filter to delete one Theme
     *   }
     * })
     * 
     */
    delete<T extends ThemeDeleteArgs>(args: SelectSubset<T, ThemeDeleteArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Theme.
     * @param {ThemeUpdateArgs} args - Arguments to update one Theme.
     * @example
     * // Update one Theme
     * const theme = await prisma.theme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeUpdateArgs>(args: SelectSubset<T, ThemeUpdateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Themes.
     * @param {ThemeDeleteManyArgs} args - Arguments to filter Themes to delete.
     * @example
     * // Delete a few Themes
     * const { count } = await prisma.theme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeDeleteManyArgs>(args?: SelectSubset<T, ThemeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeUpdateManyArgs>(args: SelectSubset<T, ThemeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Theme.
     * @param {ThemeUpsertArgs} args - Arguments to update or create a Theme.
     * @example
     * // Update or create a Theme
     * const theme = await prisma.theme.upsert({
     *   create: {
     *     // ... data to create a Theme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theme we want to update
     *   }
     * })
     */
    upsert<T extends ThemeUpsertArgs>(args: SelectSubset<T, ThemeUpsertArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeCountArgs} args - Arguments to filter Themes to count.
     * @example
     * // Count the number of Themes
     * const count = await prisma.theme.count({
     *   where: {
     *     // ... the filter for the Themes we want to count
     *   }
     * })
    **/
    count<T extends ThemeCountArgs>(
      args?: Subset<T, ThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeAggregateArgs>(args: Subset<T, ThemeAggregateArgs>): Prisma.PrismaPromise<GetThemeAggregateType<T>>

    /**
     * Group by Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theme model
   */
  readonly fields: ThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Theme$userArgs<ExtArgs> = {}>(args?: Subset<T, Theme$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usersUsingThisTheme<T extends Theme$usersUsingThisThemeArgs<ExtArgs> = {}>(args?: Subset<T, Theme$usersUsingThisThemeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerUsingThisTheme<T extends Theme$customerUsingThisThemeArgs<ExtArgs> = {}>(args?: Subset<T, Theme$customerUsingThisThemeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Theme model
   */
  interface ThemeFieldRefs {
    readonly name: FieldRef<"Theme", 'String'>
    readonly primaryColor: FieldRef<"Theme", 'String'>
    readonly secondaryColor: FieldRef<"Theme", 'String'>
    readonly accentColor: FieldRef<"Theme", 'String'>
    readonly neutralColor: FieldRef<"Theme", 'String'>
    readonly isSystem: FieldRef<"Theme", 'Boolean'>
    readonly isPublic: FieldRef<"Theme", 'Boolean'>
    readonly createdUserDocument: FieldRef<"Theme", 'String'>
    readonly createdAt: FieldRef<"Theme", 'DateTime'>
    readonly updatedAt: FieldRef<"Theme", 'DateTime'>
    readonly updatedBy: FieldRef<"Theme", 'String'>
    readonly deletedAt: FieldRef<"Theme", 'DateTime'>
    readonly deletedBy: FieldRef<"Theme", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Theme findUnique
   */
  export type ThemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findUniqueOrThrow
   */
  export type ThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findFirst
   */
  export type ThemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findFirstOrThrow
   */
  export type ThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findMany
   */
  export type ThemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Themes to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme create
   */
  export type ThemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to create a Theme.
     */
    data: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
  }

  /**
   * Theme createMany
   */
  export type ThemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Theme update
   */
  export type ThemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to update a Theme.
     */
    data: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
    /**
     * Choose, which Theme to update.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme updateMany
   */
  export type ThemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to update.
     */
    limit?: number
  }

  /**
   * Theme upsert
   */
  export type ThemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The filter to search for the Theme to update in case it exists.
     */
    where: ThemeWhereUniqueInput
    /**
     * In case the Theme found by the `where` argument doesn't exist, create a new Theme with this data.
     */
    create: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
    /**
     * In case the Theme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
  }

  /**
   * Theme delete
   */
  export type ThemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter which Theme to delete.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme deleteMany
   */
  export type ThemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themes to delete
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to delete.
     */
    limit?: number
  }

  /**
   * Theme.user
   */
  export type Theme$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Theme.usersUsingThisTheme
   */
  export type Theme$usersUsingThisThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Theme.customerUsingThisTheme
   */
  export type Theme$customerUsingThisThemeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Theme without action
   */
  export type ThemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
  }


  /**
   * Model DocumentType
   */

  export type AggregateDocumentType = {
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  export type DocumentTypeAvgAggregateOutputType = {
    digitLength: number | null
  }

  export type DocumentTypeSumAggregateOutputType = {
    digitLength: number | null
  }

  export type DocumentTypeMinAggregateOutputType = {
    name: string | null
    description: string | null
    digitLength: number | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DocumentTypeMaxAggregateOutputType = {
    name: string | null
    description: string | null
    digitLength: number | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type DocumentTypeCountAggregateOutputType = {
    name: number
    description: number
    digitLength: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type DocumentTypeAvgAggregateInputType = {
    digitLength?: true
  }

  export type DocumentTypeSumAggregateInputType = {
    digitLength?: true
  }

  export type DocumentTypeMinAggregateInputType = {
    name?: true
    description?: true
    digitLength?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DocumentTypeMaxAggregateInputType = {
    name?: true
    description?: true
    digitLength?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type DocumentTypeCountAggregateInputType = {
    name?: true
    description?: true
    digitLength?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type DocumentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentType to aggregate.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTypes
    **/
    _count?: true | DocumentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTypeMaxAggregateInputType
  }

  export type GetDocumentTypeAggregateType<T extends DocumentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentType[P]>
      : GetScalarType<T[P], AggregateDocumentType[P]>
  }




  export type DocumentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTypeWhereInput
    orderBy?: DocumentTypeOrderByWithAggregationInput | DocumentTypeOrderByWithAggregationInput[]
    by: DocumentTypeScalarFieldEnum[] | DocumentTypeScalarFieldEnum
    having?: DocumentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTypeCountAggregateInputType | true
    _avg?: DocumentTypeAvgAggregateInputType
    _sum?: DocumentTypeSumAggregateInputType
    _min?: DocumentTypeMinAggregateInputType
    _max?: DocumentTypeMaxAggregateInputType
  }

  export type DocumentTypeGroupByOutputType = {
    name: string
    description: string | null
    digitLength: number
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: DocumentTypeCountAggregateOutputType | null
    _avg: DocumentTypeAvgAggregateOutputType | null
    _sum: DocumentTypeSumAggregateOutputType | null
    _min: DocumentTypeMinAggregateOutputType | null
    _max: DocumentTypeMaxAggregateOutputType | null
  }

  type GetDocumentTypeGroupByPayload<T extends DocumentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTypeGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    digitLength?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    customers?: boolean | DocumentType$customersArgs<ExtArgs>
    users?: boolean | DocumentType$usersArgs<ExtArgs>
    _count?: boolean | DocumentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentType"]>



  export type DocumentTypeSelectScalar = {
    name?: boolean
    description?: boolean
    digitLength?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type DocumentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "digitLength" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["documentType"]>
  export type DocumentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | DocumentType$customersArgs<ExtArgs>
    users?: boolean | DocumentType$usersArgs<ExtArgs>
    _count?: boolean | DocumentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DocumentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentType"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      digitLength: number
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["documentType"]>
    composites: {}
  }

  type DocumentTypeGetPayload<S extends boolean | null | undefined | DocumentTypeDefaultArgs> = $Result.GetResult<Prisma.$DocumentTypePayload, S>

  type DocumentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentTypeCountAggregateInputType | true
    }

  export interface DocumentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentType'], meta: { name: 'DocumentType' } }
    /**
     * Find zero or one DocumentType that matches the filter.
     * @param {DocumentTypeFindUniqueArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTypeFindUniqueArgs>(args: SelectSubset<T, DocumentTypeFindUniqueArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentTypeFindUniqueOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTypeFindFirstArgs>(args?: SelectSubset<T, DocumentTypeFindFirstArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindFirstOrThrowArgs} args - Arguments to find a DocumentType
     * @example
     * // Get one DocumentType
     * const documentType = await prisma.documentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTypes
     * const documentTypes = await prisma.documentType.findMany()
     * 
     * // Get first 10 DocumentTypes
     * const documentTypes = await prisma.documentType.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const documentTypeWithNameOnly = await prisma.documentType.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends DocumentTypeFindManyArgs>(args?: SelectSubset<T, DocumentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentType.
     * @param {DocumentTypeCreateArgs} args - Arguments to create a DocumentType.
     * @example
     * // Create one DocumentType
     * const DocumentType = await prisma.documentType.create({
     *   data: {
     *     // ... data to create a DocumentType
     *   }
     * })
     * 
     */
    create<T extends DocumentTypeCreateArgs>(args: SelectSubset<T, DocumentTypeCreateArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentTypes.
     * @param {DocumentTypeCreateManyArgs} args - Arguments to create many DocumentTypes.
     * @example
     * // Create many DocumentTypes
     * const documentType = await prisma.documentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTypeCreateManyArgs>(args?: SelectSubset<T, DocumentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentType.
     * @param {DocumentTypeDeleteArgs} args - Arguments to delete one DocumentType.
     * @example
     * // Delete one DocumentType
     * const DocumentType = await prisma.documentType.delete({
     *   where: {
     *     // ... filter to delete one DocumentType
     *   }
     * })
     * 
     */
    delete<T extends DocumentTypeDeleteArgs>(args: SelectSubset<T, DocumentTypeDeleteArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentType.
     * @param {DocumentTypeUpdateArgs} args - Arguments to update one DocumentType.
     * @example
     * // Update one DocumentType
     * const documentType = await prisma.documentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTypeUpdateArgs>(args: SelectSubset<T, DocumentTypeUpdateArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentTypes.
     * @param {DocumentTypeDeleteManyArgs} args - Arguments to filter DocumentTypes to delete.
     * @example
     * // Delete a few DocumentTypes
     * const { count } = await prisma.documentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTypeDeleteManyArgs>(args?: SelectSubset<T, DocumentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTypes
     * const documentType = await prisma.documentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTypeUpdateManyArgs>(args: SelectSubset<T, DocumentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentType.
     * @param {DocumentTypeUpsertArgs} args - Arguments to update or create a DocumentType.
     * @example
     * // Update or create a DocumentType
     * const documentType = await prisma.documentType.upsert({
     *   create: {
     *     // ... data to create a DocumentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentType we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTypeUpsertArgs>(args: SelectSubset<T, DocumentTypeUpsertArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeCountArgs} args - Arguments to filter DocumentTypes to count.
     * @example
     * // Count the number of DocumentTypes
     * const count = await prisma.documentType.count({
     *   where: {
     *     // ... the filter for the DocumentTypes we want to count
     *   }
     * })
    **/
    count<T extends DocumentTypeCountArgs>(
      args?: Subset<T, DocumentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTypeAggregateArgs>(args: Subset<T, DocumentTypeAggregateArgs>): Prisma.PrismaPromise<GetDocumentTypeAggregateType<T>>

    /**
     * Group by DocumentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTypeGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentType model
   */
  readonly fields: DocumentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends DocumentType$customersArgs<ExtArgs> = {}>(args?: Subset<T, DocumentType$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends DocumentType$usersArgs<ExtArgs> = {}>(args?: Subset<T, DocumentType$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentType model
   */
  interface DocumentTypeFieldRefs {
    readonly name: FieldRef<"DocumentType", 'String'>
    readonly description: FieldRef<"DocumentType", 'String'>
    readonly digitLength: FieldRef<"DocumentType", 'Int'>
    readonly color: FieldRef<"DocumentType", 'String'>
    readonly isActive: FieldRef<"DocumentType", 'Boolean'>
    readonly createdAt: FieldRef<"DocumentType", 'DateTime'>
    readonly createdBy: FieldRef<"DocumentType", 'String'>
    readonly updatedAt: FieldRef<"DocumentType", 'DateTime'>
    readonly updatedBy: FieldRef<"DocumentType", 'String'>
    readonly deletedAt: FieldRef<"DocumentType", 'DateTime'>
    readonly deletedBy: FieldRef<"DocumentType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentType findUnique
   */
  export type DocumentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType findUniqueOrThrow
   */
  export type DocumentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType findFirst
   */
  export type DocumentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType findFirstOrThrow
   */
  export type DocumentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentType to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTypes.
     */
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType findMany
   */
  export type DocumentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTypes to fetch.
     */
    where?: DocumentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTypes to fetch.
     */
    orderBy?: DocumentTypeOrderByWithRelationInput | DocumentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTypes.
     */
    cursor?: DocumentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTypes.
     */
    skip?: number
    distinct?: DocumentTypeScalarFieldEnum | DocumentTypeScalarFieldEnum[]
  }

  /**
   * DocumentType create
   */
  export type DocumentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentType.
     */
    data: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
  }

  /**
   * DocumentType createMany
   */
  export type DocumentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTypes.
     */
    data: DocumentTypeCreateManyInput | DocumentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentType update
   */
  export type DocumentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentType.
     */
    data: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
    /**
     * Choose, which DocumentType to update.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType updateMany
   */
  export type DocumentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTypes.
     */
    data: XOR<DocumentTypeUpdateManyMutationInput, DocumentTypeUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTypes to update
     */
    where?: DocumentTypeWhereInput
    /**
     * Limit how many DocumentTypes to update.
     */
    limit?: number
  }

  /**
   * DocumentType upsert
   */
  export type DocumentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentType to update in case it exists.
     */
    where: DocumentTypeWhereUniqueInput
    /**
     * In case the DocumentType found by the `where` argument doesn't exist, create a new DocumentType with this data.
     */
    create: XOR<DocumentTypeCreateInput, DocumentTypeUncheckedCreateInput>
    /**
     * In case the DocumentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTypeUpdateInput, DocumentTypeUncheckedUpdateInput>
  }

  /**
   * DocumentType delete
   */
  export type DocumentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
    /**
     * Filter which DocumentType to delete.
     */
    where: DocumentTypeWhereUniqueInput
  }

  /**
   * DocumentType deleteMany
   */
  export type DocumentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTypes to delete
     */
    where?: DocumentTypeWhereInput
    /**
     * Limit how many DocumentTypes to delete.
     */
    limit?: number
  }

  /**
   * DocumentType.customers
   */
  export type DocumentType$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * DocumentType.users
   */
  export type DocumentType$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * DocumentType without action
   */
  export type DocumentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentType
     */
    select?: DocumentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentType
     */
    omit?: DocumentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTypeInclude<ExtArgs> | null
  }


  /**
   * Model AccountStatus
   */

  export type AggregateAccountStatus = {
    _count: AccountStatusCountAggregateOutputType | null
    _min: AccountStatusMinAggregateOutputType | null
    _max: AccountStatusMaxAggregateOutputType | null
  }

  export type AccountStatusMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AccountStatusMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type AccountStatusCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type AccountStatusMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AccountStatusMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type AccountStatusCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type AccountStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountStatus to aggregate.
     */
    where?: AccountStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountStatuses to fetch.
     */
    orderBy?: AccountStatusOrderByWithRelationInput | AccountStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountStatuses
    **/
    _count?: true | AccountStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountStatusMaxAggregateInputType
  }

  export type GetAccountStatusAggregateType<T extends AccountStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountStatus[P]>
      : GetScalarType<T[P], AggregateAccountStatus[P]>
  }




  export type AccountStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountStatusWhereInput
    orderBy?: AccountStatusOrderByWithAggregationInput | AccountStatusOrderByWithAggregationInput[]
    by: AccountStatusScalarFieldEnum[] | AccountStatusScalarFieldEnum
    having?: AccountStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountStatusCountAggregateInputType | true
    _min?: AccountStatusMinAggregateInputType
    _max?: AccountStatusMaxAggregateInputType
  }

  export type AccountStatusGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: AccountStatusCountAggregateOutputType | null
    _min: AccountStatusMinAggregateOutputType | null
    _max: AccountStatusMaxAggregateOutputType | null
  }

  type GetAccountStatusGroupByPayload<T extends AccountStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountStatusGroupByOutputType[P]>
            : GetScalarType<T[P], AccountStatusGroupByOutputType[P]>
        }
      >
    >


  export type AccountStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    users?: boolean | AccountStatus$usersArgs<ExtArgs>
    customers?: boolean | AccountStatus$customersArgs<ExtArgs>
    _count?: boolean | AccountStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountStatus"]>



  export type AccountStatusSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type AccountStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["accountStatus"]>
  export type AccountStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AccountStatus$usersArgs<ExtArgs>
    customers?: boolean | AccountStatus$customersArgs<ExtArgs>
    _count?: boolean | AccountStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountStatus"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["accountStatus"]>
    composites: {}
  }

  type AccountStatusGetPayload<S extends boolean | null | undefined | AccountStatusDefaultArgs> = $Result.GetResult<Prisma.$AccountStatusPayload, S>

  type AccountStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountStatusCountAggregateInputType | true
    }

  export interface AccountStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountStatus'], meta: { name: 'AccountStatus' } }
    /**
     * Find zero or one AccountStatus that matches the filter.
     * @param {AccountStatusFindUniqueArgs} args - Arguments to find a AccountStatus
     * @example
     * // Get one AccountStatus
     * const accountStatus = await prisma.accountStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountStatusFindUniqueArgs>(args: SelectSubset<T, AccountStatusFindUniqueArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountStatusFindUniqueOrThrowArgs} args - Arguments to find a AccountStatus
     * @example
     * // Get one AccountStatus
     * const accountStatus = await prisma.accountStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusFindFirstArgs} args - Arguments to find a AccountStatus
     * @example
     * // Get one AccountStatus
     * const accountStatus = await prisma.accountStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountStatusFindFirstArgs>(args?: SelectSubset<T, AccountStatusFindFirstArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusFindFirstOrThrowArgs} args - Arguments to find a AccountStatus
     * @example
     * // Get one AccountStatus
     * const accountStatus = await prisma.accountStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountStatuses
     * const accountStatuses = await prisma.accountStatus.findMany()
     * 
     * // Get first 10 AccountStatuses
     * const accountStatuses = await prisma.accountStatus.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const accountStatusWithCodeOnly = await prisma.accountStatus.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends AccountStatusFindManyArgs>(args?: SelectSubset<T, AccountStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountStatus.
     * @param {AccountStatusCreateArgs} args - Arguments to create a AccountStatus.
     * @example
     * // Create one AccountStatus
     * const AccountStatus = await prisma.accountStatus.create({
     *   data: {
     *     // ... data to create a AccountStatus
     *   }
     * })
     * 
     */
    create<T extends AccountStatusCreateArgs>(args: SelectSubset<T, AccountStatusCreateArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountStatuses.
     * @param {AccountStatusCreateManyArgs} args - Arguments to create many AccountStatuses.
     * @example
     * // Create many AccountStatuses
     * const accountStatus = await prisma.accountStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountStatusCreateManyArgs>(args?: SelectSubset<T, AccountStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountStatus.
     * @param {AccountStatusDeleteArgs} args - Arguments to delete one AccountStatus.
     * @example
     * // Delete one AccountStatus
     * const AccountStatus = await prisma.accountStatus.delete({
     *   where: {
     *     // ... filter to delete one AccountStatus
     *   }
     * })
     * 
     */
    delete<T extends AccountStatusDeleteArgs>(args: SelectSubset<T, AccountStatusDeleteArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountStatus.
     * @param {AccountStatusUpdateArgs} args - Arguments to update one AccountStatus.
     * @example
     * // Update one AccountStatus
     * const accountStatus = await prisma.accountStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountStatusUpdateArgs>(args: SelectSubset<T, AccountStatusUpdateArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountStatuses.
     * @param {AccountStatusDeleteManyArgs} args - Arguments to filter AccountStatuses to delete.
     * @example
     * // Delete a few AccountStatuses
     * const { count } = await prisma.accountStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountStatusDeleteManyArgs>(args?: SelectSubset<T, AccountStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountStatuses
     * const accountStatus = await prisma.accountStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountStatusUpdateManyArgs>(args: SelectSubset<T, AccountStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountStatus.
     * @param {AccountStatusUpsertArgs} args - Arguments to update or create a AccountStatus.
     * @example
     * // Update or create a AccountStatus
     * const accountStatus = await prisma.accountStatus.upsert({
     *   create: {
     *     // ... data to create a AccountStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountStatus we want to update
     *   }
     * })
     */
    upsert<T extends AccountStatusUpsertArgs>(args: SelectSubset<T, AccountStatusUpsertArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusCountArgs} args - Arguments to filter AccountStatuses to count.
     * @example
     * // Count the number of AccountStatuses
     * const count = await prisma.accountStatus.count({
     *   where: {
     *     // ... the filter for the AccountStatuses we want to count
     *   }
     * })
    **/
    count<T extends AccountStatusCountArgs>(
      args?: Subset<T, AccountStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountStatusAggregateArgs>(args: Subset<T, AccountStatusAggregateArgs>): Prisma.PrismaPromise<GetAccountStatusAggregateType<T>>

    /**
     * Group by AccountStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountStatusGroupByArgs['orderBy'] }
        : { orderBy?: AccountStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountStatus model
   */
  readonly fields: AccountStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends AccountStatus$usersArgs<ExtArgs> = {}>(args?: Subset<T, AccountStatus$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends AccountStatus$customersArgs<ExtArgs> = {}>(args?: Subset<T, AccountStatus$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountStatus model
   */
  interface AccountStatusFieldRefs {
    readonly code: FieldRef<"AccountStatus", 'String'>
    readonly name: FieldRef<"AccountStatus", 'String'>
    readonly description: FieldRef<"AccountStatus", 'String'>
    readonly color: FieldRef<"AccountStatus", 'String'>
    readonly createdAt: FieldRef<"AccountStatus", 'DateTime'>
    readonly createdBy: FieldRef<"AccountStatus", 'String'>
    readonly updatedAt: FieldRef<"AccountStatus", 'DateTime'>
    readonly updatedBy: FieldRef<"AccountStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountStatus findUnique
   */
  export type AccountStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter, which AccountStatus to fetch.
     */
    where: AccountStatusWhereUniqueInput
  }

  /**
   * AccountStatus findUniqueOrThrow
   */
  export type AccountStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter, which AccountStatus to fetch.
     */
    where: AccountStatusWhereUniqueInput
  }

  /**
   * AccountStatus findFirst
   */
  export type AccountStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter, which AccountStatus to fetch.
     */
    where?: AccountStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountStatuses to fetch.
     */
    orderBy?: AccountStatusOrderByWithRelationInput | AccountStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountStatuses.
     */
    cursor?: AccountStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountStatuses.
     */
    distinct?: AccountStatusScalarFieldEnum | AccountStatusScalarFieldEnum[]
  }

  /**
   * AccountStatus findFirstOrThrow
   */
  export type AccountStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter, which AccountStatus to fetch.
     */
    where?: AccountStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountStatuses to fetch.
     */
    orderBy?: AccountStatusOrderByWithRelationInput | AccountStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountStatuses.
     */
    cursor?: AccountStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountStatuses.
     */
    distinct?: AccountStatusScalarFieldEnum | AccountStatusScalarFieldEnum[]
  }

  /**
   * AccountStatus findMany
   */
  export type AccountStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter, which AccountStatuses to fetch.
     */
    where?: AccountStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountStatuses to fetch.
     */
    orderBy?: AccountStatusOrderByWithRelationInput | AccountStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountStatuses.
     */
    cursor?: AccountStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountStatuses.
     */
    skip?: number
    distinct?: AccountStatusScalarFieldEnum | AccountStatusScalarFieldEnum[]
  }

  /**
   * AccountStatus create
   */
  export type AccountStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountStatus.
     */
    data: XOR<AccountStatusCreateInput, AccountStatusUncheckedCreateInput>
  }

  /**
   * AccountStatus createMany
   */
  export type AccountStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountStatuses.
     */
    data: AccountStatusCreateManyInput | AccountStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountStatus update
   */
  export type AccountStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountStatus.
     */
    data: XOR<AccountStatusUpdateInput, AccountStatusUncheckedUpdateInput>
    /**
     * Choose, which AccountStatus to update.
     */
    where: AccountStatusWhereUniqueInput
  }

  /**
   * AccountStatus updateMany
   */
  export type AccountStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountStatuses.
     */
    data: XOR<AccountStatusUpdateManyMutationInput, AccountStatusUncheckedUpdateManyInput>
    /**
     * Filter which AccountStatuses to update
     */
    where?: AccountStatusWhereInput
    /**
     * Limit how many AccountStatuses to update.
     */
    limit?: number
  }

  /**
   * AccountStatus upsert
   */
  export type AccountStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountStatus to update in case it exists.
     */
    where: AccountStatusWhereUniqueInput
    /**
     * In case the AccountStatus found by the `where` argument doesn't exist, create a new AccountStatus with this data.
     */
    create: XOR<AccountStatusCreateInput, AccountStatusUncheckedCreateInput>
    /**
     * In case the AccountStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountStatusUpdateInput, AccountStatusUncheckedUpdateInput>
  }

  /**
   * AccountStatus delete
   */
  export type AccountStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
    /**
     * Filter which AccountStatus to delete.
     */
    where: AccountStatusWhereUniqueInput
  }

  /**
   * AccountStatus deleteMany
   */
  export type AccountStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountStatuses to delete
     */
    where?: AccountStatusWhereInput
    /**
     * Limit how many AccountStatuses to delete.
     */
    limit?: number
  }

  /**
   * AccountStatus.users
   */
  export type AccountStatus$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * AccountStatus.customers
   */
  export type AccountStatus$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * AccountStatus without action
   */
  export type AccountStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountStatus
     */
    select?: AccountStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountStatus
     */
    omit?: AccountStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountStatusInclude<ExtArgs> | null
  }


  /**
   * Model PermissionCategory
   */

  export type AggregatePermissionCategory = {
    _count: PermissionCategoryCountAggregateOutputType | null
    _min: PermissionCategoryMinAggregateOutputType | null
    _max: PermissionCategoryMaxAggregateOutputType | null
  }

  export type PermissionCategoryMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PermissionCategoryMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PermissionCategoryCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type PermissionCategoryMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PermissionCategoryMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PermissionCategoryCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type PermissionCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionCategory to aggregate.
     */
    where?: PermissionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionCategories to fetch.
     */
    orderBy?: PermissionCategoryOrderByWithRelationInput | PermissionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermissionCategories
    **/
    _count?: true | PermissionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionCategoryMaxAggregateInputType
  }

  export type GetPermissionCategoryAggregateType<T extends PermissionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionCategory[P]>
      : GetScalarType<T[P], AggregatePermissionCategory[P]>
  }




  export type PermissionCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionCategoryWhereInput
    orderBy?: PermissionCategoryOrderByWithAggregationInput | PermissionCategoryOrderByWithAggregationInput[]
    by: PermissionCategoryScalarFieldEnum[] | PermissionCategoryScalarFieldEnum
    having?: PermissionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCategoryCountAggregateInputType | true
    _min?: PermissionCategoryMinAggregateInputType
    _max?: PermissionCategoryMaxAggregateInputType
  }

  export type PermissionCategoryGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: PermissionCategoryCountAggregateOutputType | null
    _min: PermissionCategoryMinAggregateOutputType | null
    _max: PermissionCategoryMaxAggregateOutputType | null
  }

  type GetPermissionCategoryGroupByPayload<T extends PermissionCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PermissionCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    permissions?: boolean | PermissionCategory$permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionCategory"]>



  export type PermissionCategorySelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type PermissionCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["permissionCategory"]>
  export type PermissionCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | PermissionCategory$permissionsArgs<ExtArgs>
    _count?: boolean | PermissionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermissionCategory"
    objects: {
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["permissionCategory"]>
    composites: {}
  }

  type PermissionCategoryGetPayload<S extends boolean | null | undefined | PermissionCategoryDefaultArgs> = $Result.GetResult<Prisma.$PermissionCategoryPayload, S>

  type PermissionCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCategoryCountAggregateInputType | true
    }

  export interface PermissionCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermissionCategory'], meta: { name: 'PermissionCategory' } }
    /**
     * Find zero or one PermissionCategory that matches the filter.
     * @param {PermissionCategoryFindUniqueArgs} args - Arguments to find a PermissionCategory
     * @example
     * // Get one PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionCategoryFindUniqueArgs>(args: SelectSubset<T, PermissionCategoryFindUniqueArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PermissionCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionCategoryFindUniqueOrThrowArgs} args - Arguments to find a PermissionCategory
     * @example
     * // Get one PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryFindFirstArgs} args - Arguments to find a PermissionCategory
     * @example
     * // Get one PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionCategoryFindFirstArgs>(args?: SelectSubset<T, PermissionCategoryFindFirstArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryFindFirstOrThrowArgs} args - Arguments to find a PermissionCategory
     * @example
     * // Get one PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PermissionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissionCategories
     * const permissionCategories = await prisma.permissionCategory.findMany()
     * 
     * // Get first 10 PermissionCategories
     * const permissionCategories = await prisma.permissionCategory.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const permissionCategoryWithCodeOnly = await prisma.permissionCategory.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends PermissionCategoryFindManyArgs>(args?: SelectSubset<T, PermissionCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PermissionCategory.
     * @param {PermissionCategoryCreateArgs} args - Arguments to create a PermissionCategory.
     * @example
     * // Create one PermissionCategory
     * const PermissionCategory = await prisma.permissionCategory.create({
     *   data: {
     *     // ... data to create a PermissionCategory
     *   }
     * })
     * 
     */
    create<T extends PermissionCategoryCreateArgs>(args: SelectSubset<T, PermissionCategoryCreateArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PermissionCategories.
     * @param {PermissionCategoryCreateManyArgs} args - Arguments to create many PermissionCategories.
     * @example
     * // Create many PermissionCategories
     * const permissionCategory = await prisma.permissionCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCategoryCreateManyArgs>(args?: SelectSubset<T, PermissionCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PermissionCategory.
     * @param {PermissionCategoryDeleteArgs} args - Arguments to delete one PermissionCategory.
     * @example
     * // Delete one PermissionCategory
     * const PermissionCategory = await prisma.permissionCategory.delete({
     *   where: {
     *     // ... filter to delete one PermissionCategory
     *   }
     * })
     * 
     */
    delete<T extends PermissionCategoryDeleteArgs>(args: SelectSubset<T, PermissionCategoryDeleteArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PermissionCategory.
     * @param {PermissionCategoryUpdateArgs} args - Arguments to update one PermissionCategory.
     * @example
     * // Update one PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionCategoryUpdateArgs>(args: SelectSubset<T, PermissionCategoryUpdateArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PermissionCategories.
     * @param {PermissionCategoryDeleteManyArgs} args - Arguments to filter PermissionCategories to delete.
     * @example
     * // Delete a few PermissionCategories
     * const { count } = await prisma.permissionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionCategoryDeleteManyArgs>(args?: SelectSubset<T, PermissionCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissionCategories
     * const permissionCategory = await prisma.permissionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionCategoryUpdateManyArgs>(args: SelectSubset<T, PermissionCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PermissionCategory.
     * @param {PermissionCategoryUpsertArgs} args - Arguments to update or create a PermissionCategory.
     * @example
     * // Update or create a PermissionCategory
     * const permissionCategory = await prisma.permissionCategory.upsert({
     *   create: {
     *     // ... data to create a PermissionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissionCategory we want to update
     *   }
     * })
     */
    upsert<T extends PermissionCategoryUpsertArgs>(args: SelectSubset<T, PermissionCategoryUpsertArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PermissionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryCountArgs} args - Arguments to filter PermissionCategories to count.
     * @example
     * // Count the number of PermissionCategories
     * const count = await prisma.permissionCategory.count({
     *   where: {
     *     // ... the filter for the PermissionCategories we want to count
     *   }
     * })
    **/
    count<T extends PermissionCategoryCountArgs>(
      args?: Subset<T, PermissionCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionCategoryAggregateArgs>(args: Subset<T, PermissionCategoryAggregateArgs>): Prisma.PrismaPromise<GetPermissionCategoryAggregateType<T>>

    /**
     * Group by PermissionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PermissionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermissionCategory model
   */
  readonly fields: PermissionCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermissionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends PermissionCategory$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, PermissionCategory$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermissionCategory model
   */
  interface PermissionCategoryFieldRefs {
    readonly code: FieldRef<"PermissionCategory", 'String'>
    readonly name: FieldRef<"PermissionCategory", 'String'>
    readonly description: FieldRef<"PermissionCategory", 'String'>
    readonly color: FieldRef<"PermissionCategory", 'String'>
    readonly createdAt: FieldRef<"PermissionCategory", 'DateTime'>
    readonly createdBy: FieldRef<"PermissionCategory", 'String'>
    readonly updatedAt: FieldRef<"PermissionCategory", 'DateTime'>
    readonly updatedBy: FieldRef<"PermissionCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PermissionCategory findUnique
   */
  export type PermissionCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PermissionCategory to fetch.
     */
    where: PermissionCategoryWhereUniqueInput
  }

  /**
   * PermissionCategory findUniqueOrThrow
   */
  export type PermissionCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PermissionCategory to fetch.
     */
    where: PermissionCategoryWhereUniqueInput
  }

  /**
   * PermissionCategory findFirst
   */
  export type PermissionCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PermissionCategory to fetch.
     */
    where?: PermissionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionCategories to fetch.
     */
    orderBy?: PermissionCategoryOrderByWithRelationInput | PermissionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionCategories.
     */
    cursor?: PermissionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionCategories.
     */
    distinct?: PermissionCategoryScalarFieldEnum | PermissionCategoryScalarFieldEnum[]
  }

  /**
   * PermissionCategory findFirstOrThrow
   */
  export type PermissionCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PermissionCategory to fetch.
     */
    where?: PermissionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionCategories to fetch.
     */
    orderBy?: PermissionCategoryOrderByWithRelationInput | PermissionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionCategories.
     */
    cursor?: PermissionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionCategories.
     */
    distinct?: PermissionCategoryScalarFieldEnum | PermissionCategoryScalarFieldEnum[]
  }

  /**
   * PermissionCategory findMany
   */
  export type PermissionCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PermissionCategories to fetch.
     */
    where?: PermissionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionCategories to fetch.
     */
    orderBy?: PermissionCategoryOrderByWithRelationInput | PermissionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermissionCategories.
     */
    cursor?: PermissionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionCategories.
     */
    skip?: number
    distinct?: PermissionCategoryScalarFieldEnum | PermissionCategoryScalarFieldEnum[]
  }

  /**
   * PermissionCategory create
   */
  export type PermissionCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PermissionCategory.
     */
    data: XOR<PermissionCategoryCreateInput, PermissionCategoryUncheckedCreateInput>
  }

  /**
   * PermissionCategory createMany
   */
  export type PermissionCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermissionCategories.
     */
    data: PermissionCategoryCreateManyInput | PermissionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermissionCategory update
   */
  export type PermissionCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PermissionCategory.
     */
    data: XOR<PermissionCategoryUpdateInput, PermissionCategoryUncheckedUpdateInput>
    /**
     * Choose, which PermissionCategory to update.
     */
    where: PermissionCategoryWhereUniqueInput
  }

  /**
   * PermissionCategory updateMany
   */
  export type PermissionCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermissionCategories.
     */
    data: XOR<PermissionCategoryUpdateManyMutationInput, PermissionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PermissionCategories to update
     */
    where?: PermissionCategoryWhereInput
    /**
     * Limit how many PermissionCategories to update.
     */
    limit?: number
  }

  /**
   * PermissionCategory upsert
   */
  export type PermissionCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PermissionCategory to update in case it exists.
     */
    where: PermissionCategoryWhereUniqueInput
    /**
     * In case the PermissionCategory found by the `where` argument doesn't exist, create a new PermissionCategory with this data.
     */
    create: XOR<PermissionCategoryCreateInput, PermissionCategoryUncheckedCreateInput>
    /**
     * In case the PermissionCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionCategoryUpdateInput, PermissionCategoryUncheckedUpdateInput>
  }

  /**
   * PermissionCategory delete
   */
  export type PermissionCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
    /**
     * Filter which PermissionCategory to delete.
     */
    where: PermissionCategoryWhereUniqueInput
  }

  /**
   * PermissionCategory deleteMany
   */
  export type PermissionCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionCategories to delete
     */
    where?: PermissionCategoryWhereInput
    /**
     * Limit how many PermissionCategories to delete.
     */
    limit?: number
  }

  /**
   * PermissionCategory.permissions
   */
  export type PermissionCategory$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * PermissionCategory without action
   */
  export type PermissionCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCategory
     */
    select?: PermissionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionCategory
     */
    omit?: PermissionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    categoryCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    categoryCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type PermissionCountAggregateOutputType = {
    code: number
    name: number
    description: number
    categoryCode: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    categoryCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PermissionMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    categoryCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type PermissionCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    categoryCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    code: string
    name: string
    description: string | null
    categoryCode: string
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    categoryCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    category?: boolean | PermissionCategoryDefaultArgs<ExtArgs>
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    categoryCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "categoryCode" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | PermissionCategoryDefaultArgs<ExtArgs>
    rolePermissions?: boolean | Permission$rolePermissionsArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      category: Prisma.$PermissionCategoryPayload<ExtArgs>
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      categoryCode: string
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const permissionWithCodeOnly = await prisma.permission.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends PermissionCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionCategoryDefaultArgs<ExtArgs>>): Prisma__PermissionCategoryClient<$Result.GetResult<Prisma.$PermissionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rolePermissions<T extends Permission$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly code: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly categoryCode: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
    readonly createdBy: FieldRef<"Permission", 'String'>
    readonly updatedAt: FieldRef<"Permission", 'DateTime'>
    readonly updatedBy: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.rolePermissions
   */
  export type Permission$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RoleMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RoleCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RoleMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RoleCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolePermissions?: boolean | Role$rolePermissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      rolePermissions: Prisma.$RolePermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const roleWithNameOnly = await prisma.role.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolePermissions<T extends Role$rolePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly color: FieldRef<"Role", 'String'>
    readonly isActive: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly createdBy: FieldRef<"Role", 'String'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
    readonly updatedBy: FieldRef<"Role", 'String'>
    readonly deletedAt: FieldRef<"Role", 'DateTime'>
    readonly deletedBy: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.rolePermissions
   */
  export type Role$rolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionAvgAggregateOutputType = {
    id: number | null
  }

  export type RolePermissionSumAggregateOutputType = {
    id: number | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: number | null
    roleName: string | null
    permissionCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: number | null
    roleName: string | null
    permissionCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleName: number
    permissionCode: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type RolePermissionAvgAggregateInputType = {
    id?: true
  }

  export type RolePermissionSumAggregateInputType = {
    id?: true
  }

  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleName?: true
    permissionCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleName?: true
    permissionCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleName?: true
    permissionCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _avg?: RolePermissionAvgAggregateInputType
    _sum?: RolePermissionSumAggregateInputType
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: number
    roleName: string
    permissionCode: string
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: RolePermissionCountAggregateOutputType | null
    _avg: RolePermissionAvgAggregateOutputType | null
    _sum: RolePermissionSumAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleName?: boolean
    permissionCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    id?: boolean
    roleName?: boolean
    permissionCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleName" | "permissionCode" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleName: string
      permissionCode: string
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'Int'>
    readonly roleName: FieldRef<"RolePermission", 'String'>
    readonly permissionCode: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
    readonly createdBy: FieldRef<"RolePermission", 'String'>
    readonly updatedAt: FieldRef<"RolePermission", 'DateTime'>
    readonly updatedBy: FieldRef<"RolePermission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    salary: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    salary: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    documentNumber: string | null
    username: string | null
    email: string | null
    password: string | null
    pin: string | null
    fullName: string | null
    phoneNumber: string | null
    birthDate: Date | null
    hireDate: Date | null
    salary: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    documentTypeName: string | null
    roleName: string | null
    accountStatusCode: string | null
    themeName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type UserMaxAggregateOutputType = {
    documentNumber: string | null
    username: string | null
    email: string | null
    password: string | null
    pin: string | null
    fullName: string | null
    phoneNumber: string | null
    birthDate: Date | null
    hireDate: Date | null
    salary: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    documentTypeName: string | null
    roleName: string | null
    accountStatusCode: string | null
    themeName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type UserCountAggregateOutputType = {
    documentNumber: number
    username: number
    email: number
    password: number
    pin: number
    fullName: number
    phoneNumber: number
    birthDate: number
    hireDate: number
    salary: number
    emergencyContactName: number
    emergencyContactPhone: number
    documentTypeName: number
    roleName: number
    accountStatusCode: number
    themeName: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    salary?: true
  }

  export type UserSumAggregateInputType = {
    salary?: true
  }

  export type UserMinAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    pin?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    hireDate?: true
    salary?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    documentTypeName?: true
    roleName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type UserMaxAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    pin?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    hireDate?: true
    salary?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    documentTypeName?: true
    roleName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type UserCountAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    pin?: true
    fullName?: true
    phoneNumber?: true
    birthDate?: true
    hireDate?: true
    salary?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    documentTypeName?: true
    roleName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin: string | null
    fullName: string
    phoneNumber: string | null
    birthDate: Date | null
    hireDate: Date | null
    salary: Decimal | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode: string
    themeName: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    documentNumber?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    pin?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    birthDate?: boolean
    hireDate?: boolean
    salary?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    documentTypeName?: boolean
    roleName?: boolean
    accountStatusCode?: boolean
    themeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountStatus?: boolean | AccountStatusDefaultArgs<ExtArgs>
    theme?: boolean | User$themeArgs<ExtArgs>
    openedCashBoxes?: boolean | User$openedCashBoxesArgs<ExtArgs>
    closedCashBoxes?: boolean | User$closedCashBoxesArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    combinedTables?: boolean | User$combinedTablesArgs<ExtArgs>
    releasedTables?: boolean | User$releasedTablesArgs<ExtArgs>
    tablesSessionOpened?: boolean | User$tablesSessionOpenedArgs<ExtArgs>
    tablesSessionClosed?: boolean | User$tablesSessionClosedArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    ordersClosed?: boolean | User$ordersClosedArgs<ExtArgs>
    createdThemes?: boolean | User$createdThemesArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    documentNumber?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    pin?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    birthDate?: boolean
    hireDate?: boolean
    salary?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    documentTypeName?: boolean
    roleName?: boolean
    accountStatusCode?: boolean
    themeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"documentNumber" | "username" | "email" | "password" | "pin" | "fullName" | "phoneNumber" | "birthDate" | "hireDate" | "salary" | "emergencyContactName" | "emergencyContactPhone" | "documentTypeName" | "roleName" | "accountStatusCode" | "themeName" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    accountStatus?: boolean | AccountStatusDefaultArgs<ExtArgs>
    theme?: boolean | User$themeArgs<ExtArgs>
    openedCashBoxes?: boolean | User$openedCashBoxesArgs<ExtArgs>
    closedCashBoxes?: boolean | User$closedCashBoxesArgs<ExtArgs>
    inventoryMovements?: boolean | User$inventoryMovementsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    combinedTables?: boolean | User$combinedTablesArgs<ExtArgs>
    releasedTables?: boolean | User$releasedTablesArgs<ExtArgs>
    tablesSessionOpened?: boolean | User$tablesSessionOpenedArgs<ExtArgs>
    tablesSessionClosed?: boolean | User$tablesSessionClosedArgs<ExtArgs>
    ordersCreated?: boolean | User$ordersCreatedArgs<ExtArgs>
    ordersClosed?: boolean | User$ordersClosedArgs<ExtArgs>
    createdThemes?: boolean | User$createdThemesArgs<ExtArgs>
    paymentsReceived?: boolean | User$paymentsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      documentType: Prisma.$DocumentTypePayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
      accountStatus: Prisma.$AccountStatusPayload<ExtArgs>
      theme: Prisma.$ThemePayload<ExtArgs> | null
      openedCashBoxes: Prisma.$CashBoxPayload<ExtArgs>[]
      closedCashBoxes: Prisma.$CashBoxPayload<ExtArgs>[]
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      combinedTables: Prisma.$CombineTablePayload<ExtArgs>[]
      releasedTables: Prisma.$CombineTablePayload<ExtArgs>[]
      tablesSessionOpened: Prisma.$TableSessionPayload<ExtArgs>[]
      tablesSessionClosed: Prisma.$TableSessionPayload<ExtArgs>[]
      ordersCreated: Prisma.$OrderPayload<ExtArgs>[]
      ordersClosed: Prisma.$OrderPayload<ExtArgs>[]
      createdThemes: Prisma.$ThemePayload<ExtArgs>[]
      paymentsReceived: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      documentNumber: string
      username: string
      email: string
      password: string
      pin: string | null
      fullName: string
      phoneNumber: string | null
      birthDate: Date | null
      hireDate: Date | null
      salary: Prisma.Decimal | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      documentTypeName: string
      roleName: string
      accountStatusCode: string
      themeName: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `documentNumber`
     * const userWithDocumentNumberOnly = await prisma.user.findMany({ select: { documentNumber: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentType<T extends DocumentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTypeDefaultArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accountStatus<T extends AccountStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountStatusDefaultArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    theme<T extends User$themeArgs<ExtArgs> = {}>(args?: Subset<T, User$themeArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    openedCashBoxes<T extends User$openedCashBoxesArgs<ExtArgs> = {}>(args?: Subset<T, User$openedCashBoxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    closedCashBoxes<T extends User$closedCashBoxesArgs<ExtArgs> = {}>(args?: Subset<T, User$closedCashBoxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryMovements<T extends User$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    combinedTables<T extends User$combinedTablesArgs<ExtArgs> = {}>(args?: Subset<T, User$combinedTablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    releasedTables<T extends User$releasedTablesArgs<ExtArgs> = {}>(args?: Subset<T, User$releasedTablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tablesSessionOpened<T extends User$tablesSessionOpenedArgs<ExtArgs> = {}>(args?: Subset<T, User$tablesSessionOpenedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tablesSessionClosed<T extends User$tablesSessionClosedArgs<ExtArgs> = {}>(args?: Subset<T, User$tablesSessionClosedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersCreated<T extends User$ordersCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ordersClosed<T extends User$ordersClosedArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersClosedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdThemes<T extends User$createdThemesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdThemesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsReceived<T extends User$paymentsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly documentNumber: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly pin: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly hireDate: FieldRef<"User", 'DateTime'>
    readonly salary: FieldRef<"User", 'Decimal'>
    readonly emergencyContactName: FieldRef<"User", 'String'>
    readonly emergencyContactPhone: FieldRef<"User", 'String'>
    readonly documentTypeName: FieldRef<"User", 'String'>
    readonly roleName: FieldRef<"User", 'String'>
    readonly accountStatusCode: FieldRef<"User", 'String'>
    readonly themeName: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly updatedBy: FieldRef<"User", 'String'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly deletedBy: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.theme
   */
  export type User$themeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    where?: ThemeWhereInput
  }

  /**
   * User.openedCashBoxes
   */
  export type User$openedCashBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    where?: CashBoxWhereInput
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    cursor?: CashBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashBoxScalarFieldEnum | CashBoxScalarFieldEnum[]
  }

  /**
   * User.closedCashBoxes
   */
  export type User$closedCashBoxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    where?: CashBoxWhereInput
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    cursor?: CashBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashBoxScalarFieldEnum | CashBoxScalarFieldEnum[]
  }

  /**
   * User.inventoryMovements
   */
  export type User$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.combinedTables
   */
  export type User$combinedTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    where?: CombineTableWhereInput
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    cursor?: CombineTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombineTableScalarFieldEnum | CombineTableScalarFieldEnum[]
  }

  /**
   * User.releasedTables
   */
  export type User$releasedTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    where?: CombineTableWhereInput
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    cursor?: CombineTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombineTableScalarFieldEnum | CombineTableScalarFieldEnum[]
  }

  /**
   * User.tablesSessionOpened
   */
  export type User$tablesSessionOpenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    where?: TableSessionWhereInput
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    cursor?: TableSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * User.tablesSessionClosed
   */
  export type User$tablesSessionClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    where?: TableSessionWhereInput
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    cursor?: TableSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * User.ordersCreated
   */
  export type User$ordersCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.ordersClosed
   */
  export type User$ordersClosedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.createdThemes
   */
  export type User$createdThemesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    cursor?: ThemeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * User.paymentsReceived
   */
  export type User$paymentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    isActive: boolean | null
    expiresAt: Date | null
    closedAt: Date | null
    closedBy: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    isActive: boolean | null
    expiresAt: Date | null
    closedAt: Date | null
    closedBy: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userDocumentNumber: number
    customerDocumentNumber: number
    token: number
    deviceInfo: number
    ipAddress: number
    isActive: number
    expiresAt: number
    closedAt: number
    closedBy: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    isActive?: true
    expiresAt?: true
    closedAt?: true
    closedBy?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    isActive?: true
    expiresAt?: true
    closedAt?: true
    closedBy?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    isActive?: true
    expiresAt?: true
    closedAt?: true
    closedBy?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    isActive: boolean
    expiresAt: Date
    closedAt: Date | null
    closedBy: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userDocumentNumber?: boolean
    customerDocumentNumber?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    isActive?: boolean
    expiresAt?: boolean
    closedAt?: boolean
    closedBy?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    user?: boolean | Session$userArgs<ExtArgs>
    customer?: boolean | Session$customerArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    userDocumentNumber?: boolean
    customerDocumentNumber?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    isActive?: boolean
    expiresAt?: boolean
    closedAt?: boolean
    closedBy?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userDocumentNumber" | "customerDocumentNumber" | "token" | "deviceInfo" | "ipAddress" | "isActive" | "expiresAt" | "closedAt" | "closedBy" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Session$userArgs<ExtArgs>
    customer?: boolean | Session$customerArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userDocumentNumber: string | null
      customerDocumentNumber: string | null
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      isActive: boolean
      expiresAt: Date
      closedAt: Date | null
      closedBy: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Session$userArgs<ExtArgs> = {}>(args?: Subset<T, Session$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Session$customerArgs<ExtArgs> = {}>(args?: Subset<T, Session$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userDocumentNumber: FieldRef<"Session", 'String'>
    readonly customerDocumentNumber: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly deviceInfo: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly isActive: FieldRef<"Session", 'Boolean'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly closedAt: FieldRef<"Session", 'DateTime'>
    readonly closedBy: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly createdBy: FieldRef<"Session", 'String'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly updatedBy: FieldRef<"Session", 'String'>
    readonly deletedAt: FieldRef<"Session", 'DateTime'>
    readonly deletedBy: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.user
   */
  export type Session$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Session.customer
   */
  export type Session$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    documentNumber: string | null
    username: string | null
    email: string | null
    password: string | null
    fullName: string | null
    phoneNumber: string | null
    documentTypeName: string | null
    accountStatusCode: string | null
    themeName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    documentNumber: string | null
    username: string | null
    email: string | null
    password: string | null
    fullName: string | null
    phoneNumber: string | null
    documentTypeName: string | null
    accountStatusCode: string | null
    themeName: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CustomerCountAggregateOutputType = {
    documentNumber: number
    username: number
    email: number
    password: number
    fullName: number
    phoneNumber: number
    documentTypeName: number
    accountStatusCode: number
    themeName: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    phoneNumber?: true
    documentTypeName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CustomerMaxAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    phoneNumber?: true
    documentTypeName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CustomerCountAggregateInputType = {
    documentNumber?: true
    username?: true
    email?: true
    password?: true
    fullName?: true
    phoneNumber?: true
    documentTypeName?: true
    accountStatusCode?: true
    themeName?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    documentNumber: string
    username: string | null
    email: string | null
    password: string | null
    fullName: string
    phoneNumber: string | null
    documentTypeName: string
    accountStatusCode: string
    themeName: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    documentNumber?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    documentTypeName?: boolean
    accountStatusCode?: boolean
    themeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
    accountStatus?: boolean | AccountStatusDefaultArgs<ExtArgs>
    theme?: boolean | Customer$themeArgs<ExtArgs>
    sessions?: boolean | Customer$sessionsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    logs?: boolean | Customer$logsArgs<ExtArgs>
    paymentsMade?: boolean | Customer$paymentsMadeArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    documentNumber?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    phoneNumber?: boolean
    documentTypeName?: boolean
    accountStatusCode?: boolean
    themeName?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"documentNumber" | "username" | "email" | "password" | "fullName" | "phoneNumber" | "documentTypeName" | "accountStatusCode" | "themeName" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentType?: boolean | DocumentTypeDefaultArgs<ExtArgs>
    accountStatus?: boolean | AccountStatusDefaultArgs<ExtArgs>
    theme?: boolean | Customer$themeArgs<ExtArgs>
    sessions?: boolean | Customer$sessionsArgs<ExtArgs>
    orders?: boolean | Customer$ordersArgs<ExtArgs>
    logs?: boolean | Customer$logsArgs<ExtArgs>
    paymentsMade?: boolean | Customer$paymentsMadeArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      documentType: Prisma.$DocumentTypePayload<ExtArgs>
      accountStatus: Prisma.$AccountStatusPayload<ExtArgs>
      theme: Prisma.$ThemePayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      paymentsMade: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      documentNumber: string
      username: string | null
      email: string | null
      password: string | null
      fullName: string
      phoneNumber: string | null
      documentTypeName: string
      accountStatusCode: string
      themeName: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `documentNumber`
     * const customerWithDocumentNumberOnly = await prisma.customer.findMany({ select: { documentNumber: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentType<T extends DocumentTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTypeDefaultArgs<ExtArgs>>): Prisma__DocumentTypeClient<$Result.GetResult<Prisma.$DocumentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accountStatus<T extends AccountStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountStatusDefaultArgs<ExtArgs>>): Prisma__AccountStatusClient<$Result.GetResult<Prisma.$AccountStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    theme<T extends Customer$themeArgs<ExtArgs> = {}>(args?: Subset<T, Customer$themeArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends Customer$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Customer$logsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentsMade<T extends Customer$paymentsMadeArgs<ExtArgs> = {}>(args?: Subset<T, Customer$paymentsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly documentNumber: FieldRef<"Customer", 'String'>
    readonly username: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly fullName: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly documentTypeName: FieldRef<"Customer", 'String'>
    readonly accountStatusCode: FieldRef<"Customer", 'String'>
    readonly themeName: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly createdBy: FieldRef<"Customer", 'String'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedBy: FieldRef<"Customer", 'String'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedBy: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.theme
   */
  export type Customer$themeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    where?: ThemeWhereInput
  }

  /**
   * Customer.sessions
   */
  export type Customer$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Customer.orders
   */
  export type Customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer.logs
   */
  export type Customer$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Customer.paymentsMade
   */
  export type Customer$paymentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CashBox
   */

  export type AggregateCashBox = {
    _count: CashBoxCountAggregateOutputType | null
    _avg: CashBoxAvgAggregateOutputType | null
    _sum: CashBoxSumAggregateOutputType | null
    _min: CashBoxMinAggregateOutputType | null
    _max: CashBoxMaxAggregateOutputType | null
  }

  export type CashBoxAvgAggregateOutputType = {
    id: number | null
    initialAmount: Decimal | null
    finalAmount: Decimal | null
    totalSales: Decimal | null
  }

  export type CashBoxSumAggregateOutputType = {
    id: number | null
    initialAmount: Decimal | null
    finalAmount: Decimal | null
    totalSales: Decimal | null
  }

  export type CashBoxMinAggregateOutputType = {
    id: number | null
    openerUserDocument: string | null
    openedAt: Date | null
    initialAmount: Decimal | null
    closerUserDocument: string | null
    closedAt: Date | null
    finalAmount: Decimal | null
    totalSales: Decimal | null
    notes: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CashBoxMaxAggregateOutputType = {
    id: number | null
    openerUserDocument: string | null
    openedAt: Date | null
    initialAmount: Decimal | null
    closerUserDocument: string | null
    closedAt: Date | null
    finalAmount: Decimal | null
    totalSales: Decimal | null
    notes: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CashBoxCountAggregateOutputType = {
    id: number
    openerUserDocument: number
    openedAt: number
    initialAmount: number
    closerUserDocument: number
    closedAt: number
    finalAmount: number
    totalSales: number
    notes: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type CashBoxAvgAggregateInputType = {
    id?: true
    initialAmount?: true
    finalAmount?: true
    totalSales?: true
  }

  export type CashBoxSumAggregateInputType = {
    id?: true
    initialAmount?: true
    finalAmount?: true
    totalSales?: true
  }

  export type CashBoxMinAggregateInputType = {
    id?: true
    openerUserDocument?: true
    openedAt?: true
    initialAmount?: true
    closerUserDocument?: true
    closedAt?: true
    finalAmount?: true
    totalSales?: true
    notes?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CashBoxMaxAggregateInputType = {
    id?: true
    openerUserDocument?: true
    openedAt?: true
    initialAmount?: true
    closerUserDocument?: true
    closedAt?: true
    finalAmount?: true
    totalSales?: true
    notes?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CashBoxCountAggregateInputType = {
    id?: true
    openerUserDocument?: true
    openedAt?: true
    initialAmount?: true
    closerUserDocument?: true
    closedAt?: true
    finalAmount?: true
    totalSales?: true
    notes?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type CashBoxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashBox to aggregate.
     */
    where?: CashBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashBoxes to fetch.
     */
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashBoxes
    **/
    _count?: true | CashBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashBoxMaxAggregateInputType
  }

  export type GetCashBoxAggregateType<T extends CashBoxAggregateArgs> = {
        [P in keyof T & keyof AggregateCashBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashBox[P]>
      : GetScalarType<T[P], AggregateCashBox[P]>
  }




  export type CashBoxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashBoxWhereInput
    orderBy?: CashBoxOrderByWithAggregationInput | CashBoxOrderByWithAggregationInput[]
    by: CashBoxScalarFieldEnum[] | CashBoxScalarFieldEnum
    having?: CashBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashBoxCountAggregateInputType | true
    _avg?: CashBoxAvgAggregateInputType
    _sum?: CashBoxSumAggregateInputType
    _min?: CashBoxMinAggregateInputType
    _max?: CashBoxMaxAggregateInputType
  }

  export type CashBoxGroupByOutputType = {
    id: number
    openerUserDocument: string
    openedAt: Date
    initialAmount: Decimal
    closerUserDocument: string | null
    closedAt: Date | null
    finalAmount: Decimal | null
    totalSales: Decimal | null
    notes: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: CashBoxCountAggregateOutputType | null
    _avg: CashBoxAvgAggregateOutputType | null
    _sum: CashBoxSumAggregateOutputType | null
    _min: CashBoxMinAggregateOutputType | null
    _max: CashBoxMaxAggregateOutputType | null
  }

  type GetCashBoxGroupByPayload<T extends CashBoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashBoxGroupByOutputType[P]>
            : GetScalarType<T[P], CashBoxGroupByOutputType[P]>
        }
      >
    >


  export type CashBoxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    openerUserDocument?: boolean
    openedAt?: boolean
    initialAmount?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    finalAmount?: boolean
    totalSales?: boolean
    notes?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    opener?: boolean | UserDefaultArgs<ExtArgs>
    closer?: boolean | CashBox$closerArgs<ExtArgs>
    payments?: boolean | CashBox$paymentsArgs<ExtArgs>
    _count?: boolean | CashBoxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashBox"]>



  export type CashBoxSelectScalar = {
    id?: boolean
    openerUserDocument?: boolean
    openedAt?: boolean
    initialAmount?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    finalAmount?: boolean
    totalSales?: boolean
    notes?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type CashBoxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "openerUserDocument" | "openedAt" | "initialAmount" | "closerUserDocument" | "closedAt" | "finalAmount" | "totalSales" | "notes" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["cashBox"]>
  export type CashBoxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opener?: boolean | UserDefaultArgs<ExtArgs>
    closer?: boolean | CashBox$closerArgs<ExtArgs>
    payments?: boolean | CashBox$paymentsArgs<ExtArgs>
    _count?: boolean | CashBoxCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CashBoxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashBox"
    objects: {
      opener: Prisma.$UserPayload<ExtArgs>
      closer: Prisma.$UserPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      openerUserDocument: string
      openedAt: Date
      initialAmount: Prisma.Decimal
      closerUserDocument: string | null
      closedAt: Date | null
      finalAmount: Prisma.Decimal | null
      totalSales: Prisma.Decimal | null
      notes: string | null
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["cashBox"]>
    composites: {}
  }

  type CashBoxGetPayload<S extends boolean | null | undefined | CashBoxDefaultArgs> = $Result.GetResult<Prisma.$CashBoxPayload, S>

  type CashBoxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashBoxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashBoxCountAggregateInputType | true
    }

  export interface CashBoxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashBox'], meta: { name: 'CashBox' } }
    /**
     * Find zero or one CashBox that matches the filter.
     * @param {CashBoxFindUniqueArgs} args - Arguments to find a CashBox
     * @example
     * // Get one CashBox
     * const cashBox = await prisma.cashBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashBoxFindUniqueArgs>(args: SelectSubset<T, CashBoxFindUniqueArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashBox that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashBoxFindUniqueOrThrowArgs} args - Arguments to find a CashBox
     * @example
     * // Get one CashBox
     * const cashBox = await prisma.cashBox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashBoxFindUniqueOrThrowArgs>(args: SelectSubset<T, CashBoxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxFindFirstArgs} args - Arguments to find a CashBox
     * @example
     * // Get one CashBox
     * const cashBox = await prisma.cashBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashBoxFindFirstArgs>(args?: SelectSubset<T, CashBoxFindFirstArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashBox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxFindFirstOrThrowArgs} args - Arguments to find a CashBox
     * @example
     * // Get one CashBox
     * const cashBox = await prisma.cashBox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashBoxFindFirstOrThrowArgs>(args?: SelectSubset<T, CashBoxFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashBoxes
     * const cashBoxes = await prisma.cashBox.findMany()
     * 
     * // Get first 10 CashBoxes
     * const cashBoxes = await prisma.cashBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashBoxWithIdOnly = await prisma.cashBox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashBoxFindManyArgs>(args?: SelectSubset<T, CashBoxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashBox.
     * @param {CashBoxCreateArgs} args - Arguments to create a CashBox.
     * @example
     * // Create one CashBox
     * const CashBox = await prisma.cashBox.create({
     *   data: {
     *     // ... data to create a CashBox
     *   }
     * })
     * 
     */
    create<T extends CashBoxCreateArgs>(args: SelectSubset<T, CashBoxCreateArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashBoxes.
     * @param {CashBoxCreateManyArgs} args - Arguments to create many CashBoxes.
     * @example
     * // Create many CashBoxes
     * const cashBox = await prisma.cashBox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashBoxCreateManyArgs>(args?: SelectSubset<T, CashBoxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CashBox.
     * @param {CashBoxDeleteArgs} args - Arguments to delete one CashBox.
     * @example
     * // Delete one CashBox
     * const CashBox = await prisma.cashBox.delete({
     *   where: {
     *     // ... filter to delete one CashBox
     *   }
     * })
     * 
     */
    delete<T extends CashBoxDeleteArgs>(args: SelectSubset<T, CashBoxDeleteArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashBox.
     * @param {CashBoxUpdateArgs} args - Arguments to update one CashBox.
     * @example
     * // Update one CashBox
     * const cashBox = await prisma.cashBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashBoxUpdateArgs>(args: SelectSubset<T, CashBoxUpdateArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashBoxes.
     * @param {CashBoxDeleteManyArgs} args - Arguments to filter CashBoxes to delete.
     * @example
     * // Delete a few CashBoxes
     * const { count } = await prisma.cashBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashBoxDeleteManyArgs>(args?: SelectSubset<T, CashBoxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashBoxes
     * const cashBox = await prisma.cashBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashBoxUpdateManyArgs>(args: SelectSubset<T, CashBoxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashBox.
     * @param {CashBoxUpsertArgs} args - Arguments to update or create a CashBox.
     * @example
     * // Update or create a CashBox
     * const cashBox = await prisma.cashBox.upsert({
     *   create: {
     *     // ... data to create a CashBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashBox we want to update
     *   }
     * })
     */
    upsert<T extends CashBoxUpsertArgs>(args: SelectSubset<T, CashBoxUpsertArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxCountArgs} args - Arguments to filter CashBoxes to count.
     * @example
     * // Count the number of CashBoxes
     * const count = await prisma.cashBox.count({
     *   where: {
     *     // ... the filter for the CashBoxes we want to count
     *   }
     * })
    **/
    count<T extends CashBoxCountArgs>(
      args?: Subset<T, CashBoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashBoxAggregateArgs>(args: Subset<T, CashBoxAggregateArgs>): Prisma.PrismaPromise<GetCashBoxAggregateType<T>>

    /**
     * Group by CashBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashBoxGroupByArgs['orderBy'] }
        : { orderBy?: CashBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashBox model
   */
  readonly fields: CashBoxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashBoxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opener<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    closer<T extends CashBox$closerArgs<ExtArgs> = {}>(args?: Subset<T, CashBox$closerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends CashBox$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, CashBox$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashBox model
   */
  interface CashBoxFieldRefs {
    readonly id: FieldRef<"CashBox", 'Int'>
    readonly openerUserDocument: FieldRef<"CashBox", 'String'>
    readonly openedAt: FieldRef<"CashBox", 'DateTime'>
    readonly initialAmount: FieldRef<"CashBox", 'Decimal'>
    readonly closerUserDocument: FieldRef<"CashBox", 'String'>
    readonly closedAt: FieldRef<"CashBox", 'DateTime'>
    readonly finalAmount: FieldRef<"CashBox", 'Decimal'>
    readonly totalSales: FieldRef<"CashBox", 'Decimal'>
    readonly notes: FieldRef<"CashBox", 'String'>
    readonly updatedAt: FieldRef<"CashBox", 'DateTime'>
    readonly updatedBy: FieldRef<"CashBox", 'String'>
    readonly deletedAt: FieldRef<"CashBox", 'DateTime'>
    readonly deletedBy: FieldRef<"CashBox", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashBox findUnique
   */
  export type CashBoxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter, which CashBox to fetch.
     */
    where: CashBoxWhereUniqueInput
  }

  /**
   * CashBox findUniqueOrThrow
   */
  export type CashBoxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter, which CashBox to fetch.
     */
    where: CashBoxWhereUniqueInput
  }

  /**
   * CashBox findFirst
   */
  export type CashBoxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter, which CashBox to fetch.
     */
    where?: CashBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashBoxes to fetch.
     */
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashBoxes.
     */
    cursor?: CashBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashBoxes.
     */
    distinct?: CashBoxScalarFieldEnum | CashBoxScalarFieldEnum[]
  }

  /**
   * CashBox findFirstOrThrow
   */
  export type CashBoxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter, which CashBox to fetch.
     */
    where?: CashBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashBoxes to fetch.
     */
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashBoxes.
     */
    cursor?: CashBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashBoxes.
     */
    distinct?: CashBoxScalarFieldEnum | CashBoxScalarFieldEnum[]
  }

  /**
   * CashBox findMany
   */
  export type CashBoxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter, which CashBoxes to fetch.
     */
    where?: CashBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashBoxes to fetch.
     */
    orderBy?: CashBoxOrderByWithRelationInput | CashBoxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashBoxes.
     */
    cursor?: CashBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashBoxes.
     */
    skip?: number
    distinct?: CashBoxScalarFieldEnum | CashBoxScalarFieldEnum[]
  }

  /**
   * CashBox create
   */
  export type CashBoxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * The data needed to create a CashBox.
     */
    data: XOR<CashBoxCreateInput, CashBoxUncheckedCreateInput>
  }

  /**
   * CashBox createMany
   */
  export type CashBoxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashBoxes.
     */
    data: CashBoxCreateManyInput | CashBoxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashBox update
   */
  export type CashBoxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * The data needed to update a CashBox.
     */
    data: XOR<CashBoxUpdateInput, CashBoxUncheckedUpdateInput>
    /**
     * Choose, which CashBox to update.
     */
    where: CashBoxWhereUniqueInput
  }

  /**
   * CashBox updateMany
   */
  export type CashBoxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashBoxes.
     */
    data: XOR<CashBoxUpdateManyMutationInput, CashBoxUncheckedUpdateManyInput>
    /**
     * Filter which CashBoxes to update
     */
    where?: CashBoxWhereInput
    /**
     * Limit how many CashBoxes to update.
     */
    limit?: number
  }

  /**
   * CashBox upsert
   */
  export type CashBoxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * The filter to search for the CashBox to update in case it exists.
     */
    where: CashBoxWhereUniqueInput
    /**
     * In case the CashBox found by the `where` argument doesn't exist, create a new CashBox with this data.
     */
    create: XOR<CashBoxCreateInput, CashBoxUncheckedCreateInput>
    /**
     * In case the CashBox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashBoxUpdateInput, CashBoxUncheckedUpdateInput>
  }

  /**
   * CashBox delete
   */
  export type CashBoxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
    /**
     * Filter which CashBox to delete.
     */
    where: CashBoxWhereUniqueInput
  }

  /**
   * CashBox deleteMany
   */
  export type CashBoxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashBoxes to delete
     */
    where?: CashBoxWhereInput
    /**
     * Limit how many CashBoxes to delete.
     */
    limit?: number
  }

  /**
   * CashBox.closer
   */
  export type CashBox$closerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CashBox.payments
   */
  export type CashBox$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * CashBox without action
   */
  export type CashBoxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashBox
     */
    select?: CashBoxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashBox
     */
    omit?: CashBoxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashBoxInclude<ExtArgs> | null
  }


  /**
   * Model TableStatus
   */

  export type AggregateTableStatus = {
    _count: TableStatusCountAggregateOutputType | null
    _min: TableStatusMinAggregateOutputType | null
    _max: TableStatusMaxAggregateOutputType | null
  }

  export type TableStatusMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TableStatusMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type TableStatusCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type TableStatusMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TableStatusMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type TableStatusCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type TableStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableStatus to aggregate.
     */
    where?: TableStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableStatuses to fetch.
     */
    orderBy?: TableStatusOrderByWithRelationInput | TableStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableStatuses
    **/
    _count?: true | TableStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableStatusMaxAggregateInputType
  }

  export type GetTableStatusAggregateType<T extends TableStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTableStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableStatus[P]>
      : GetScalarType<T[P], AggregateTableStatus[P]>
  }




  export type TableStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableStatusWhereInput
    orderBy?: TableStatusOrderByWithAggregationInput | TableStatusOrderByWithAggregationInput[]
    by: TableStatusScalarFieldEnum[] | TableStatusScalarFieldEnum
    having?: TableStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableStatusCountAggregateInputType | true
    _min?: TableStatusMinAggregateInputType
    _max?: TableStatusMaxAggregateInputType
  }

  export type TableStatusGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: TableStatusCountAggregateOutputType | null
    _min: TableStatusMinAggregateOutputType | null
    _max: TableStatusMaxAggregateOutputType | null
  }

  type GetTableStatusGroupByPayload<T extends TableStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TableStatusGroupByOutputType[P]>
        }
      >
    >


  export type TableStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    tables?: boolean | TableStatus$tablesArgs<ExtArgs>
    _count?: boolean | TableStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableStatus"]>



  export type TableStatusSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type TableStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["tableStatus"]>
  export type TableStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | TableStatus$tablesArgs<ExtArgs>
    _count?: boolean | TableStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TableStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TableStatus"
    objects: {
      tables: Prisma.$TablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["tableStatus"]>
    composites: {}
  }

  type TableStatusGetPayload<S extends boolean | null | undefined | TableStatusDefaultArgs> = $Result.GetResult<Prisma.$TableStatusPayload, S>

  type TableStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableStatusCountAggregateInputType | true
    }

  export interface TableStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TableStatus'], meta: { name: 'TableStatus' } }
    /**
     * Find zero or one TableStatus that matches the filter.
     * @param {TableStatusFindUniqueArgs} args - Arguments to find a TableStatus
     * @example
     * // Get one TableStatus
     * const tableStatus = await prisma.tableStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableStatusFindUniqueArgs>(args: SelectSubset<T, TableStatusFindUniqueArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TableStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableStatusFindUniqueOrThrowArgs} args - Arguments to find a TableStatus
     * @example
     * // Get one TableStatus
     * const tableStatus = await prisma.tableStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, TableStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusFindFirstArgs} args - Arguments to find a TableStatus
     * @example
     * // Get one TableStatus
     * const tableStatus = await prisma.tableStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableStatusFindFirstArgs>(args?: SelectSubset<T, TableStatusFindFirstArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusFindFirstOrThrowArgs} args - Arguments to find a TableStatus
     * @example
     * // Get one TableStatus
     * const tableStatus = await prisma.tableStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, TableStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TableStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableStatuses
     * const tableStatuses = await prisma.tableStatus.findMany()
     * 
     * // Get first 10 TableStatuses
     * const tableStatuses = await prisma.tableStatus.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const tableStatusWithCodeOnly = await prisma.tableStatus.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends TableStatusFindManyArgs>(args?: SelectSubset<T, TableStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TableStatus.
     * @param {TableStatusCreateArgs} args - Arguments to create a TableStatus.
     * @example
     * // Create one TableStatus
     * const TableStatus = await prisma.tableStatus.create({
     *   data: {
     *     // ... data to create a TableStatus
     *   }
     * })
     * 
     */
    create<T extends TableStatusCreateArgs>(args: SelectSubset<T, TableStatusCreateArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TableStatuses.
     * @param {TableStatusCreateManyArgs} args - Arguments to create many TableStatuses.
     * @example
     * // Create many TableStatuses
     * const tableStatus = await prisma.tableStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableStatusCreateManyArgs>(args?: SelectSubset<T, TableStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TableStatus.
     * @param {TableStatusDeleteArgs} args - Arguments to delete one TableStatus.
     * @example
     * // Delete one TableStatus
     * const TableStatus = await prisma.tableStatus.delete({
     *   where: {
     *     // ... filter to delete one TableStatus
     *   }
     * })
     * 
     */
    delete<T extends TableStatusDeleteArgs>(args: SelectSubset<T, TableStatusDeleteArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TableStatus.
     * @param {TableStatusUpdateArgs} args - Arguments to update one TableStatus.
     * @example
     * // Update one TableStatus
     * const tableStatus = await prisma.tableStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableStatusUpdateArgs>(args: SelectSubset<T, TableStatusUpdateArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TableStatuses.
     * @param {TableStatusDeleteManyArgs} args - Arguments to filter TableStatuses to delete.
     * @example
     * // Delete a few TableStatuses
     * const { count } = await prisma.tableStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableStatusDeleteManyArgs>(args?: SelectSubset<T, TableStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableStatuses
     * const tableStatus = await prisma.tableStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableStatusUpdateManyArgs>(args: SelectSubset<T, TableStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TableStatus.
     * @param {TableStatusUpsertArgs} args - Arguments to update or create a TableStatus.
     * @example
     * // Update or create a TableStatus
     * const tableStatus = await prisma.tableStatus.upsert({
     *   create: {
     *     // ... data to create a TableStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableStatus we want to update
     *   }
     * })
     */
    upsert<T extends TableStatusUpsertArgs>(args: SelectSubset<T, TableStatusUpsertArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TableStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusCountArgs} args - Arguments to filter TableStatuses to count.
     * @example
     * // Count the number of TableStatuses
     * const count = await prisma.tableStatus.count({
     *   where: {
     *     // ... the filter for the TableStatuses we want to count
     *   }
     * })
    **/
    count<T extends TableStatusCountArgs>(
      args?: Subset<T, TableStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableStatusAggregateArgs>(args: Subset<T, TableStatusAggregateArgs>): Prisma.PrismaPromise<GetTableStatusAggregateType<T>>

    /**
     * Group by TableStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableStatusGroupByArgs['orderBy'] }
        : { orderBy?: TableStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TableStatus model
   */
  readonly fields: TableStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tables<T extends TableStatus$tablesArgs<ExtArgs> = {}>(args?: Subset<T, TableStatus$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TableStatus model
   */
  interface TableStatusFieldRefs {
    readonly code: FieldRef<"TableStatus", 'String'>
    readonly name: FieldRef<"TableStatus", 'String'>
    readonly description: FieldRef<"TableStatus", 'String'>
    readonly color: FieldRef<"TableStatus", 'String'>
    readonly createdAt: FieldRef<"TableStatus", 'DateTime'>
    readonly createdBy: FieldRef<"TableStatus", 'String'>
    readonly updatedAt: FieldRef<"TableStatus", 'DateTime'>
    readonly updatedBy: FieldRef<"TableStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TableStatus findUnique
   */
  export type TableStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter, which TableStatus to fetch.
     */
    where: TableStatusWhereUniqueInput
  }

  /**
   * TableStatus findUniqueOrThrow
   */
  export type TableStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter, which TableStatus to fetch.
     */
    where: TableStatusWhereUniqueInput
  }

  /**
   * TableStatus findFirst
   */
  export type TableStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter, which TableStatus to fetch.
     */
    where?: TableStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableStatuses to fetch.
     */
    orderBy?: TableStatusOrderByWithRelationInput | TableStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableStatuses.
     */
    cursor?: TableStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableStatuses.
     */
    distinct?: TableStatusScalarFieldEnum | TableStatusScalarFieldEnum[]
  }

  /**
   * TableStatus findFirstOrThrow
   */
  export type TableStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter, which TableStatus to fetch.
     */
    where?: TableStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableStatuses to fetch.
     */
    orderBy?: TableStatusOrderByWithRelationInput | TableStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableStatuses.
     */
    cursor?: TableStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableStatuses.
     */
    distinct?: TableStatusScalarFieldEnum | TableStatusScalarFieldEnum[]
  }

  /**
   * TableStatus findMany
   */
  export type TableStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter, which TableStatuses to fetch.
     */
    where?: TableStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableStatuses to fetch.
     */
    orderBy?: TableStatusOrderByWithRelationInput | TableStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableStatuses.
     */
    cursor?: TableStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableStatuses.
     */
    skip?: number
    distinct?: TableStatusScalarFieldEnum | TableStatusScalarFieldEnum[]
  }

  /**
   * TableStatus create
   */
  export type TableStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a TableStatus.
     */
    data: XOR<TableStatusCreateInput, TableStatusUncheckedCreateInput>
  }

  /**
   * TableStatus createMany
   */
  export type TableStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TableStatuses.
     */
    data: TableStatusCreateManyInput | TableStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TableStatus update
   */
  export type TableStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a TableStatus.
     */
    data: XOR<TableStatusUpdateInput, TableStatusUncheckedUpdateInput>
    /**
     * Choose, which TableStatus to update.
     */
    where: TableStatusWhereUniqueInput
  }

  /**
   * TableStatus updateMany
   */
  export type TableStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TableStatuses.
     */
    data: XOR<TableStatusUpdateManyMutationInput, TableStatusUncheckedUpdateManyInput>
    /**
     * Filter which TableStatuses to update
     */
    where?: TableStatusWhereInput
    /**
     * Limit how many TableStatuses to update.
     */
    limit?: number
  }

  /**
   * TableStatus upsert
   */
  export type TableStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the TableStatus to update in case it exists.
     */
    where: TableStatusWhereUniqueInput
    /**
     * In case the TableStatus found by the `where` argument doesn't exist, create a new TableStatus with this data.
     */
    create: XOR<TableStatusCreateInput, TableStatusUncheckedCreateInput>
    /**
     * In case the TableStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableStatusUpdateInput, TableStatusUncheckedUpdateInput>
  }

  /**
   * TableStatus delete
   */
  export type TableStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
    /**
     * Filter which TableStatus to delete.
     */
    where: TableStatusWhereUniqueInput
  }

  /**
   * TableStatus deleteMany
   */
  export type TableStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableStatuses to delete
     */
    where?: TableStatusWhereInput
    /**
     * Limit how many TableStatuses to delete.
     */
    limit?: number
  }

  /**
   * TableStatus.tables
   */
  export type TableStatus$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * TableStatus without action
   */
  export type TableStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableStatus
     */
    select?: TableStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableStatus
     */
    omit?: TableStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableStatusInclude<ExtArgs> | null
  }


  /**
   * Model RestaurantZone
   */

  export type AggregateRestaurantZone = {
    _count: RestaurantZoneCountAggregateOutputType | null
    _min: RestaurantZoneMinAggregateOutputType | null
    _max: RestaurantZoneMaxAggregateOutputType | null
  }

  export type RestaurantZoneMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RestaurantZoneMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type RestaurantZoneCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type RestaurantZoneMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RestaurantZoneMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type RestaurantZoneCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type RestaurantZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantZone to aggregate.
     */
    where?: RestaurantZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantZones to fetch.
     */
    orderBy?: RestaurantZoneOrderByWithRelationInput | RestaurantZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RestaurantZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RestaurantZones
    **/
    _count?: true | RestaurantZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RestaurantZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RestaurantZoneMaxAggregateInputType
  }

  export type GetRestaurantZoneAggregateType<T extends RestaurantZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateRestaurantZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRestaurantZone[P]>
      : GetScalarType<T[P], AggregateRestaurantZone[P]>
  }




  export type RestaurantZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RestaurantZoneWhereInput
    orderBy?: RestaurantZoneOrderByWithAggregationInput | RestaurantZoneOrderByWithAggregationInput[]
    by: RestaurantZoneScalarFieldEnum[] | RestaurantZoneScalarFieldEnum
    having?: RestaurantZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RestaurantZoneCountAggregateInputType | true
    _min?: RestaurantZoneMinAggregateInputType
    _max?: RestaurantZoneMaxAggregateInputType
  }

  export type RestaurantZoneGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: RestaurantZoneCountAggregateOutputType | null
    _min: RestaurantZoneMinAggregateOutputType | null
    _max: RestaurantZoneMaxAggregateOutputType | null
  }

  type GetRestaurantZoneGroupByPayload<T extends RestaurantZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RestaurantZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RestaurantZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RestaurantZoneGroupByOutputType[P]>
            : GetScalarType<T[P], RestaurantZoneGroupByOutputType[P]>
        }
      >
    >


  export type RestaurantZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    tables?: boolean | RestaurantZone$tablesArgs<ExtArgs>
    _count?: boolean | RestaurantZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["restaurantZone"]>



  export type RestaurantZoneSelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type RestaurantZoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["restaurantZone"]>
  export type RestaurantZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | RestaurantZone$tablesArgs<ExtArgs>
    _count?: boolean | RestaurantZoneCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RestaurantZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RestaurantZone"
    objects: {
      tables: Prisma.$TablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["restaurantZone"]>
    composites: {}
  }

  type RestaurantZoneGetPayload<S extends boolean | null | undefined | RestaurantZoneDefaultArgs> = $Result.GetResult<Prisma.$RestaurantZonePayload, S>

  type RestaurantZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RestaurantZoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RestaurantZoneCountAggregateInputType | true
    }

  export interface RestaurantZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RestaurantZone'], meta: { name: 'RestaurantZone' } }
    /**
     * Find zero or one RestaurantZone that matches the filter.
     * @param {RestaurantZoneFindUniqueArgs} args - Arguments to find a RestaurantZone
     * @example
     * // Get one RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RestaurantZoneFindUniqueArgs>(args: SelectSubset<T, RestaurantZoneFindUniqueArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RestaurantZone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RestaurantZoneFindUniqueOrThrowArgs} args - Arguments to find a RestaurantZone
     * @example
     * // Get one RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RestaurantZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, RestaurantZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantZone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneFindFirstArgs} args - Arguments to find a RestaurantZone
     * @example
     * // Get one RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RestaurantZoneFindFirstArgs>(args?: SelectSubset<T, RestaurantZoneFindFirstArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RestaurantZone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneFindFirstOrThrowArgs} args - Arguments to find a RestaurantZone
     * @example
     * // Get one RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RestaurantZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, RestaurantZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RestaurantZones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RestaurantZones
     * const restaurantZones = await prisma.restaurantZone.findMany()
     * 
     * // Get first 10 RestaurantZones
     * const restaurantZones = await prisma.restaurantZone.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const restaurantZoneWithNameOnly = await prisma.restaurantZone.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends RestaurantZoneFindManyArgs>(args?: SelectSubset<T, RestaurantZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RestaurantZone.
     * @param {RestaurantZoneCreateArgs} args - Arguments to create a RestaurantZone.
     * @example
     * // Create one RestaurantZone
     * const RestaurantZone = await prisma.restaurantZone.create({
     *   data: {
     *     // ... data to create a RestaurantZone
     *   }
     * })
     * 
     */
    create<T extends RestaurantZoneCreateArgs>(args: SelectSubset<T, RestaurantZoneCreateArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RestaurantZones.
     * @param {RestaurantZoneCreateManyArgs} args - Arguments to create many RestaurantZones.
     * @example
     * // Create many RestaurantZones
     * const restaurantZone = await prisma.restaurantZone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RestaurantZoneCreateManyArgs>(args?: SelectSubset<T, RestaurantZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RestaurantZone.
     * @param {RestaurantZoneDeleteArgs} args - Arguments to delete one RestaurantZone.
     * @example
     * // Delete one RestaurantZone
     * const RestaurantZone = await prisma.restaurantZone.delete({
     *   where: {
     *     // ... filter to delete one RestaurantZone
     *   }
     * })
     * 
     */
    delete<T extends RestaurantZoneDeleteArgs>(args: SelectSubset<T, RestaurantZoneDeleteArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RestaurantZone.
     * @param {RestaurantZoneUpdateArgs} args - Arguments to update one RestaurantZone.
     * @example
     * // Update one RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RestaurantZoneUpdateArgs>(args: SelectSubset<T, RestaurantZoneUpdateArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RestaurantZones.
     * @param {RestaurantZoneDeleteManyArgs} args - Arguments to filter RestaurantZones to delete.
     * @example
     * // Delete a few RestaurantZones
     * const { count } = await prisma.restaurantZone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RestaurantZoneDeleteManyArgs>(args?: SelectSubset<T, RestaurantZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RestaurantZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RestaurantZones
     * const restaurantZone = await prisma.restaurantZone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RestaurantZoneUpdateManyArgs>(args: SelectSubset<T, RestaurantZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RestaurantZone.
     * @param {RestaurantZoneUpsertArgs} args - Arguments to update or create a RestaurantZone.
     * @example
     * // Update or create a RestaurantZone
     * const restaurantZone = await prisma.restaurantZone.upsert({
     *   create: {
     *     // ... data to create a RestaurantZone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RestaurantZone we want to update
     *   }
     * })
     */
    upsert<T extends RestaurantZoneUpsertArgs>(args: SelectSubset<T, RestaurantZoneUpsertArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RestaurantZones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneCountArgs} args - Arguments to filter RestaurantZones to count.
     * @example
     * // Count the number of RestaurantZones
     * const count = await prisma.restaurantZone.count({
     *   where: {
     *     // ... the filter for the RestaurantZones we want to count
     *   }
     * })
    **/
    count<T extends RestaurantZoneCountArgs>(
      args?: Subset<T, RestaurantZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RestaurantZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RestaurantZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RestaurantZoneAggregateArgs>(args: Subset<T, RestaurantZoneAggregateArgs>): Prisma.PrismaPromise<GetRestaurantZoneAggregateType<T>>

    /**
     * Group by RestaurantZone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RestaurantZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RestaurantZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RestaurantZoneGroupByArgs['orderBy'] }
        : { orderBy?: RestaurantZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RestaurantZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRestaurantZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RestaurantZone model
   */
  readonly fields: RestaurantZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RestaurantZone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RestaurantZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tables<T extends RestaurantZone$tablesArgs<ExtArgs> = {}>(args?: Subset<T, RestaurantZone$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RestaurantZone model
   */
  interface RestaurantZoneFieldRefs {
    readonly name: FieldRef<"RestaurantZone", 'String'>
    readonly description: FieldRef<"RestaurantZone", 'String'>
    readonly color: FieldRef<"RestaurantZone", 'String'>
    readonly isActive: FieldRef<"RestaurantZone", 'Boolean'>
    readonly createdAt: FieldRef<"RestaurantZone", 'DateTime'>
    readonly createdBy: FieldRef<"RestaurantZone", 'String'>
    readonly updatedAt: FieldRef<"RestaurantZone", 'DateTime'>
    readonly updatedBy: FieldRef<"RestaurantZone", 'String'>
    readonly deletedAt: FieldRef<"RestaurantZone", 'DateTime'>
    readonly deletedBy: FieldRef<"RestaurantZone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RestaurantZone findUnique
   */
  export type RestaurantZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantZone to fetch.
     */
    where: RestaurantZoneWhereUniqueInput
  }

  /**
   * RestaurantZone findUniqueOrThrow
   */
  export type RestaurantZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantZone to fetch.
     */
    where: RestaurantZoneWhereUniqueInput
  }

  /**
   * RestaurantZone findFirst
   */
  export type RestaurantZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantZone to fetch.
     */
    where?: RestaurantZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantZones to fetch.
     */
    orderBy?: RestaurantZoneOrderByWithRelationInput | RestaurantZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantZones.
     */
    cursor?: RestaurantZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantZones.
     */
    distinct?: RestaurantZoneScalarFieldEnum | RestaurantZoneScalarFieldEnum[]
  }

  /**
   * RestaurantZone findFirstOrThrow
   */
  export type RestaurantZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantZone to fetch.
     */
    where?: RestaurantZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantZones to fetch.
     */
    orderBy?: RestaurantZoneOrderByWithRelationInput | RestaurantZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RestaurantZones.
     */
    cursor?: RestaurantZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantZones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RestaurantZones.
     */
    distinct?: RestaurantZoneScalarFieldEnum | RestaurantZoneScalarFieldEnum[]
  }

  /**
   * RestaurantZone findMany
   */
  export type RestaurantZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter, which RestaurantZones to fetch.
     */
    where?: RestaurantZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RestaurantZones to fetch.
     */
    orderBy?: RestaurantZoneOrderByWithRelationInput | RestaurantZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RestaurantZones.
     */
    cursor?: RestaurantZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RestaurantZones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RestaurantZones.
     */
    skip?: number
    distinct?: RestaurantZoneScalarFieldEnum | RestaurantZoneScalarFieldEnum[]
  }

  /**
   * RestaurantZone create
   */
  export type RestaurantZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a RestaurantZone.
     */
    data: XOR<RestaurantZoneCreateInput, RestaurantZoneUncheckedCreateInput>
  }

  /**
   * RestaurantZone createMany
   */
  export type RestaurantZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RestaurantZones.
     */
    data: RestaurantZoneCreateManyInput | RestaurantZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RestaurantZone update
   */
  export type RestaurantZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a RestaurantZone.
     */
    data: XOR<RestaurantZoneUpdateInput, RestaurantZoneUncheckedUpdateInput>
    /**
     * Choose, which RestaurantZone to update.
     */
    where: RestaurantZoneWhereUniqueInput
  }

  /**
   * RestaurantZone updateMany
   */
  export type RestaurantZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RestaurantZones.
     */
    data: XOR<RestaurantZoneUpdateManyMutationInput, RestaurantZoneUncheckedUpdateManyInput>
    /**
     * Filter which RestaurantZones to update
     */
    where?: RestaurantZoneWhereInput
    /**
     * Limit how many RestaurantZones to update.
     */
    limit?: number
  }

  /**
   * RestaurantZone upsert
   */
  export type RestaurantZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the RestaurantZone to update in case it exists.
     */
    where: RestaurantZoneWhereUniqueInput
    /**
     * In case the RestaurantZone found by the `where` argument doesn't exist, create a new RestaurantZone with this data.
     */
    create: XOR<RestaurantZoneCreateInput, RestaurantZoneUncheckedCreateInput>
    /**
     * In case the RestaurantZone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RestaurantZoneUpdateInput, RestaurantZoneUncheckedUpdateInput>
  }

  /**
   * RestaurantZone delete
   */
  export type RestaurantZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    /**
     * Filter which RestaurantZone to delete.
     */
    where: RestaurantZoneWhereUniqueInput
  }

  /**
   * RestaurantZone deleteMany
   */
  export type RestaurantZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RestaurantZones to delete
     */
    where?: RestaurantZoneWhereInput
    /**
     * Limit how many RestaurantZones to delete.
     */
    limit?: number
  }

  /**
   * RestaurantZone.tables
   */
  export type RestaurantZone$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * RestaurantZone without action
   */
  export type RestaurantZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type TableSumAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type TableMinAggregateOutputType = {
    id: number | null
    name: string | null
    capacity: number | null
    zoneName: string | null
    statusCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    capacity: number | null
    zoneName: string | null
    statusCode: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TableCountAggregateOutputType = {
    id: number
    name: number
    capacity: number
    zoneName: number
    statusCode: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type TableAvgAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type TableSumAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type TableMinAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    zoneName?: true
    statusCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TableMaxAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    zoneName?: true
    statusCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TableCountAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    zoneName?: true
    statusCode?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _avg?: TableAvgAggregateInputType
    _sum?: TableSumAggregateInputType
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    id: number
    name: string
    capacity: number
    zoneName: string | null
    statusCode: string
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: TableCountAggregateOutputType | null
    _avg: TableAvgAggregateOutputType | null
    _sum: TableSumAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    capacity?: boolean
    zoneName?: boolean
    statusCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    zone?: boolean | Table$zoneArgs<ExtArgs>
    status?: boolean | TableStatusDefaultArgs<ExtArgs>
    tableSessions?: boolean | Table$tableSessionsArgs<ExtArgs>
    combineTableItems?: boolean | Table$combineTableItemsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>



  export type TableSelectScalar = {
    id?: boolean
    name?: boolean
    capacity?: boolean
    zoneName?: boolean
    statusCode?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type TableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "capacity" | "zoneName" | "statusCode" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["table"]>
  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | Table$zoneArgs<ExtArgs>
    status?: boolean | TableStatusDefaultArgs<ExtArgs>
    tableSessions?: boolean | Table$tableSessionsArgs<ExtArgs>
    combineTableItems?: boolean | Table$combineTableItemsArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      zone: Prisma.$RestaurantZonePayload<ExtArgs> | null
      status: Prisma.$TableStatusPayload<ExtArgs>
      tableSessions: Prisma.$TableSessionPayload<ExtArgs>[]
      combineTableItems: Prisma.$CombineTableItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      capacity: number
      zoneName: string | null
      statusCode: string
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableWithIdOnly = await prisma.table.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends Table$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Table$zoneArgs<ExtArgs>>): Prisma__RestaurantZoneClient<$Result.GetResult<Prisma.$RestaurantZonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    status<T extends TableStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableStatusDefaultArgs<ExtArgs>>): Prisma__TableStatusClient<$Result.GetResult<Prisma.$TableStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tableSessions<T extends Table$tableSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Table$tableSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    combineTableItems<T extends Table$combineTableItemsArgs<ExtArgs> = {}>(args?: Subset<T, Table$combineTableItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */
  interface TableFieldRefs {
    readonly id: FieldRef<"Table", 'Int'>
    readonly name: FieldRef<"Table", 'String'>
    readonly capacity: FieldRef<"Table", 'Int'>
    readonly zoneName: FieldRef<"Table", 'String'>
    readonly statusCode: FieldRef<"Table", 'String'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly createdBy: FieldRef<"Table", 'String'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
    readonly updatedBy: FieldRef<"Table", 'String'>
    readonly deletedAt: FieldRef<"Table", 'DateTime'>
    readonly deletedBy: FieldRef<"Table", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to delete.
     */
    limit?: number
  }

  /**
   * Table.zone
   */
  export type Table$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RestaurantZone
     */
    select?: RestaurantZoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RestaurantZone
     */
    omit?: RestaurantZoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RestaurantZoneInclude<ExtArgs> | null
    where?: RestaurantZoneWhereInput
  }

  /**
   * Table.tableSessions
   */
  export type Table$tableSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    where?: TableSessionWhereInput
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    cursor?: TableSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * Table.combineTableItems
   */
  export type Table$combineTableItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    where?: CombineTableItemWhereInput
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    cursor?: CombineTableItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombineTableItemScalarFieldEnum | CombineTableItemScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model CombineTable
   */

  export type AggregateCombineTable = {
    _count: CombineTableCountAggregateOutputType | null
    _avg: CombineTableAvgAggregateOutputType | null
    _sum: CombineTableSumAggregateOutputType | null
    _min: CombineTableMinAggregateOutputType | null
    _max: CombineTableMaxAggregateOutputType | null
  }

  export type CombineTableAvgAggregateOutputType = {
    id: number | null
  }

  export type CombineTableSumAggregateOutputType = {
    id: number | null
  }

  export type CombineTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    combinerUserDocument: string | null
    combineAt: Date | null
    isActive: boolean | null
    releaserUserDocument: string | null
    releasedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CombineTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    combinerUserDocument: string | null
    combineAt: Date | null
    isActive: boolean | null
    releaserUserDocument: string | null
    releasedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CombineTableCountAggregateOutputType = {
    id: number
    name: number
    combinerUserDocument: number
    combineAt: number
    isActive: number
    releaserUserDocument: number
    releasedAt: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type CombineTableAvgAggregateInputType = {
    id?: true
  }

  export type CombineTableSumAggregateInputType = {
    id?: true
  }

  export type CombineTableMinAggregateInputType = {
    id?: true
    name?: true
    combinerUserDocument?: true
    combineAt?: true
    isActive?: true
    releaserUserDocument?: true
    releasedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CombineTableMaxAggregateInputType = {
    id?: true
    name?: true
    combinerUserDocument?: true
    combineAt?: true
    isActive?: true
    releaserUserDocument?: true
    releasedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CombineTableCountAggregateInputType = {
    id?: true
    name?: true
    combinerUserDocument?: true
    combineAt?: true
    isActive?: true
    releaserUserDocument?: true
    releasedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type CombineTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombineTable to aggregate.
     */
    where?: CombineTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTables to fetch.
     */
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombineTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombineTables
    **/
    _count?: true | CombineTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombineTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombineTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombineTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombineTableMaxAggregateInputType
  }

  export type GetCombineTableAggregateType<T extends CombineTableAggregateArgs> = {
        [P in keyof T & keyof AggregateCombineTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombineTable[P]>
      : GetScalarType<T[P], AggregateCombineTable[P]>
  }




  export type CombineTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableWhereInput
    orderBy?: CombineTableOrderByWithAggregationInput | CombineTableOrderByWithAggregationInput[]
    by: CombineTableScalarFieldEnum[] | CombineTableScalarFieldEnum
    having?: CombineTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombineTableCountAggregateInputType | true
    _avg?: CombineTableAvgAggregateInputType
    _sum?: CombineTableSumAggregateInputType
    _min?: CombineTableMinAggregateInputType
    _max?: CombineTableMaxAggregateInputType
  }

  export type CombineTableGroupByOutputType = {
    id: number
    name: string
    combinerUserDocument: string
    combineAt: Date
    isActive: boolean
    releaserUserDocument: string | null
    releasedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: CombineTableCountAggregateOutputType | null
    _avg: CombineTableAvgAggregateOutputType | null
    _sum: CombineTableSumAggregateOutputType | null
    _min: CombineTableMinAggregateOutputType | null
    _max: CombineTableMaxAggregateOutputType | null
  }

  type GetCombineTableGroupByPayload<T extends CombineTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombineTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombineTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombineTableGroupByOutputType[P]>
            : GetScalarType<T[P], CombineTableGroupByOutputType[P]>
        }
      >
    >


  export type CombineTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    combinerUserDocument?: boolean
    combineAt?: boolean
    isActive?: boolean
    releaserUserDocument?: boolean
    releasedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    combiner?: boolean | UserDefaultArgs<ExtArgs>
    releaser?: boolean | CombineTable$releaserArgs<ExtArgs>
    tables?: boolean | CombineTable$tablesArgs<ExtArgs>
    tableSessions?: boolean | CombineTable$tableSessionsArgs<ExtArgs>
    _count?: boolean | CombineTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combineTable"]>



  export type CombineTableSelectScalar = {
    id?: boolean
    name?: boolean
    combinerUserDocument?: boolean
    combineAt?: boolean
    isActive?: boolean
    releaserUserDocument?: boolean
    releasedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type CombineTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "combinerUserDocument" | "combineAt" | "isActive" | "releaserUserDocument" | "releasedAt" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["combineTable"]>
  export type CombineTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    combiner?: boolean | UserDefaultArgs<ExtArgs>
    releaser?: boolean | CombineTable$releaserArgs<ExtArgs>
    tables?: boolean | CombineTable$tablesArgs<ExtArgs>
    tableSessions?: boolean | CombineTable$tableSessionsArgs<ExtArgs>
    _count?: boolean | CombineTableCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CombineTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombineTable"
    objects: {
      combiner: Prisma.$UserPayload<ExtArgs>
      releaser: Prisma.$UserPayload<ExtArgs> | null
      tables: Prisma.$CombineTableItemPayload<ExtArgs>[]
      tableSessions: Prisma.$TableSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      combinerUserDocument: string
      combineAt: Date
      isActive: boolean
      releaserUserDocument: string | null
      releasedAt: Date | null
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["combineTable"]>
    composites: {}
  }

  type CombineTableGetPayload<S extends boolean | null | undefined | CombineTableDefaultArgs> = $Result.GetResult<Prisma.$CombineTablePayload, S>

  type CombineTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CombineTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CombineTableCountAggregateInputType | true
    }

  export interface CombineTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombineTable'], meta: { name: 'CombineTable' } }
    /**
     * Find zero or one CombineTable that matches the filter.
     * @param {CombineTableFindUniqueArgs} args - Arguments to find a CombineTable
     * @example
     * // Get one CombineTable
     * const combineTable = await prisma.combineTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombineTableFindUniqueArgs>(args: SelectSubset<T, CombineTableFindUniqueArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CombineTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CombineTableFindUniqueOrThrowArgs} args - Arguments to find a CombineTable
     * @example
     * // Get one CombineTable
     * const combineTable = await prisma.combineTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombineTableFindUniqueOrThrowArgs>(args: SelectSubset<T, CombineTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombineTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableFindFirstArgs} args - Arguments to find a CombineTable
     * @example
     * // Get one CombineTable
     * const combineTable = await prisma.combineTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombineTableFindFirstArgs>(args?: SelectSubset<T, CombineTableFindFirstArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombineTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableFindFirstOrThrowArgs} args - Arguments to find a CombineTable
     * @example
     * // Get one CombineTable
     * const combineTable = await prisma.combineTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombineTableFindFirstOrThrowArgs>(args?: SelectSubset<T, CombineTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CombineTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombineTables
     * const combineTables = await prisma.combineTable.findMany()
     * 
     * // Get first 10 CombineTables
     * const combineTables = await prisma.combineTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combineTableWithIdOnly = await prisma.combineTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombineTableFindManyArgs>(args?: SelectSubset<T, CombineTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CombineTable.
     * @param {CombineTableCreateArgs} args - Arguments to create a CombineTable.
     * @example
     * // Create one CombineTable
     * const CombineTable = await prisma.combineTable.create({
     *   data: {
     *     // ... data to create a CombineTable
     *   }
     * })
     * 
     */
    create<T extends CombineTableCreateArgs>(args: SelectSubset<T, CombineTableCreateArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CombineTables.
     * @param {CombineTableCreateManyArgs} args - Arguments to create many CombineTables.
     * @example
     * // Create many CombineTables
     * const combineTable = await prisma.combineTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombineTableCreateManyArgs>(args?: SelectSubset<T, CombineTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CombineTable.
     * @param {CombineTableDeleteArgs} args - Arguments to delete one CombineTable.
     * @example
     * // Delete one CombineTable
     * const CombineTable = await prisma.combineTable.delete({
     *   where: {
     *     // ... filter to delete one CombineTable
     *   }
     * })
     * 
     */
    delete<T extends CombineTableDeleteArgs>(args: SelectSubset<T, CombineTableDeleteArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CombineTable.
     * @param {CombineTableUpdateArgs} args - Arguments to update one CombineTable.
     * @example
     * // Update one CombineTable
     * const combineTable = await prisma.combineTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombineTableUpdateArgs>(args: SelectSubset<T, CombineTableUpdateArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CombineTables.
     * @param {CombineTableDeleteManyArgs} args - Arguments to filter CombineTables to delete.
     * @example
     * // Delete a few CombineTables
     * const { count } = await prisma.combineTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombineTableDeleteManyArgs>(args?: SelectSubset<T, CombineTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombineTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombineTables
     * const combineTable = await prisma.combineTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombineTableUpdateManyArgs>(args: SelectSubset<T, CombineTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CombineTable.
     * @param {CombineTableUpsertArgs} args - Arguments to update or create a CombineTable.
     * @example
     * // Update or create a CombineTable
     * const combineTable = await prisma.combineTable.upsert({
     *   create: {
     *     // ... data to create a CombineTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombineTable we want to update
     *   }
     * })
     */
    upsert<T extends CombineTableUpsertArgs>(args: SelectSubset<T, CombineTableUpsertArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CombineTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableCountArgs} args - Arguments to filter CombineTables to count.
     * @example
     * // Count the number of CombineTables
     * const count = await prisma.combineTable.count({
     *   where: {
     *     // ... the filter for the CombineTables we want to count
     *   }
     * })
    **/
    count<T extends CombineTableCountArgs>(
      args?: Subset<T, CombineTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombineTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombineTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombineTableAggregateArgs>(args: Subset<T, CombineTableAggregateArgs>): Prisma.PrismaPromise<GetCombineTableAggregateType<T>>

    /**
     * Group by CombineTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombineTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombineTableGroupByArgs['orderBy'] }
        : { orderBy?: CombineTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombineTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombineTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombineTable model
   */
  readonly fields: CombineTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombineTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombineTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    combiner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    releaser<T extends CombineTable$releaserArgs<ExtArgs> = {}>(args?: Subset<T, CombineTable$releaserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tables<T extends CombineTable$tablesArgs<ExtArgs> = {}>(args?: Subset<T, CombineTable$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tableSessions<T extends CombineTable$tableSessionsArgs<ExtArgs> = {}>(args?: Subset<T, CombineTable$tableSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombineTable model
   */
  interface CombineTableFieldRefs {
    readonly id: FieldRef<"CombineTable", 'Int'>
    readonly name: FieldRef<"CombineTable", 'String'>
    readonly combinerUserDocument: FieldRef<"CombineTable", 'String'>
    readonly combineAt: FieldRef<"CombineTable", 'DateTime'>
    readonly isActive: FieldRef<"CombineTable", 'Boolean'>
    readonly releaserUserDocument: FieldRef<"CombineTable", 'String'>
    readonly releasedAt: FieldRef<"CombineTable", 'DateTime'>
    readonly updatedAt: FieldRef<"CombineTable", 'DateTime'>
    readonly updatedBy: FieldRef<"CombineTable", 'String'>
    readonly deletedAt: FieldRef<"CombineTable", 'DateTime'>
    readonly deletedBy: FieldRef<"CombineTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CombineTable findUnique
   */
  export type CombineTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter, which CombineTable to fetch.
     */
    where: CombineTableWhereUniqueInput
  }

  /**
   * CombineTable findUniqueOrThrow
   */
  export type CombineTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter, which CombineTable to fetch.
     */
    where: CombineTableWhereUniqueInput
  }

  /**
   * CombineTable findFirst
   */
  export type CombineTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter, which CombineTable to fetch.
     */
    where?: CombineTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTables to fetch.
     */
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombineTables.
     */
    cursor?: CombineTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombineTables.
     */
    distinct?: CombineTableScalarFieldEnum | CombineTableScalarFieldEnum[]
  }

  /**
   * CombineTable findFirstOrThrow
   */
  export type CombineTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter, which CombineTable to fetch.
     */
    where?: CombineTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTables to fetch.
     */
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombineTables.
     */
    cursor?: CombineTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombineTables.
     */
    distinct?: CombineTableScalarFieldEnum | CombineTableScalarFieldEnum[]
  }

  /**
   * CombineTable findMany
   */
  export type CombineTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter, which CombineTables to fetch.
     */
    where?: CombineTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTables to fetch.
     */
    orderBy?: CombineTableOrderByWithRelationInput | CombineTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombineTables.
     */
    cursor?: CombineTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTables.
     */
    skip?: number
    distinct?: CombineTableScalarFieldEnum | CombineTableScalarFieldEnum[]
  }

  /**
   * CombineTable create
   */
  export type CombineTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * The data needed to create a CombineTable.
     */
    data: XOR<CombineTableCreateInput, CombineTableUncheckedCreateInput>
  }

  /**
   * CombineTable createMany
   */
  export type CombineTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombineTables.
     */
    data: CombineTableCreateManyInput | CombineTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombineTable update
   */
  export type CombineTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * The data needed to update a CombineTable.
     */
    data: XOR<CombineTableUpdateInput, CombineTableUncheckedUpdateInput>
    /**
     * Choose, which CombineTable to update.
     */
    where: CombineTableWhereUniqueInput
  }

  /**
   * CombineTable updateMany
   */
  export type CombineTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombineTables.
     */
    data: XOR<CombineTableUpdateManyMutationInput, CombineTableUncheckedUpdateManyInput>
    /**
     * Filter which CombineTables to update
     */
    where?: CombineTableWhereInput
    /**
     * Limit how many CombineTables to update.
     */
    limit?: number
  }

  /**
   * CombineTable upsert
   */
  export type CombineTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * The filter to search for the CombineTable to update in case it exists.
     */
    where: CombineTableWhereUniqueInput
    /**
     * In case the CombineTable found by the `where` argument doesn't exist, create a new CombineTable with this data.
     */
    create: XOR<CombineTableCreateInput, CombineTableUncheckedCreateInput>
    /**
     * In case the CombineTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombineTableUpdateInput, CombineTableUncheckedUpdateInput>
  }

  /**
   * CombineTable delete
   */
  export type CombineTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    /**
     * Filter which CombineTable to delete.
     */
    where: CombineTableWhereUniqueInput
  }

  /**
   * CombineTable deleteMany
   */
  export type CombineTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombineTables to delete
     */
    where?: CombineTableWhereInput
    /**
     * Limit how many CombineTables to delete.
     */
    limit?: number
  }

  /**
   * CombineTable.releaser
   */
  export type CombineTable$releaserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CombineTable.tables
   */
  export type CombineTable$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    where?: CombineTableItemWhereInput
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    cursor?: CombineTableItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombineTableItemScalarFieldEnum | CombineTableItemScalarFieldEnum[]
  }

  /**
   * CombineTable.tableSessions
   */
  export type CombineTable$tableSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    where?: TableSessionWhereInput
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    cursor?: TableSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * CombineTable without action
   */
  export type CombineTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
  }


  /**
   * Model CombineTableItem
   */

  export type AggregateCombineTableItem = {
    _count: CombineTableItemCountAggregateOutputType | null
    _avg: CombineTableItemAvgAggregateOutputType | null
    _sum: CombineTableItemSumAggregateOutputType | null
    _min: CombineTableItemMinAggregateOutputType | null
    _max: CombineTableItemMaxAggregateOutputType | null
  }

  export type CombineTableItemAvgAggregateOutputType = {
    id: number | null
    combineTableId: number | null
    tableId: number | null
  }

  export type CombineTableItemSumAggregateOutputType = {
    id: number | null
    combineTableId: number | null
    tableId: number | null
  }

  export type CombineTableItemMinAggregateOutputType = {
    id: number | null
    combineTableId: number | null
    tableId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CombineTableItemMaxAggregateOutputType = {
    id: number | null
    combineTableId: number | null
    tableId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type CombineTableItemCountAggregateOutputType = {
    id: number
    combineTableId: number
    tableId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type CombineTableItemAvgAggregateInputType = {
    id?: true
    combineTableId?: true
    tableId?: true
  }

  export type CombineTableItemSumAggregateInputType = {
    id?: true
    combineTableId?: true
    tableId?: true
  }

  export type CombineTableItemMinAggregateInputType = {
    id?: true
    combineTableId?: true
    tableId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CombineTableItemMaxAggregateInputType = {
    id?: true
    combineTableId?: true
    tableId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type CombineTableItemCountAggregateInputType = {
    id?: true
    combineTableId?: true
    tableId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type CombineTableItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombineTableItem to aggregate.
     */
    where?: CombineTableItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTableItems to fetch.
     */
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombineTableItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTableItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTableItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombineTableItems
    **/
    _count?: true | CombineTableItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombineTableItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombineTableItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombineTableItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombineTableItemMaxAggregateInputType
  }

  export type GetCombineTableItemAggregateType<T extends CombineTableItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCombineTableItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombineTableItem[P]>
      : GetScalarType<T[P], AggregateCombineTableItem[P]>
  }




  export type CombineTableItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombineTableItemWhereInput
    orderBy?: CombineTableItemOrderByWithAggregationInput | CombineTableItemOrderByWithAggregationInput[]
    by: CombineTableItemScalarFieldEnum[] | CombineTableItemScalarFieldEnum
    having?: CombineTableItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombineTableItemCountAggregateInputType | true
    _avg?: CombineTableItemAvgAggregateInputType
    _sum?: CombineTableItemSumAggregateInputType
    _min?: CombineTableItemMinAggregateInputType
    _max?: CombineTableItemMaxAggregateInputType
  }

  export type CombineTableItemGroupByOutputType = {
    id: number
    combineTableId: number
    tableId: number
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: CombineTableItemCountAggregateOutputType | null
    _avg: CombineTableItemAvgAggregateOutputType | null
    _sum: CombineTableItemSumAggregateOutputType | null
    _min: CombineTableItemMinAggregateOutputType | null
    _max: CombineTableItemMaxAggregateOutputType | null
  }

  type GetCombineTableItemGroupByPayload<T extends CombineTableItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombineTableItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombineTableItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombineTableItemGroupByOutputType[P]>
            : GetScalarType<T[P], CombineTableItemGroupByOutputType[P]>
        }
      >
    >


  export type CombineTableItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    combineTableId?: boolean
    tableId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    combineTable?: boolean | CombineTableDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combineTableItem"]>



  export type CombineTableItemSelectScalar = {
    id?: boolean
    combineTableId?: boolean
    tableId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type CombineTableItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "combineTableId" | "tableId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["combineTableItem"]>
  export type CombineTableItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    combineTable?: boolean | CombineTableDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
  }

  export type $CombineTableItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombineTableItem"
    objects: {
      combineTable: Prisma.$CombineTablePayload<ExtArgs>
      table: Prisma.$TablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      combineTableId: number
      tableId: number
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["combineTableItem"]>
    composites: {}
  }

  type CombineTableItemGetPayload<S extends boolean | null | undefined | CombineTableItemDefaultArgs> = $Result.GetResult<Prisma.$CombineTableItemPayload, S>

  type CombineTableItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CombineTableItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CombineTableItemCountAggregateInputType | true
    }

  export interface CombineTableItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombineTableItem'], meta: { name: 'CombineTableItem' } }
    /**
     * Find zero or one CombineTableItem that matches the filter.
     * @param {CombineTableItemFindUniqueArgs} args - Arguments to find a CombineTableItem
     * @example
     * // Get one CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombineTableItemFindUniqueArgs>(args: SelectSubset<T, CombineTableItemFindUniqueArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CombineTableItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CombineTableItemFindUniqueOrThrowArgs} args - Arguments to find a CombineTableItem
     * @example
     * // Get one CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombineTableItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CombineTableItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombineTableItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemFindFirstArgs} args - Arguments to find a CombineTableItem
     * @example
     * // Get one CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombineTableItemFindFirstArgs>(args?: SelectSubset<T, CombineTableItemFindFirstArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CombineTableItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemFindFirstOrThrowArgs} args - Arguments to find a CombineTableItem
     * @example
     * // Get one CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombineTableItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CombineTableItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CombineTableItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombineTableItems
     * const combineTableItems = await prisma.combineTableItem.findMany()
     * 
     * // Get first 10 CombineTableItems
     * const combineTableItems = await prisma.combineTableItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combineTableItemWithIdOnly = await prisma.combineTableItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombineTableItemFindManyArgs>(args?: SelectSubset<T, CombineTableItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CombineTableItem.
     * @param {CombineTableItemCreateArgs} args - Arguments to create a CombineTableItem.
     * @example
     * // Create one CombineTableItem
     * const CombineTableItem = await prisma.combineTableItem.create({
     *   data: {
     *     // ... data to create a CombineTableItem
     *   }
     * })
     * 
     */
    create<T extends CombineTableItemCreateArgs>(args: SelectSubset<T, CombineTableItemCreateArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CombineTableItems.
     * @param {CombineTableItemCreateManyArgs} args - Arguments to create many CombineTableItems.
     * @example
     * // Create many CombineTableItems
     * const combineTableItem = await prisma.combineTableItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombineTableItemCreateManyArgs>(args?: SelectSubset<T, CombineTableItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CombineTableItem.
     * @param {CombineTableItemDeleteArgs} args - Arguments to delete one CombineTableItem.
     * @example
     * // Delete one CombineTableItem
     * const CombineTableItem = await prisma.combineTableItem.delete({
     *   where: {
     *     // ... filter to delete one CombineTableItem
     *   }
     * })
     * 
     */
    delete<T extends CombineTableItemDeleteArgs>(args: SelectSubset<T, CombineTableItemDeleteArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CombineTableItem.
     * @param {CombineTableItemUpdateArgs} args - Arguments to update one CombineTableItem.
     * @example
     * // Update one CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombineTableItemUpdateArgs>(args: SelectSubset<T, CombineTableItemUpdateArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CombineTableItems.
     * @param {CombineTableItemDeleteManyArgs} args - Arguments to filter CombineTableItems to delete.
     * @example
     * // Delete a few CombineTableItems
     * const { count } = await prisma.combineTableItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombineTableItemDeleteManyArgs>(args?: SelectSubset<T, CombineTableItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombineTableItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombineTableItems
     * const combineTableItem = await prisma.combineTableItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombineTableItemUpdateManyArgs>(args: SelectSubset<T, CombineTableItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CombineTableItem.
     * @param {CombineTableItemUpsertArgs} args - Arguments to update or create a CombineTableItem.
     * @example
     * // Update or create a CombineTableItem
     * const combineTableItem = await prisma.combineTableItem.upsert({
     *   create: {
     *     // ... data to create a CombineTableItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombineTableItem we want to update
     *   }
     * })
     */
    upsert<T extends CombineTableItemUpsertArgs>(args: SelectSubset<T, CombineTableItemUpsertArgs<ExtArgs>>): Prisma__CombineTableItemClient<$Result.GetResult<Prisma.$CombineTableItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CombineTableItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemCountArgs} args - Arguments to filter CombineTableItems to count.
     * @example
     * // Count the number of CombineTableItems
     * const count = await prisma.combineTableItem.count({
     *   where: {
     *     // ... the filter for the CombineTableItems we want to count
     *   }
     * })
    **/
    count<T extends CombineTableItemCountArgs>(
      args?: Subset<T, CombineTableItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombineTableItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombineTableItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombineTableItemAggregateArgs>(args: Subset<T, CombineTableItemAggregateArgs>): Prisma.PrismaPromise<GetCombineTableItemAggregateType<T>>

    /**
     * Group by CombineTableItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombineTableItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombineTableItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombineTableItemGroupByArgs['orderBy'] }
        : { orderBy?: CombineTableItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombineTableItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombineTableItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombineTableItem model
   */
  readonly fields: CombineTableItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombineTableItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombineTableItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    combineTable<T extends CombineTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CombineTableDefaultArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombineTableItem model
   */
  interface CombineTableItemFieldRefs {
    readonly id: FieldRef<"CombineTableItem", 'Int'>
    readonly combineTableId: FieldRef<"CombineTableItem", 'Int'>
    readonly tableId: FieldRef<"CombineTableItem", 'Int'>
    readonly createdAt: FieldRef<"CombineTableItem", 'DateTime'>
    readonly createdBy: FieldRef<"CombineTableItem", 'String'>
    readonly updatedAt: FieldRef<"CombineTableItem", 'DateTime'>
    readonly updatedBy: FieldRef<"CombineTableItem", 'String'>
    readonly deletedAt: FieldRef<"CombineTableItem", 'DateTime'>
    readonly deletedBy: FieldRef<"CombineTableItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CombineTableItem findUnique
   */
  export type CombineTableItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter, which CombineTableItem to fetch.
     */
    where: CombineTableItemWhereUniqueInput
  }

  /**
   * CombineTableItem findUniqueOrThrow
   */
  export type CombineTableItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter, which CombineTableItem to fetch.
     */
    where: CombineTableItemWhereUniqueInput
  }

  /**
   * CombineTableItem findFirst
   */
  export type CombineTableItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter, which CombineTableItem to fetch.
     */
    where?: CombineTableItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTableItems to fetch.
     */
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombineTableItems.
     */
    cursor?: CombineTableItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTableItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTableItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombineTableItems.
     */
    distinct?: CombineTableItemScalarFieldEnum | CombineTableItemScalarFieldEnum[]
  }

  /**
   * CombineTableItem findFirstOrThrow
   */
  export type CombineTableItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter, which CombineTableItem to fetch.
     */
    where?: CombineTableItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTableItems to fetch.
     */
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombineTableItems.
     */
    cursor?: CombineTableItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTableItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTableItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombineTableItems.
     */
    distinct?: CombineTableItemScalarFieldEnum | CombineTableItemScalarFieldEnum[]
  }

  /**
   * CombineTableItem findMany
   */
  export type CombineTableItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter, which CombineTableItems to fetch.
     */
    where?: CombineTableItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombineTableItems to fetch.
     */
    orderBy?: CombineTableItemOrderByWithRelationInput | CombineTableItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombineTableItems.
     */
    cursor?: CombineTableItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombineTableItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombineTableItems.
     */
    skip?: number
    distinct?: CombineTableItemScalarFieldEnum | CombineTableItemScalarFieldEnum[]
  }

  /**
   * CombineTableItem create
   */
  export type CombineTableItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CombineTableItem.
     */
    data: XOR<CombineTableItemCreateInput, CombineTableItemUncheckedCreateInput>
  }

  /**
   * CombineTableItem createMany
   */
  export type CombineTableItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombineTableItems.
     */
    data: CombineTableItemCreateManyInput | CombineTableItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombineTableItem update
   */
  export type CombineTableItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CombineTableItem.
     */
    data: XOR<CombineTableItemUpdateInput, CombineTableItemUncheckedUpdateInput>
    /**
     * Choose, which CombineTableItem to update.
     */
    where: CombineTableItemWhereUniqueInput
  }

  /**
   * CombineTableItem updateMany
   */
  export type CombineTableItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombineTableItems.
     */
    data: XOR<CombineTableItemUpdateManyMutationInput, CombineTableItemUncheckedUpdateManyInput>
    /**
     * Filter which CombineTableItems to update
     */
    where?: CombineTableItemWhereInput
    /**
     * Limit how many CombineTableItems to update.
     */
    limit?: number
  }

  /**
   * CombineTableItem upsert
   */
  export type CombineTableItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CombineTableItem to update in case it exists.
     */
    where: CombineTableItemWhereUniqueInput
    /**
     * In case the CombineTableItem found by the `where` argument doesn't exist, create a new CombineTableItem with this data.
     */
    create: XOR<CombineTableItemCreateInput, CombineTableItemUncheckedCreateInput>
    /**
     * In case the CombineTableItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombineTableItemUpdateInput, CombineTableItemUncheckedUpdateInput>
  }

  /**
   * CombineTableItem delete
   */
  export type CombineTableItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
    /**
     * Filter which CombineTableItem to delete.
     */
    where: CombineTableItemWhereUniqueInput
  }

  /**
   * CombineTableItem deleteMany
   */
  export type CombineTableItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombineTableItems to delete
     */
    where?: CombineTableItemWhereInput
    /**
     * Limit how many CombineTableItems to delete.
     */
    limit?: number
  }

  /**
   * CombineTableItem without action
   */
  export type CombineTableItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTableItem
     */
    select?: CombineTableItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTableItem
     */
    omit?: CombineTableItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableItemInclude<ExtArgs> | null
  }


  /**
   * Model TableSession
   */

  export type AggregateTableSession = {
    _count: TableSessionCountAggregateOutputType | null
    _avg: TableSessionAvgAggregateOutputType | null
    _sum: TableSessionSumAggregateOutputType | null
    _min: TableSessionMinAggregateOutputType | null
    _max: TableSessionMaxAggregateOutputType | null
  }

  export type TableSessionAvgAggregateOutputType = {
    id: number | null
    tableId: number | null
    combineTableId: number | null
    numberPeople: number | null
  }

  export type TableSessionSumAggregateOutputType = {
    id: number | null
    tableId: number | null
    combineTableId: number | null
    numberPeople: number | null
  }

  export type TableSessionMinAggregateOutputType = {
    id: number | null
    tableId: number | null
    combineTableId: number | null
    openerUserDocument: string | null
    openedAt: Date | null
    numberPeople: number | null
    isActive: boolean | null
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TableSessionMaxAggregateOutputType = {
    id: number | null
    tableId: number | null
    combineTableId: number | null
    openerUserDocument: string | null
    openedAt: Date | null
    numberPeople: number | null
    isActive: boolean | null
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type TableSessionCountAggregateOutputType = {
    id: number
    tableId: number
    combineTableId: number
    openerUserDocument: number
    openedAt: number
    numberPeople: number
    isActive: number
    closerUserDocument: number
    closedAt: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type TableSessionAvgAggregateInputType = {
    id?: true
    tableId?: true
    combineTableId?: true
    numberPeople?: true
  }

  export type TableSessionSumAggregateInputType = {
    id?: true
    tableId?: true
    combineTableId?: true
    numberPeople?: true
  }

  export type TableSessionMinAggregateInputType = {
    id?: true
    tableId?: true
    combineTableId?: true
    openerUserDocument?: true
    openedAt?: true
    numberPeople?: true
    isActive?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TableSessionMaxAggregateInputType = {
    id?: true
    tableId?: true
    combineTableId?: true
    openerUserDocument?: true
    openedAt?: true
    numberPeople?: true
    isActive?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type TableSessionCountAggregateInputType = {
    id?: true
    tableId?: true
    combineTableId?: true
    openerUserDocument?: true
    openedAt?: true
    numberPeople?: true
    isActive?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type TableSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableSession to aggregate.
     */
    where?: TableSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableSessions to fetch.
     */
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableSessions
    **/
    _count?: true | TableSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableSessionMaxAggregateInputType
  }

  export type GetTableSessionAggregateType<T extends TableSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTableSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableSession[P]>
      : GetScalarType<T[P], AggregateTableSession[P]>
  }




  export type TableSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableSessionWhereInput
    orderBy?: TableSessionOrderByWithAggregationInput | TableSessionOrderByWithAggregationInput[]
    by: TableSessionScalarFieldEnum[] | TableSessionScalarFieldEnum
    having?: TableSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableSessionCountAggregateInputType | true
    _avg?: TableSessionAvgAggregateInputType
    _sum?: TableSessionSumAggregateInputType
    _min?: TableSessionMinAggregateInputType
    _max?: TableSessionMaxAggregateInputType
  }

  export type TableSessionGroupByOutputType = {
    id: number
    tableId: number | null
    combineTableId: number | null
    openerUserDocument: string
    openedAt: Date
    numberPeople: number
    isActive: boolean
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: TableSessionCountAggregateOutputType | null
    _avg: TableSessionAvgAggregateOutputType | null
    _sum: TableSessionSumAggregateOutputType | null
    _min: TableSessionMinAggregateOutputType | null
    _max: TableSessionMaxAggregateOutputType | null
  }

  type GetTableSessionGroupByPayload<T extends TableSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TableSessionGroupByOutputType[P]>
        }
      >
    >


  export type TableSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    combineTableId?: boolean
    openerUserDocument?: boolean
    openedAt?: boolean
    numberPeople?: boolean
    isActive?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    table?: boolean | TableSession$tableArgs<ExtArgs>
    combineTable?: boolean | TableSession$combineTableArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
    closer?: boolean | TableSession$closerArgs<ExtArgs>
    orders?: boolean | TableSession$ordersArgs<ExtArgs>
    _count?: boolean | TableSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableSession"]>



  export type TableSessionSelectScalar = {
    id?: boolean
    tableId?: boolean
    combineTableId?: boolean
    openerUserDocument?: boolean
    openedAt?: boolean
    numberPeople?: boolean
    isActive?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type TableSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "combineTableId" | "openerUserDocument" | "openedAt" | "numberPeople" | "isActive" | "closerUserDocument" | "closedAt" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["tableSession"]>
  export type TableSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | TableSession$tableArgs<ExtArgs>
    combineTable?: boolean | TableSession$combineTableArgs<ExtArgs>
    opener?: boolean | UserDefaultArgs<ExtArgs>
    closer?: boolean | TableSession$closerArgs<ExtArgs>
    orders?: boolean | TableSession$ordersArgs<ExtArgs>
    _count?: boolean | TableSessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TableSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TableSession"
    objects: {
      table: Prisma.$TablePayload<ExtArgs> | null
      combineTable: Prisma.$CombineTablePayload<ExtArgs> | null
      opener: Prisma.$UserPayload<ExtArgs>
      closer: Prisma.$UserPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableId: number | null
      combineTableId: number | null
      openerUserDocument: string
      openedAt: Date
      numberPeople: number
      isActive: boolean
      closerUserDocument: string | null
      closedAt: Date | null
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["tableSession"]>
    composites: {}
  }

  type TableSessionGetPayload<S extends boolean | null | undefined | TableSessionDefaultArgs> = $Result.GetResult<Prisma.$TableSessionPayload, S>

  type TableSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableSessionCountAggregateInputType | true
    }

  export interface TableSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TableSession'], meta: { name: 'TableSession' } }
    /**
     * Find zero or one TableSession that matches the filter.
     * @param {TableSessionFindUniqueArgs} args - Arguments to find a TableSession
     * @example
     * // Get one TableSession
     * const tableSession = await prisma.tableSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableSessionFindUniqueArgs>(args: SelectSubset<T, TableSessionFindUniqueArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TableSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableSessionFindUniqueOrThrowArgs} args - Arguments to find a TableSession
     * @example
     * // Get one TableSession
     * const tableSession = await prisma.tableSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TableSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionFindFirstArgs} args - Arguments to find a TableSession
     * @example
     * // Get one TableSession
     * const tableSession = await prisma.tableSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableSessionFindFirstArgs>(args?: SelectSubset<T, TableSessionFindFirstArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionFindFirstOrThrowArgs} args - Arguments to find a TableSession
     * @example
     * // Get one TableSession
     * const tableSession = await prisma.tableSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TableSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TableSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableSessions
     * const tableSessions = await prisma.tableSession.findMany()
     * 
     * // Get first 10 TableSessions
     * const tableSessions = await prisma.tableSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableSessionWithIdOnly = await prisma.tableSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableSessionFindManyArgs>(args?: SelectSubset<T, TableSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TableSession.
     * @param {TableSessionCreateArgs} args - Arguments to create a TableSession.
     * @example
     * // Create one TableSession
     * const TableSession = await prisma.tableSession.create({
     *   data: {
     *     // ... data to create a TableSession
     *   }
     * })
     * 
     */
    create<T extends TableSessionCreateArgs>(args: SelectSubset<T, TableSessionCreateArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TableSessions.
     * @param {TableSessionCreateManyArgs} args - Arguments to create many TableSessions.
     * @example
     * // Create many TableSessions
     * const tableSession = await prisma.tableSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableSessionCreateManyArgs>(args?: SelectSubset<T, TableSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TableSession.
     * @param {TableSessionDeleteArgs} args - Arguments to delete one TableSession.
     * @example
     * // Delete one TableSession
     * const TableSession = await prisma.tableSession.delete({
     *   where: {
     *     // ... filter to delete one TableSession
     *   }
     * })
     * 
     */
    delete<T extends TableSessionDeleteArgs>(args: SelectSubset<T, TableSessionDeleteArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TableSession.
     * @param {TableSessionUpdateArgs} args - Arguments to update one TableSession.
     * @example
     * // Update one TableSession
     * const tableSession = await prisma.tableSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableSessionUpdateArgs>(args: SelectSubset<T, TableSessionUpdateArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TableSessions.
     * @param {TableSessionDeleteManyArgs} args - Arguments to filter TableSessions to delete.
     * @example
     * // Delete a few TableSessions
     * const { count } = await prisma.tableSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableSessionDeleteManyArgs>(args?: SelectSubset<T, TableSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableSessions
     * const tableSession = await prisma.tableSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableSessionUpdateManyArgs>(args: SelectSubset<T, TableSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TableSession.
     * @param {TableSessionUpsertArgs} args - Arguments to update or create a TableSession.
     * @example
     * // Update or create a TableSession
     * const tableSession = await prisma.tableSession.upsert({
     *   create: {
     *     // ... data to create a TableSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableSession we want to update
     *   }
     * })
     */
    upsert<T extends TableSessionUpsertArgs>(args: SelectSubset<T, TableSessionUpsertArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TableSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionCountArgs} args - Arguments to filter TableSessions to count.
     * @example
     * // Count the number of TableSessions
     * const count = await prisma.tableSession.count({
     *   where: {
     *     // ... the filter for the TableSessions we want to count
     *   }
     * })
    **/
    count<T extends TableSessionCountArgs>(
      args?: Subset<T, TableSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableSessionAggregateArgs>(args: Subset<T, TableSessionAggregateArgs>): Prisma.PrismaPromise<GetTableSessionAggregateType<T>>

    /**
     * Group by TableSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableSessionGroupByArgs['orderBy'] }
        : { orderBy?: TableSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TableSession model
   */
  readonly fields: TableSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends TableSession$tableArgs<ExtArgs> = {}>(args?: Subset<T, TableSession$tableArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    combineTable<T extends TableSession$combineTableArgs<ExtArgs> = {}>(args?: Subset<T, TableSession$combineTableArgs<ExtArgs>>): Prisma__CombineTableClient<$Result.GetResult<Prisma.$CombineTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    opener<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    closer<T extends TableSession$closerArgs<ExtArgs> = {}>(args?: Subset<T, TableSession$closerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends TableSession$ordersArgs<ExtArgs> = {}>(args?: Subset<T, TableSession$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TableSession model
   */
  interface TableSessionFieldRefs {
    readonly id: FieldRef<"TableSession", 'Int'>
    readonly tableId: FieldRef<"TableSession", 'Int'>
    readonly combineTableId: FieldRef<"TableSession", 'Int'>
    readonly openerUserDocument: FieldRef<"TableSession", 'String'>
    readonly openedAt: FieldRef<"TableSession", 'DateTime'>
    readonly numberPeople: FieldRef<"TableSession", 'Int'>
    readonly isActive: FieldRef<"TableSession", 'Boolean'>
    readonly closerUserDocument: FieldRef<"TableSession", 'String'>
    readonly closedAt: FieldRef<"TableSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TableSession", 'DateTime'>
    readonly updatedBy: FieldRef<"TableSession", 'String'>
    readonly deletedAt: FieldRef<"TableSession", 'DateTime'>
    readonly deletedBy: FieldRef<"TableSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TableSession findUnique
   */
  export type TableSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter, which TableSession to fetch.
     */
    where: TableSessionWhereUniqueInput
  }

  /**
   * TableSession findUniqueOrThrow
   */
  export type TableSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter, which TableSession to fetch.
     */
    where: TableSessionWhereUniqueInput
  }

  /**
   * TableSession findFirst
   */
  export type TableSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter, which TableSession to fetch.
     */
    where?: TableSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableSessions to fetch.
     */
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableSessions.
     */
    cursor?: TableSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableSessions.
     */
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * TableSession findFirstOrThrow
   */
  export type TableSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter, which TableSession to fetch.
     */
    where?: TableSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableSessions to fetch.
     */
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableSessions.
     */
    cursor?: TableSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableSessions.
     */
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * TableSession findMany
   */
  export type TableSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter, which TableSessions to fetch.
     */
    where?: TableSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableSessions to fetch.
     */
    orderBy?: TableSessionOrderByWithRelationInput | TableSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableSessions.
     */
    cursor?: TableSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableSessions.
     */
    skip?: number
    distinct?: TableSessionScalarFieldEnum | TableSessionScalarFieldEnum[]
  }

  /**
   * TableSession create
   */
  export type TableSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TableSession.
     */
    data: XOR<TableSessionCreateInput, TableSessionUncheckedCreateInput>
  }

  /**
   * TableSession createMany
   */
  export type TableSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TableSessions.
     */
    data: TableSessionCreateManyInput | TableSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TableSession update
   */
  export type TableSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TableSession.
     */
    data: XOR<TableSessionUpdateInput, TableSessionUncheckedUpdateInput>
    /**
     * Choose, which TableSession to update.
     */
    where: TableSessionWhereUniqueInput
  }

  /**
   * TableSession updateMany
   */
  export type TableSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TableSessions.
     */
    data: XOR<TableSessionUpdateManyMutationInput, TableSessionUncheckedUpdateManyInput>
    /**
     * Filter which TableSessions to update
     */
    where?: TableSessionWhereInput
    /**
     * Limit how many TableSessions to update.
     */
    limit?: number
  }

  /**
   * TableSession upsert
   */
  export type TableSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TableSession to update in case it exists.
     */
    where: TableSessionWhereUniqueInput
    /**
     * In case the TableSession found by the `where` argument doesn't exist, create a new TableSession with this data.
     */
    create: XOR<TableSessionCreateInput, TableSessionUncheckedCreateInput>
    /**
     * In case the TableSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableSessionUpdateInput, TableSessionUncheckedUpdateInput>
  }

  /**
   * TableSession delete
   */
  export type TableSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    /**
     * Filter which TableSession to delete.
     */
    where: TableSessionWhereUniqueInput
  }

  /**
   * TableSession deleteMany
   */
  export type TableSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableSessions to delete
     */
    where?: TableSessionWhereInput
    /**
     * Limit how many TableSessions to delete.
     */
    limit?: number
  }

  /**
   * TableSession.table
   */
  export type TableSession$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
  }

  /**
   * TableSession.combineTable
   */
  export type TableSession$combineTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombineTable
     */
    select?: CombineTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CombineTable
     */
    omit?: CombineTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombineTableInclude<ExtArgs> | null
    where?: CombineTableWhereInput
  }

  /**
   * TableSession.closer
   */
  export type TableSession$closerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TableSession.orders
   */
  export type TableSession$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * TableSession without action
   */
  export type TableSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    imageableId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    imageableId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    name: string | null
    altText: string | null
    url: string | null
    imageableId: number | null
    imageableType: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    altText: string | null
    url: string | null
    imageableId: number | null
    imageableType: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    name: number
    altText: number
    url: number
    imageableId: number
    imageableType: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    imageableId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    imageableId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    name?: true
    altText?: true
    url?: true
    imageableId?: true
    imageableType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    name?: true
    altText?: true
    url?: true
    imageableId?: true
    imageableType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    name?: true
    altText?: true
    url?: true
    imageableId?: true
    imageableType?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    name: string
    altText: string
    url: string
    imageableId: number
    imageableType: string
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    altText?: boolean
    url?: boolean
    imageableId?: boolean
    imageableType?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }, ExtArgs["result"]["image"]>



  export type ImageSelectScalar = {
    id?: boolean
    name?: boolean
    altText?: boolean
    url?: boolean
    imageableId?: boolean
    imageableType?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "altText" | "url" | "imageableId" | "imageableType" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["image"]>

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      altText: string
      url: string
      imageableId: number
      imageableType: string
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly name: FieldRef<"Image", 'String'>
    readonly altText: FieldRef<"Image", 'String'>
    readonly url: FieldRef<"Image", 'String'>
    readonly imageableId: FieldRef<"Image", 'Int'>
    readonly imageableType: FieldRef<"Image", 'String'>
    readonly isActive: FieldRef<"Image", 'Boolean'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly createdBy: FieldRef<"Image", 'String'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
    readonly updatedBy: FieldRef<"Image", 'String'>
    readonly deletedAt: FieldRef<"Image", 'DateTime'>
    readonly deletedBy: FieldRef<"Image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BrandMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type BrandCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BrandMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type BrandCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    products?: boolean | Brand$productsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>



  export type BrandSelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Brand$productsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const brandWithNameOnly = await prisma.brand.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Brand$productsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly name: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
    readonly color: FieldRef<"Brand", 'String'>
    readonly isActive: FieldRef<"Brand", 'Boolean'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly createdBy: FieldRef<"Brand", 'String'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedBy: FieldRef<"Brand", 'String'>
    readonly deletedAt: FieldRef<"Brand", 'DateTime'>
    readonly deletedBy: FieldRef<"Brand", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.products
   */
  export type Brand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model ProductStatus
   */

  export type AggregateProductStatus = {
    _count: ProductStatusCountAggregateOutputType | null
    _min: ProductStatusMinAggregateOutputType | null
    _max: ProductStatusMaxAggregateOutputType | null
  }

  export type ProductStatusMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductStatusMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type ProductStatusCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type ProductStatusMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductStatusMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type ProductStatusCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type ProductStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStatus to aggregate.
     */
    where?: ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStatuses to fetch.
     */
    orderBy?: ProductStatusOrderByWithRelationInput | ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductStatuses
    **/
    _count?: true | ProductStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductStatusMaxAggregateInputType
  }

  export type GetProductStatusAggregateType<T extends ProductStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateProductStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductStatus[P]>
      : GetScalarType<T[P], AggregateProductStatus[P]>
  }




  export type ProductStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductStatusWhereInput
    orderBy?: ProductStatusOrderByWithAggregationInput | ProductStatusOrderByWithAggregationInput[]
    by: ProductStatusScalarFieldEnum[] | ProductStatusScalarFieldEnum
    having?: ProductStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductStatusCountAggregateInputType | true
    _min?: ProductStatusMinAggregateInputType
    _max?: ProductStatusMaxAggregateInputType
  }

  export type ProductStatusGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: ProductStatusCountAggregateOutputType | null
    _min: ProductStatusMinAggregateOutputType | null
    _max: ProductStatusMaxAggregateOutputType | null
  }

  type GetProductStatusGroupByPayload<T extends ProductStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ProductStatusGroupByOutputType[P]>
        }
      >
    >


  export type ProductStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    products?: boolean | ProductStatus$productsArgs<ExtArgs>
    _count?: boolean | ProductStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productStatus"]>



  export type ProductStatusSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type ProductStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["productStatus"]>
  export type ProductStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductStatus$productsArgs<ExtArgs>
    _count?: boolean | ProductStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductStatus"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["productStatus"]>
    composites: {}
  }

  type ProductStatusGetPayload<S extends boolean | null | undefined | ProductStatusDefaultArgs> = $Result.GetResult<Prisma.$ProductStatusPayload, S>

  type ProductStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductStatusCountAggregateInputType | true
    }

  export interface ProductStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductStatus'], meta: { name: 'ProductStatus' } }
    /**
     * Find zero or one ProductStatus that matches the filter.
     * @param {ProductStatusFindUniqueArgs} args - Arguments to find a ProductStatus
     * @example
     * // Get one ProductStatus
     * const productStatus = await prisma.productStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductStatusFindUniqueArgs>(args: SelectSubset<T, ProductStatusFindUniqueArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductStatusFindUniqueOrThrowArgs} args - Arguments to find a ProductStatus
     * @example
     * // Get one ProductStatus
     * const productStatus = await prisma.productStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusFindFirstArgs} args - Arguments to find a ProductStatus
     * @example
     * // Get one ProductStatus
     * const productStatus = await prisma.productStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductStatusFindFirstArgs>(args?: SelectSubset<T, ProductStatusFindFirstArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusFindFirstOrThrowArgs} args - Arguments to find a ProductStatus
     * @example
     * // Get one ProductStatus
     * const productStatus = await prisma.productStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductStatuses
     * const productStatuses = await prisma.productStatus.findMany()
     * 
     * // Get first 10 ProductStatuses
     * const productStatuses = await prisma.productStatus.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const productStatusWithCodeOnly = await prisma.productStatus.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends ProductStatusFindManyArgs>(args?: SelectSubset<T, ProductStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductStatus.
     * @param {ProductStatusCreateArgs} args - Arguments to create a ProductStatus.
     * @example
     * // Create one ProductStatus
     * const ProductStatus = await prisma.productStatus.create({
     *   data: {
     *     // ... data to create a ProductStatus
     *   }
     * })
     * 
     */
    create<T extends ProductStatusCreateArgs>(args: SelectSubset<T, ProductStatusCreateArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductStatuses.
     * @param {ProductStatusCreateManyArgs} args - Arguments to create many ProductStatuses.
     * @example
     * // Create many ProductStatuses
     * const productStatus = await prisma.productStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductStatusCreateManyArgs>(args?: SelectSubset<T, ProductStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductStatus.
     * @param {ProductStatusDeleteArgs} args - Arguments to delete one ProductStatus.
     * @example
     * // Delete one ProductStatus
     * const ProductStatus = await prisma.productStatus.delete({
     *   where: {
     *     // ... filter to delete one ProductStatus
     *   }
     * })
     * 
     */
    delete<T extends ProductStatusDeleteArgs>(args: SelectSubset<T, ProductStatusDeleteArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductStatus.
     * @param {ProductStatusUpdateArgs} args - Arguments to update one ProductStatus.
     * @example
     * // Update one ProductStatus
     * const productStatus = await prisma.productStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductStatusUpdateArgs>(args: SelectSubset<T, ProductStatusUpdateArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductStatuses.
     * @param {ProductStatusDeleteManyArgs} args - Arguments to filter ProductStatuses to delete.
     * @example
     * // Delete a few ProductStatuses
     * const { count } = await prisma.productStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductStatusDeleteManyArgs>(args?: SelectSubset<T, ProductStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductStatuses
     * const productStatus = await prisma.productStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductStatusUpdateManyArgs>(args: SelectSubset<T, ProductStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductStatus.
     * @param {ProductStatusUpsertArgs} args - Arguments to update or create a ProductStatus.
     * @example
     * // Update or create a ProductStatus
     * const productStatus = await prisma.productStatus.upsert({
     *   create: {
     *     // ... data to create a ProductStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductStatus we want to update
     *   }
     * })
     */
    upsert<T extends ProductStatusUpsertArgs>(args: SelectSubset<T, ProductStatusUpsertArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusCountArgs} args - Arguments to filter ProductStatuses to count.
     * @example
     * // Count the number of ProductStatuses
     * const count = await prisma.productStatus.count({
     *   where: {
     *     // ... the filter for the ProductStatuses we want to count
     *   }
     * })
    **/
    count<T extends ProductStatusCountArgs>(
      args?: Subset<T, ProductStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductStatusAggregateArgs>(args: Subset<T, ProductStatusAggregateArgs>): Prisma.PrismaPromise<GetProductStatusAggregateType<T>>

    /**
     * Group by ProductStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductStatusGroupByArgs['orderBy'] }
        : { orderBy?: ProductStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductStatus model
   */
  readonly fields: ProductStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductStatus$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductStatus$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductStatus model
   */
  interface ProductStatusFieldRefs {
    readonly code: FieldRef<"ProductStatus", 'String'>
    readonly name: FieldRef<"ProductStatus", 'String'>
    readonly description: FieldRef<"ProductStatus", 'String'>
    readonly color: FieldRef<"ProductStatus", 'String'>
    readonly createdAt: FieldRef<"ProductStatus", 'DateTime'>
    readonly createdBy: FieldRef<"ProductStatus", 'String'>
    readonly updatedAt: FieldRef<"ProductStatus", 'DateTime'>
    readonly updatedBy: FieldRef<"ProductStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductStatus findUnique
   */
  export type ProductStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProductStatus to fetch.
     */
    where: ProductStatusWhereUniqueInput
  }

  /**
   * ProductStatus findUniqueOrThrow
   */
  export type ProductStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProductStatus to fetch.
     */
    where: ProductStatusWhereUniqueInput
  }

  /**
   * ProductStatus findFirst
   */
  export type ProductStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProductStatus to fetch.
     */
    where?: ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStatuses to fetch.
     */
    orderBy?: ProductStatusOrderByWithRelationInput | ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStatuses.
     */
    cursor?: ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStatuses.
     */
    distinct?: ProductStatusScalarFieldEnum | ProductStatusScalarFieldEnum[]
  }

  /**
   * ProductStatus findFirstOrThrow
   */
  export type ProductStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProductStatus to fetch.
     */
    where?: ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStatuses to fetch.
     */
    orderBy?: ProductStatusOrderByWithRelationInput | ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductStatuses.
     */
    cursor?: ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductStatuses.
     */
    distinct?: ProductStatusScalarFieldEnum | ProductStatusScalarFieldEnum[]
  }

  /**
   * ProductStatus findMany
   */
  export type ProductStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which ProductStatuses to fetch.
     */
    where?: ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductStatuses to fetch.
     */
    orderBy?: ProductStatusOrderByWithRelationInput | ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductStatuses.
     */
    cursor?: ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductStatuses.
     */
    skip?: number
    distinct?: ProductStatusScalarFieldEnum | ProductStatusScalarFieldEnum[]
  }

  /**
   * ProductStatus create
   */
  export type ProductStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductStatus.
     */
    data: XOR<ProductStatusCreateInput, ProductStatusUncheckedCreateInput>
  }

  /**
   * ProductStatus createMany
   */
  export type ProductStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductStatuses.
     */
    data: ProductStatusCreateManyInput | ProductStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductStatus update
   */
  export type ProductStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductStatus.
     */
    data: XOR<ProductStatusUpdateInput, ProductStatusUncheckedUpdateInput>
    /**
     * Choose, which ProductStatus to update.
     */
    where: ProductStatusWhereUniqueInput
  }

  /**
   * ProductStatus updateMany
   */
  export type ProductStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductStatuses.
     */
    data: XOR<ProductStatusUpdateManyMutationInput, ProductStatusUncheckedUpdateManyInput>
    /**
     * Filter which ProductStatuses to update
     */
    where?: ProductStatusWhereInput
    /**
     * Limit how many ProductStatuses to update.
     */
    limit?: number
  }

  /**
   * ProductStatus upsert
   */
  export type ProductStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductStatus to update in case it exists.
     */
    where: ProductStatusWhereUniqueInput
    /**
     * In case the ProductStatus found by the `where` argument doesn't exist, create a new ProductStatus with this data.
     */
    create: XOR<ProductStatusCreateInput, ProductStatusUncheckedCreateInput>
    /**
     * In case the ProductStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductStatusUpdateInput, ProductStatusUncheckedUpdateInput>
  }

  /**
   * ProductStatus delete
   */
  export type ProductStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
    /**
     * Filter which ProductStatus to delete.
     */
    where: ProductStatusWhereUniqueInput
  }

  /**
   * ProductStatus deleteMany
   */
  export type ProductStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductStatuses to delete
     */
    where?: ProductStatusWhereInput
    /**
     * Limit how many ProductStatuses to delete.
     */
    limit?: number
  }

  /**
   * ProductStatus.products
   */
  export type ProductStatus$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductStatus without action
   */
  export type ProductStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductStatus
     */
    select?: ProductStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductStatus
     */
    omit?: ProductStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductStatusInclude<ExtArgs> | null
  }


  /**
   * Model ProductType
   */

  export type AggregateProductType = {
    _count: ProductTypeCountAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  export type ProductTypeMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductTypeMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductTypeCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ProductTypeMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductTypeMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductTypeCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ProductTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductType to aggregate.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTypes
    **/
    _count?: true | ProductTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTypeMaxAggregateInputType
  }

  export type GetProductTypeAggregateType<T extends ProductTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductType[P]>
      : GetScalarType<T[P], AggregateProductType[P]>
  }




  export type ProductTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTypeWhereInput
    orderBy?: ProductTypeOrderByWithAggregationInput | ProductTypeOrderByWithAggregationInput[]
    by: ProductTypeScalarFieldEnum[] | ProductTypeScalarFieldEnum
    having?: ProductTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTypeCountAggregateInputType | true
    _min?: ProductTypeMinAggregateInputType
    _max?: ProductTypeMaxAggregateInputType
  }

  export type ProductTypeGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: ProductTypeCountAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  type GetProductTypeGroupByPayload<T extends ProductTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    products?: boolean | ProductType$productsArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productType"]>



  export type ProductTypeSelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ProductTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["productType"]>
  export type ProductTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductType$productsArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductType"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["productType"]>
    composites: {}
  }

  type ProductTypeGetPayload<S extends boolean | null | undefined | ProductTypeDefaultArgs> = $Result.GetResult<Prisma.$ProductTypePayload, S>

  type ProductTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductTypeCountAggregateInputType | true
    }

  export interface ProductTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductType'], meta: { name: 'ProductType' } }
    /**
     * Find zero or one ProductType that matches the filter.
     * @param {ProductTypeFindUniqueArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTypeFindUniqueArgs>(args: SelectSubset<T, ProductTypeFindUniqueArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTypeFindUniqueOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTypeFindFirstArgs>(args?: SelectSubset<T, ProductTypeFindFirstArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTypes
     * const productTypes = await prisma.productType.findMany()
     * 
     * // Get first 10 ProductTypes
     * const productTypes = await prisma.productType.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const productTypeWithNameOnly = await prisma.productType.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ProductTypeFindManyArgs>(args?: SelectSubset<T, ProductTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductType.
     * @param {ProductTypeCreateArgs} args - Arguments to create a ProductType.
     * @example
     * // Create one ProductType
     * const ProductType = await prisma.productType.create({
     *   data: {
     *     // ... data to create a ProductType
     *   }
     * })
     * 
     */
    create<T extends ProductTypeCreateArgs>(args: SelectSubset<T, ProductTypeCreateArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductTypes.
     * @param {ProductTypeCreateManyArgs} args - Arguments to create many ProductTypes.
     * @example
     * // Create many ProductTypes
     * const productType = await prisma.productType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTypeCreateManyArgs>(args?: SelectSubset<T, ProductTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductType.
     * @param {ProductTypeDeleteArgs} args - Arguments to delete one ProductType.
     * @example
     * // Delete one ProductType
     * const ProductType = await prisma.productType.delete({
     *   where: {
     *     // ... filter to delete one ProductType
     *   }
     * })
     * 
     */
    delete<T extends ProductTypeDeleteArgs>(args: SelectSubset<T, ProductTypeDeleteArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductType.
     * @param {ProductTypeUpdateArgs} args - Arguments to update one ProductType.
     * @example
     * // Update one ProductType
     * const productType = await prisma.productType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTypeUpdateArgs>(args: SelectSubset<T, ProductTypeUpdateArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductTypes.
     * @param {ProductTypeDeleteManyArgs} args - Arguments to filter ProductTypes to delete.
     * @example
     * // Delete a few ProductTypes
     * const { count } = await prisma.productType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTypeDeleteManyArgs>(args?: SelectSubset<T, ProductTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTypes
     * const productType = await prisma.productType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTypeUpdateManyArgs>(args: SelectSubset<T, ProductTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductType.
     * @param {ProductTypeUpsertArgs} args - Arguments to update or create a ProductType.
     * @example
     * // Update or create a ProductType
     * const productType = await prisma.productType.upsert({
     *   create: {
     *     // ... data to create a ProductType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductType we want to update
     *   }
     * })
     */
    upsert<T extends ProductTypeUpsertArgs>(args: SelectSubset<T, ProductTypeUpsertArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeCountArgs} args - Arguments to filter ProductTypes to count.
     * @example
     * // Count the number of ProductTypes
     * const count = await prisma.productType.count({
     *   where: {
     *     // ... the filter for the ProductTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductTypeCountArgs>(
      args?: Subset<T, ProductTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTypeAggregateArgs>(args: Subset<T, ProductTypeAggregateArgs>): Prisma.PrismaPromise<GetProductTypeAggregateType<T>>

    /**
     * Group by ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductType model
   */
  readonly fields: ProductTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductType$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductType$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductType model
   */
  interface ProductTypeFieldRefs {
    readonly name: FieldRef<"ProductType", 'String'>
    readonly description: FieldRef<"ProductType", 'String'>
    readonly color: FieldRef<"ProductType", 'String'>
    readonly isActive: FieldRef<"ProductType", 'Boolean'>
    readonly createdAt: FieldRef<"ProductType", 'DateTime'>
    readonly createdBy: FieldRef<"ProductType", 'String'>
    readonly updatedAt: FieldRef<"ProductType", 'DateTime'>
    readonly updatedBy: FieldRef<"ProductType", 'String'>
    readonly deletedAt: FieldRef<"ProductType", 'DateTime'>
    readonly deletedBy: FieldRef<"ProductType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductType findUnique
   */
  export type ProductTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
  }

  /**
   * ProductType findUniqueOrThrow
   */
  export type ProductTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
  }

  /**
   * ProductType findFirst
   */
  export type ProductTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
  }

  /**
   * ProductType findFirstOrThrow
   */
  export type ProductTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
  }

  /**
   * ProductType findMany
   */
  export type ProductTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypes to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
  }

  /**
   * ProductType create
   */
  export type ProductTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductType.
     */
    data: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
  }

  /**
   * ProductType createMany
   */
  export type ProductTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTypes.
     */
    data: ProductTypeCreateManyInput | ProductTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductType update
   */
  export type ProductTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductType.
     */
    data: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductType to update.
     */
    where: ProductTypeWhereUniqueInput
  }

  /**
   * ProductType updateMany
   */
  export type ProductTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTypes.
     */
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductTypes to update
     */
    where?: ProductTypeWhereInput
    /**
     * Limit how many ProductTypes to update.
     */
    limit?: number
  }

  /**
   * ProductType upsert
   */
  export type ProductTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductType to update in case it exists.
     */
    where: ProductTypeWhereUniqueInput
    /**
     * In case the ProductType found by the `where` argument doesn't exist, create a new ProductType with this data.
     */
    create: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
    /**
     * In case the ProductType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
  }

  /**
   * ProductType delete
   */
  export type ProductTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter which ProductType to delete.
     */
    where: ProductTypeWhereUniqueInput
  }

  /**
   * ProductType deleteMany
   */
  export type ProductTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTypes to delete
     */
    where?: ProductTypeWhereInput
    /**
     * Limit how many ProductTypes to delete.
     */
    limit?: number
  }

  /**
   * ProductType.products
   */
  export type ProductType$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductType without action
   */
  export type ProductTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>



  export type ProductCategorySelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ProductCategory$productsArgs<ExtArgs>
    _count?: boolean | ProductCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const productCategoryWithNameOnly = await prisma.productCategory.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends ProductCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly name: FieldRef<"ProductCategory", 'String'>
    readonly description: FieldRef<"ProductCategory", 'String'>
    readonly color: FieldRef<"ProductCategory", 'String'>
    readonly isActive: FieldRef<"ProductCategory", 'Boolean'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly createdBy: FieldRef<"ProductCategory", 'String'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedBy: FieldRef<"ProductCategory", 'String'>
    readonly deletedAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly deletedBy: FieldRef<"ProductCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory.products
   */
  export type ProductCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    offerPrice: Decimal | null
    mainImageId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    offerPrice: Decimal | null
    mainImageId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    offerPrice: Decimal | null
    productTypeName: string | null
    productCategoryName: string | null
    brandName: string | null
    productStatusCode: string | null
    mainImageId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: Decimal | null
    offerPrice: Decimal | null
    productTypeName: string | null
    productCategoryName: string | null
    brandName: string | null
    productStatusCode: string | null
    mainImageId: number | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    offerPrice: number
    productTypeName: number
    productCategoryName: number
    brandName: number
    productStatusCode: number
    mainImageId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    mainImageId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    offerPrice?: true
    mainImageId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    offerPrice?: true
    productTypeName?: true
    productCategoryName?: true
    brandName?: true
    productStatusCode?: true
    mainImageId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    offerPrice?: true
    productTypeName?: true
    productCategoryName?: true
    brandName?: true
    productStatusCode?: true
    mainImageId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    offerPrice?: true
    productTypeName?: true
    productCategoryName?: true
    brandName?: true
    productStatusCode?: true
    mainImageId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string | null
    price: Decimal
    offerPrice: Decimal | null
    productTypeName: string
    productCategoryName: string
    brandName: string | null
    productStatusCode: string
    mainImageId: number | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    offerPrice?: boolean
    productTypeName?: boolean
    productCategoryName?: boolean
    brandName?: boolean
    productStatusCode?: boolean
    mainImageId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
    productCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    productStatus?: boolean | ProductStatusDefaultArgs<ExtArgs>
    inventories?: boolean | Product$inventoriesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>



  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    offerPrice?: boolean
    productTypeName?: boolean
    productCategoryName?: boolean
    brandName?: boolean
    productStatusCode?: boolean
    mainImageId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "offerPrice" | "productTypeName" | "productCategoryName" | "brandName" | "productStatusCode" | "mainImageId" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
    productCategory?: boolean | ProductCategoryDefaultArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    productStatus?: boolean | ProductStatusDefaultArgs<ExtArgs>
    inventories?: boolean | Product$inventoriesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      productType: Prisma.$ProductTypePayload<ExtArgs>
      productCategory: Prisma.$ProductCategoryPayload<ExtArgs>
      brand: Prisma.$BrandPayload<ExtArgs> | null
      productStatus: Prisma.$ProductStatusPayload<ExtArgs>
      inventories: Prisma.$InventoryPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      price: Prisma.Decimal
      offerPrice: Prisma.Decimal | null
      productTypeName: string
      productCategoryName: string
      brandName: string | null
      productStatusCode: string
      mainImageId: number | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productType<T extends ProductTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeDefaultArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productCategory<T extends ProductCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCategoryDefaultArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brand<T extends Product$brandArgs<ExtArgs> = {}>(args?: Subset<T, Product$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productStatus<T extends ProductStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductStatusDefaultArgs<ExtArgs>>): Prisma__ProductStatusClient<$Result.GetResult<Prisma.$ProductStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventories<T extends Product$inventoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly offerPrice: FieldRef<"Product", 'Decimal'>
    readonly productTypeName: FieldRef<"Product", 'String'>
    readonly productCategoryName: FieldRef<"Product", 'String'>
    readonly brandName: FieldRef<"Product", 'String'>
    readonly productStatusCode: FieldRef<"Product", 'String'>
    readonly mainImageId: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly createdBy: FieldRef<"Product", 'String'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly updatedBy: FieldRef<"Product", 'String'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedBy: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.brand
   */
  export type Product$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * Product.inventories
   */
  export type Product$inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatus
   */

  export type AggregateOrderStatus = {
    _count: OrderStatusCountAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  export type OrderStatusMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrderStatusMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrderStatusCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type OrderStatusMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrderStatusMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrderStatusCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type OrderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatus to aggregate.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatuses
    **/
    _count?: true | OrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusMaxAggregateInputType
  }

  export type GetOrderStatusAggregateType<T extends OrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatus[P]>
      : GetScalarType<T[P], AggregateOrderStatus[P]>
  }




  export type OrderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusWhereInput
    orderBy?: OrderStatusOrderByWithAggregationInput | OrderStatusOrderByWithAggregationInput[]
    by: OrderStatusScalarFieldEnum[] | OrderStatusScalarFieldEnum
    having?: OrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusCountAggregateInputType | true
    _min?: OrderStatusMinAggregateInputType
    _max?: OrderStatusMaxAggregateInputType
  }

  export type OrderStatusGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: OrderStatusCountAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  type GetOrderStatusGroupByPayload<T extends OrderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatus"]>



  export type OrderStatusSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type OrderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["orderStatus"]>
  export type OrderStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatus"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["orderStatus"]>
    composites: {}
  }

  type OrderStatusGetPayload<S extends boolean | null | undefined | OrderStatusDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusPayload, S>

  type OrderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStatusCountAggregateInputType | true
    }

  export interface OrderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatus'], meta: { name: 'OrderStatus' } }
    /**
     * Find zero or one OrderStatus that matches the filter.
     * @param {OrderStatusFindUniqueArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusFindUniqueArgs>(args: SelectSubset<T, OrderStatusFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusFindFirstArgs>(args?: SelectSubset<T, OrderStatusFindFirstArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany()
     * 
     * // Get first 10 OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const orderStatusWithCodeOnly = await prisma.orderStatus.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends OrderStatusFindManyArgs>(args?: SelectSubset<T, OrderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStatus.
     * @param {OrderStatusCreateArgs} args - Arguments to create a OrderStatus.
     * @example
     * // Create one OrderStatus
     * const OrderStatus = await prisma.orderStatus.create({
     *   data: {
     *     // ... data to create a OrderStatus
     *   }
     * })
     * 
     */
    create<T extends OrderStatusCreateArgs>(args: SelectSubset<T, OrderStatusCreateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderStatuses.
     * @param {OrderStatusCreateManyArgs} args - Arguments to create many OrderStatuses.
     * @example
     * // Create many OrderStatuses
     * const orderStatus = await prisma.orderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusCreateManyArgs>(args?: SelectSubset<T, OrderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderStatus.
     * @param {OrderStatusDeleteArgs} args - Arguments to delete one OrderStatus.
     * @example
     * // Delete one OrderStatus
     * const OrderStatus = await prisma.orderStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderStatus
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusDeleteArgs>(args: SelectSubset<T, OrderStatusDeleteArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStatus.
     * @param {OrderStatusUpdateArgs} args - Arguments to update one OrderStatus.
     * @example
     * // Update one OrderStatus
     * const orderStatus = await prisma.orderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusUpdateArgs>(args: SelectSubset<T, OrderStatusUpdateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderStatuses.
     * @param {OrderStatusDeleteManyArgs} args - Arguments to filter OrderStatuses to delete.
     * @example
     * // Delete a few OrderStatuses
     * const { count } = await prisma.orderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusDeleteManyArgs>(args?: SelectSubset<T, OrderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusUpdateManyArgs>(args: SelectSubset<T, OrderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderStatus.
     * @param {OrderStatusUpsertArgs} args - Arguments to update or create a OrderStatus.
     * @example
     * // Update or create a OrderStatus
     * const orderStatus = await prisma.orderStatus.upsert({
     *   create: {
     *     // ... data to create a OrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatus we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusUpsertArgs>(args: SelectSubset<T, OrderStatusUpsertArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusCountArgs} args - Arguments to filter OrderStatuses to count.
     * @example
     * // Count the number of OrderStatuses
     * const count = await prisma.orderStatus.count({
     *   where: {
     *     // ... the filter for the OrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusCountArgs>(
      args?: Subset<T, OrderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusAggregateArgs>(args: Subset<T, OrderStatusAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusAggregateType<T>>

    /**
     * Group by OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatus model
   */
  readonly fields: OrderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends OrderStatus$ordersArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatus$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatus model
   */
  interface OrderStatusFieldRefs {
    readonly code: FieldRef<"OrderStatus", 'String'>
    readonly name: FieldRef<"OrderStatus", 'String'>
    readonly description: FieldRef<"OrderStatus", 'String'>
    readonly color: FieldRef<"OrderStatus", 'String'>
    readonly createdAt: FieldRef<"OrderStatus", 'DateTime'>
    readonly createdBy: FieldRef<"OrderStatus", 'String'>
    readonly updatedAt: FieldRef<"OrderStatus", 'DateTime'>
    readonly updatedBy: FieldRef<"OrderStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatus findUnique
   */
  export type OrderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findUniqueOrThrow
   */
  export type OrderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findFirst
   */
  export type OrderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findFirstOrThrow
   */
  export type OrderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findMany
   */
  export type OrderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatuses to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus create
   */
  export type OrderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatus.
     */
    data: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
  }

  /**
   * OrderStatus createMany
   */
  export type OrderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatuses.
     */
    data: OrderStatusCreateManyInput | OrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatus update
   */
  export type OrderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatus.
     */
    data: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderStatus to update.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus updateMany
   */
  export type OrderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatuses.
     */
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderStatus upsert
   */
  export type OrderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatus to update in case it exists.
     */
    where: OrderStatusWhereUniqueInput
    /**
     * In case the OrderStatus found by the `where` argument doesn't exist, create a new OrderStatus with this data.
     */
    create: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
    /**
     * In case the OrderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
  }

  /**
   * OrderStatus delete
   */
  export type OrderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter which OrderStatus to delete.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus deleteMany
   */
  export type OrderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatuses to delete
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to delete.
     */
    limit?: number
  }

  /**
   * OrderStatus.orders
   */
  export type OrderStatus$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderStatus without action
   */
  export type OrderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
  }


  /**
   * Model OrderItemStatus
   */

  export type AggregateOrderItemStatus = {
    _count: OrderItemStatusCountAggregateOutputType | null
    _min: OrderItemStatusMinAggregateOutputType | null
    _max: OrderItemStatusMaxAggregateOutputType | null
  }

  export type OrderItemStatusMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrderItemStatusMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type OrderItemStatusCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type OrderItemStatusMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrderItemStatusMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type OrderItemStatusCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type OrderItemStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemStatus to aggregate.
     */
    where?: OrderItemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemStatuses to fetch.
     */
    orderBy?: OrderItemStatusOrderByWithRelationInput | OrderItemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItemStatuses
    **/
    _count?: true | OrderItemStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemStatusMaxAggregateInputType
  }

  export type GetOrderItemStatusAggregateType<T extends OrderItemStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItemStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItemStatus[P]>
      : GetScalarType<T[P], AggregateOrderItemStatus[P]>
  }




  export type OrderItemStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemStatusWhereInput
    orderBy?: OrderItemStatusOrderByWithAggregationInput | OrderItemStatusOrderByWithAggregationInput[]
    by: OrderItemStatusScalarFieldEnum[] | OrderItemStatusScalarFieldEnum
    having?: OrderItemStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemStatusCountAggregateInputType | true
    _min?: OrderItemStatusMinAggregateInputType
    _max?: OrderItemStatusMaxAggregateInputType
  }

  export type OrderItemStatusGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: OrderItemStatusCountAggregateOutputType | null
    _min: OrderItemStatusMinAggregateOutputType | null
    _max: OrderItemStatusMaxAggregateOutputType | null
  }

  type GetOrderItemStatusGroupByPayload<T extends OrderItemStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    orderItems?: boolean | OrderItemStatus$orderItemsArgs<ExtArgs>
    _count?: boolean | OrderItemStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItemStatus"]>



  export type OrderItemStatusSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type OrderItemStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["orderItemStatus"]>
  export type OrderItemStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderItemStatus$orderItemsArgs<ExtArgs>
    _count?: boolean | OrderItemStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderItemStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItemStatus"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["orderItemStatus"]>
    composites: {}
  }

  type OrderItemStatusGetPayload<S extends boolean | null | undefined | OrderItemStatusDefaultArgs> = $Result.GetResult<Prisma.$OrderItemStatusPayload, S>

  type OrderItemStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemStatusCountAggregateInputType | true
    }

  export interface OrderItemStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItemStatus'], meta: { name: 'OrderItemStatus' } }
    /**
     * Find zero or one OrderItemStatus that matches the filter.
     * @param {OrderItemStatusFindUniqueArgs} args - Arguments to find a OrderItemStatus
     * @example
     * // Get one OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemStatusFindUniqueArgs>(args: SelectSubset<T, OrderItemStatusFindUniqueArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItemStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderItemStatus
     * @example
     * // Get one OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusFindFirstArgs} args - Arguments to find a OrderItemStatus
     * @example
     * // Get one OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemStatusFindFirstArgs>(args?: SelectSubset<T, OrderItemStatusFindFirstArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItemStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusFindFirstOrThrowArgs} args - Arguments to find a OrderItemStatus
     * @example
     * // Get one OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItemStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItemStatuses
     * const orderItemStatuses = await prisma.orderItemStatus.findMany()
     * 
     * // Get first 10 OrderItemStatuses
     * const orderItemStatuses = await prisma.orderItemStatus.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const orderItemStatusWithCodeOnly = await prisma.orderItemStatus.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends OrderItemStatusFindManyArgs>(args?: SelectSubset<T, OrderItemStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItemStatus.
     * @param {OrderItemStatusCreateArgs} args - Arguments to create a OrderItemStatus.
     * @example
     * // Create one OrderItemStatus
     * const OrderItemStatus = await prisma.orderItemStatus.create({
     *   data: {
     *     // ... data to create a OrderItemStatus
     *   }
     * })
     * 
     */
    create<T extends OrderItemStatusCreateArgs>(args: SelectSubset<T, OrderItemStatusCreateArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItemStatuses.
     * @param {OrderItemStatusCreateManyArgs} args - Arguments to create many OrderItemStatuses.
     * @example
     * // Create many OrderItemStatuses
     * const orderItemStatus = await prisma.orderItemStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemStatusCreateManyArgs>(args?: SelectSubset<T, OrderItemStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItemStatus.
     * @param {OrderItemStatusDeleteArgs} args - Arguments to delete one OrderItemStatus.
     * @example
     * // Delete one OrderItemStatus
     * const OrderItemStatus = await prisma.orderItemStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderItemStatus
     *   }
     * })
     * 
     */
    delete<T extends OrderItemStatusDeleteArgs>(args: SelectSubset<T, OrderItemStatusDeleteArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItemStatus.
     * @param {OrderItemStatusUpdateArgs} args - Arguments to update one OrderItemStatus.
     * @example
     * // Update one OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemStatusUpdateArgs>(args: SelectSubset<T, OrderItemStatusUpdateArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItemStatuses.
     * @param {OrderItemStatusDeleteManyArgs} args - Arguments to filter OrderItemStatuses to delete.
     * @example
     * // Delete a few OrderItemStatuses
     * const { count } = await prisma.orderItemStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemStatusDeleteManyArgs>(args?: SelectSubset<T, OrderItemStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItemStatuses
     * const orderItemStatus = await prisma.orderItemStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemStatusUpdateManyArgs>(args: SelectSubset<T, OrderItemStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItemStatus.
     * @param {OrderItemStatusUpsertArgs} args - Arguments to update or create a OrderItemStatus.
     * @example
     * // Update or create a OrderItemStatus
     * const orderItemStatus = await prisma.orderItemStatus.upsert({
     *   create: {
     *     // ... data to create a OrderItemStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItemStatus we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemStatusUpsertArgs>(args: SelectSubset<T, OrderItemStatusUpsertArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusCountArgs} args - Arguments to filter OrderItemStatuses to count.
     * @example
     * // Count the number of OrderItemStatuses
     * const count = await prisma.orderItemStatus.count({
     *   where: {
     *     // ... the filter for the OrderItemStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderItemStatusCountArgs>(
      args?: Subset<T, OrderItemStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemStatusAggregateArgs>(args: Subset<T, OrderItemStatusAggregateArgs>): Prisma.PrismaPromise<GetOrderItemStatusAggregateType<T>>

    /**
     * Group by OrderItemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItemStatus model
   */
  readonly fields: OrderItemStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItemStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends OrderItemStatus$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemStatus$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItemStatus model
   */
  interface OrderItemStatusFieldRefs {
    readonly code: FieldRef<"OrderItemStatus", 'String'>
    readonly name: FieldRef<"OrderItemStatus", 'String'>
    readonly description: FieldRef<"OrderItemStatus", 'String'>
    readonly color: FieldRef<"OrderItemStatus", 'String'>
    readonly createdAt: FieldRef<"OrderItemStatus", 'DateTime'>
    readonly createdBy: FieldRef<"OrderItemStatus", 'String'>
    readonly updatedAt: FieldRef<"OrderItemStatus", 'DateTime'>
    readonly updatedBy: FieldRef<"OrderItemStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItemStatus findUnique
   */
  export type OrderItemStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemStatus to fetch.
     */
    where: OrderItemStatusWhereUniqueInput
  }

  /**
   * OrderItemStatus findUniqueOrThrow
   */
  export type OrderItemStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemStatus to fetch.
     */
    where: OrderItemStatusWhereUniqueInput
  }

  /**
   * OrderItemStatus findFirst
   */
  export type OrderItemStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemStatus to fetch.
     */
    where?: OrderItemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemStatuses to fetch.
     */
    orderBy?: OrderItemStatusOrderByWithRelationInput | OrderItemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemStatuses.
     */
    cursor?: OrderItemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemStatuses.
     */
    distinct?: OrderItemStatusScalarFieldEnum | OrderItemStatusScalarFieldEnum[]
  }

  /**
   * OrderItemStatus findFirstOrThrow
   */
  export type OrderItemStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemStatus to fetch.
     */
    where?: OrderItemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemStatuses to fetch.
     */
    orderBy?: OrderItemStatusOrderByWithRelationInput | OrderItemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItemStatuses.
     */
    cursor?: OrderItemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItemStatuses.
     */
    distinct?: OrderItemStatusScalarFieldEnum | OrderItemStatusScalarFieldEnum[]
  }

  /**
   * OrderItemStatus findMany
   */
  export type OrderItemStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderItemStatuses to fetch.
     */
    where?: OrderItemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItemStatuses to fetch.
     */
    orderBy?: OrderItemStatusOrderByWithRelationInput | OrderItemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItemStatuses.
     */
    cursor?: OrderItemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItemStatuses.
     */
    skip?: number
    distinct?: OrderItemStatusScalarFieldEnum | OrderItemStatusScalarFieldEnum[]
  }

  /**
   * OrderItemStatus create
   */
  export type OrderItemStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItemStatus.
     */
    data: XOR<OrderItemStatusCreateInput, OrderItemStatusUncheckedCreateInput>
  }

  /**
   * OrderItemStatus createMany
   */
  export type OrderItemStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItemStatuses.
     */
    data: OrderItemStatusCreateManyInput | OrderItemStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItemStatus update
   */
  export type OrderItemStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItemStatus.
     */
    data: XOR<OrderItemStatusUpdateInput, OrderItemStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderItemStatus to update.
     */
    where: OrderItemStatusWhereUniqueInput
  }

  /**
   * OrderItemStatus updateMany
   */
  export type OrderItemStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItemStatuses.
     */
    data: XOR<OrderItemStatusUpdateManyMutationInput, OrderItemStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderItemStatuses to update
     */
    where?: OrderItemStatusWhereInput
    /**
     * Limit how many OrderItemStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderItemStatus upsert
   */
  export type OrderItemStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItemStatus to update in case it exists.
     */
    where: OrderItemStatusWhereUniqueInput
    /**
     * In case the OrderItemStatus found by the `where` argument doesn't exist, create a new OrderItemStatus with this data.
     */
    create: XOR<OrderItemStatusCreateInput, OrderItemStatusUncheckedCreateInput>
    /**
     * In case the OrderItemStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemStatusUpdateInput, OrderItemStatusUncheckedUpdateInput>
  }

  /**
   * OrderItemStatus delete
   */
  export type OrderItemStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
    /**
     * Filter which OrderItemStatus to delete.
     */
    where: OrderItemStatusWhereUniqueInput
  }

  /**
   * OrderItemStatus deleteMany
   */
  export type OrderItemStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItemStatuses to delete
     */
    where?: OrderItemStatusWhereInput
    /**
     * Limit how many OrderItemStatuses to delete.
     */
    limit?: number
  }

  /**
   * OrderItemStatus.orderItems
   */
  export type OrderItemStatus$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItemStatus without action
   */
  export type OrderItemStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemStatus
     */
    select?: OrderItemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItemStatus
     */
    omit?: OrderItemStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemStatusInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    tableSessionId: number | null
    subtotalAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    tableSessionId: number | null
    subtotalAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    code: string | null
    tableSessionId: number | null
    creatorUserDocument: string | null
    createdAt: Date | null
    customerDocumentNumber: string | null
    subtotalAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
    statusCode: string | null
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type OrderMaxAggregateOutputType = {
    code: string | null
    tableSessionId: number | null
    creatorUserDocument: string | null
    createdAt: Date | null
    customerDocumentNumber: string | null
    subtotalAmount: Decimal | null
    taxAmount: Decimal | null
    totalAmount: Decimal | null
    statusCode: string | null
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type OrderCountAggregateOutputType = {
    code: number
    tableSessionId: number
    creatorUserDocument: number
    createdAt: number
    customerDocumentNumber: number
    subtotalAmount: number
    taxAmount: number
    totalAmount: number
    statusCode: number
    closerUserDocument: number
    closedAt: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    tableSessionId?: true
    subtotalAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    tableSessionId?: true
    subtotalAmount?: true
    taxAmount?: true
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    code?: true
    tableSessionId?: true
    creatorUserDocument?: true
    createdAt?: true
    customerDocumentNumber?: true
    subtotalAmount?: true
    taxAmount?: true
    totalAmount?: true
    statusCode?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type OrderMaxAggregateInputType = {
    code?: true
    tableSessionId?: true
    creatorUserDocument?: true
    createdAt?: true
    customerDocumentNumber?: true
    subtotalAmount?: true
    taxAmount?: true
    totalAmount?: true
    statusCode?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type OrderCountAggregateInputType = {
    code?: true
    tableSessionId?: true
    creatorUserDocument?: true
    createdAt?: true
    customerDocumentNumber?: true
    subtotalAmount?: true
    taxAmount?: true
    totalAmount?: true
    statusCode?: true
    closerUserDocument?: true
    closedAt?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    code: string
    tableSessionId: number | null
    creatorUserDocument: string
    createdAt: Date | null
    customerDocumentNumber: string
    subtotalAmount: Decimal
    taxAmount: Decimal
    totalAmount: Decimal
    statusCode: string
    closerUserDocument: string | null
    closedAt: Date | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    tableSessionId?: boolean
    creatorUserDocument?: boolean
    createdAt?: boolean
    customerDocumentNumber?: boolean
    subtotalAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    statusCode?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    tableSession?: boolean | Order$tableSessionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    closer?: boolean | Order$closerArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>



  export type OrderSelectScalar = {
    code?: boolean
    tableSessionId?: boolean
    creatorUserDocument?: boolean
    createdAt?: boolean
    customerDocumentNumber?: boolean
    subtotalAmount?: boolean
    taxAmount?: boolean
    totalAmount?: boolean
    statusCode?: boolean
    closerUserDocument?: boolean
    closedAt?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "tableSessionId" | "creatorUserDocument" | "createdAt" | "customerDocumentNumber" | "subtotalAmount" | "taxAmount" | "totalAmount" | "statusCode" | "closerUserDocument" | "closedAt" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tableSession?: boolean | Order$tableSessionArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    closer?: boolean | Order$closerArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      tableSession: Prisma.$TableSessionPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      status: Prisma.$OrderStatusPayload<ExtArgs>
      closer: Prisma.$UserPayload<ExtArgs> | null
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      tableSessionId: number | null
      creatorUserDocument: string
      createdAt: Date | null
      customerDocumentNumber: string
      subtotalAmount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      statusCode: string
      closerUserDocument: string | null
      closedAt: Date | null
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const orderWithCodeOnly = await prisma.order.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tableSession<T extends Order$tableSessionArgs<ExtArgs> = {}>(args?: Subset<T, Order$tableSessionArgs<ExtArgs>>): Prisma__TableSessionClient<$Result.GetResult<Prisma.$TableSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends OrderStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatusDefaultArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    closer<T extends Order$closerArgs<ExtArgs> = {}>(args?: Subset<T, Order$closerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly code: FieldRef<"Order", 'String'>
    readonly tableSessionId: FieldRef<"Order", 'Int'>
    readonly creatorUserDocument: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly customerDocumentNumber: FieldRef<"Order", 'String'>
    readonly subtotalAmount: FieldRef<"Order", 'Decimal'>
    readonly taxAmount: FieldRef<"Order", 'Decimal'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly statusCode: FieldRef<"Order", 'String'>
    readonly closerUserDocument: FieldRef<"Order", 'String'>
    readonly closedAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly updatedBy: FieldRef<"Order", 'String'>
    readonly deletedAt: FieldRef<"Order", 'DateTime'>
    readonly deletedBy: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.tableSession
   */
  export type Order$tableSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableSession
     */
    select?: TableSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableSession
     */
    omit?: TableSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableSessionInclude<ExtArgs> | null
    where?: TableSessionWhereInput
  }

  /**
   * Order.closer
   */
  export type Order$closerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.payment
   */
  export type Order$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    subTotal: Decimal | null
    discount: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    subTotal: Decimal | null
    discount: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderCode: string | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    subTotal: Decimal | null
    discount: Decimal | null
    statusCode: string | null
    specialInstructions: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderCode: string | null
    productId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    subTotal: Decimal | null
    discount: Decimal | null
    statusCode: string | null
    specialInstructions: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderCode: number
    productId: number
    quantity: number
    unitPrice: number
    subTotal: number
    discount: number
    statusCode: number
    specialInstructions: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subTotal?: true
    discount?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subTotal?: true
    discount?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderCode?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subTotal?: true
    discount?: true
    statusCode?: true
    specialInstructions?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderCode?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subTotal?: true
    discount?: true
    statusCode?: true
    specialInstructions?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderCode?: true
    productId?: true
    quantity?: true
    unitPrice?: true
    subTotal?: true
    discount?: true
    statusCode?: true
    specialInstructions?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderCode: string
    productId: number
    quantity: number
    unitPrice: Decimal
    subTotal: Decimal
    discount: Decimal
    statusCode: string
    specialInstructions: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderCode?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    discount?: boolean
    statusCode?: boolean
    specialInstructions?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    status?: boolean | OrderItemStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>



  export type OrderItemSelectScalar = {
    id?: boolean
    orderCode?: boolean
    productId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subTotal?: boolean
    discount?: boolean
    statusCode?: boolean
    specialInstructions?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderCode" | "productId" | "quantity" | "unitPrice" | "subTotal" | "discount" | "statusCode" | "specialInstructions" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    status?: boolean | OrderItemStatusDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      status: Prisma.$OrderItemStatusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderCode: string
      productId: number
      quantity: number
      unitPrice: Prisma.Decimal
      subTotal: Prisma.Decimal
      discount: Prisma.Decimal
      statusCode: string
      specialInstructions: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends OrderItemStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemStatusDefaultArgs<ExtArgs>>): Prisma__OrderItemStatusClient<$Result.GetResult<Prisma.$OrderItemStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderCode: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly subTotal: FieldRef<"OrderItem", 'Decimal'>
    readonly discount: FieldRef<"OrderItem", 'Decimal'>
    readonly statusCode: FieldRef<"OrderItem", 'String'>
    readonly specialInstructions: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly createdBy: FieldRef<"OrderItem", 'String'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedBy: FieldRef<"OrderItem", 'String'>
    readonly deletedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly deletedBy: FieldRef<"OrderItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    name: string | null
    description: string | null
    color: string | null
    isActive: boolean | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    name: number
    description: number
    color: number
    isActive: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    name?: true
    description?: true
    color?: true
    isActive?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    name: string
    description: string | null
    color: string | null
    isActive: boolean
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>



  export type PaymentMethodSelectScalar = {
    name?: boolean
    description?: boolean
    color?: boolean
    isActive?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "color" | "isActive" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PaymentMethod$paymentsArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string | null
      color: string | null
      isActive: boolean
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const paymentMethodWithNameOnly = await prisma.paymentMethod.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends PaymentMethod$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly name: FieldRef<"PaymentMethod", 'String'>
    readonly description: FieldRef<"PaymentMethod", 'String'>
    readonly color: FieldRef<"PaymentMethod", 'String'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly createdBy: FieldRef<"PaymentMethod", 'String'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedBy: FieldRef<"PaymentMethod", 'String'>
    readonly deletedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly deletedBy: FieldRef<"PaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.payments
   */
  export type PaymentMethod$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    cashBoxId: number | null
    totalAmount: Decimal | null
    receivedAmount: Decimal | null
    changeAmount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    cashBoxId: number | null
    totalAmount: Decimal | null
    receivedAmount: Decimal | null
    changeAmount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    orderCode: string | null
    cashBoxId: number | null
    totalAmount: Decimal | null
    paymentMethodName: string | null
    receivedAmount: Decimal | null
    changeAmount: Decimal | null
    transactionNumber: string | null
    notes: string | null
    receiveUserDocument: string | null
    paidCustomerDocument: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    orderCode: string | null
    cashBoxId: number | null
    totalAmount: Decimal | null
    paymentMethodName: string | null
    receivedAmount: Decimal | null
    changeAmount: Decimal | null
    transactionNumber: string | null
    notes: string | null
    receiveUserDocument: string | null
    paidCustomerDocument: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderCode: number
    cashBoxId: number
    totalAmount: number
    paymentMethodName: number
    receivedAmount: number
    changeAmount: number
    transactionNumber: number
    notes: number
    receiveUserDocument: number
    paidCustomerDocument: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    cashBoxId?: true
    totalAmount?: true
    receivedAmount?: true
    changeAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    cashBoxId?: true
    totalAmount?: true
    receivedAmount?: true
    changeAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderCode?: true
    cashBoxId?: true
    totalAmount?: true
    paymentMethodName?: true
    receivedAmount?: true
    changeAmount?: true
    transactionNumber?: true
    notes?: true
    receiveUserDocument?: true
    paidCustomerDocument?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderCode?: true
    cashBoxId?: true
    totalAmount?: true
    paymentMethodName?: true
    receivedAmount?: true
    changeAmount?: true
    transactionNumber?: true
    notes?: true
    receiveUserDocument?: true
    paidCustomerDocument?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderCode?: true
    cashBoxId?: true
    totalAmount?: true
    paymentMethodName?: true
    receivedAmount?: true
    changeAmount?: true
    transactionNumber?: true
    notes?: true
    receiveUserDocument?: true
    paidCustomerDocument?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal
    paymentMethodName: string
    receivedAmount: Decimal | null
    changeAmount: Decimal | null
    transactionNumber: string | null
    notes: string | null
    receiveUserDocument: string
    paidCustomerDocument: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderCode?: boolean
    cashBoxId?: boolean
    totalAmount?: boolean
    paymentMethodName?: boolean
    receivedAmount?: boolean
    changeAmount?: boolean
    transactionNumber?: boolean
    notes?: boolean
    receiveUserDocument?: boolean
    paidCustomerDocument?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    cashBox?: boolean | CashBoxDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    receiveUser?: boolean | UserDefaultArgs<ExtArgs>
    paidCustomer?: boolean | Payment$paidCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    id?: boolean
    orderCode?: boolean
    cashBoxId?: boolean
    totalAmount?: boolean
    paymentMethodName?: boolean
    receivedAmount?: boolean
    changeAmount?: boolean
    transactionNumber?: boolean
    notes?: boolean
    receiveUserDocument?: boolean
    paidCustomerDocument?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderCode" | "cashBoxId" | "totalAmount" | "paymentMethodName" | "receivedAmount" | "changeAmount" | "transactionNumber" | "notes" | "receiveUserDocument" | "paidCustomerDocument" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    cashBox?: boolean | CashBoxDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    receiveUser?: boolean | UserDefaultArgs<ExtArgs>
    paidCustomer?: boolean | Payment$paidCustomerArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      cashBox: Prisma.$CashBoxPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
      receiveUser: Prisma.$UserPayload<ExtArgs>
      paidCustomer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderCode: string
      cashBoxId: number
      totalAmount: Prisma.Decimal
      paymentMethodName: string
      receivedAmount: Prisma.Decimal | null
      changeAmount: Prisma.Decimal | null
      transactionNumber: string | null
      notes: string | null
      receiveUserDocument: string
      paidCustomerDocument: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cashBox<T extends CashBoxDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CashBoxDefaultArgs<ExtArgs>>): Prisma__CashBoxClient<$Result.GetResult<Prisma.$CashBoxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiveUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paidCustomer<T extends Payment$paidCustomerArgs<ExtArgs> = {}>(args?: Subset<T, Payment$paidCustomerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly orderCode: FieldRef<"Payment", 'String'>
    readonly cashBoxId: FieldRef<"Payment", 'Int'>
    readonly totalAmount: FieldRef<"Payment", 'Decimal'>
    readonly paymentMethodName: FieldRef<"Payment", 'String'>
    readonly receivedAmount: FieldRef<"Payment", 'Decimal'>
    readonly changeAmount: FieldRef<"Payment", 'Decimal'>
    readonly transactionNumber: FieldRef<"Payment", 'String'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly receiveUserDocument: FieldRef<"Payment", 'String'>
    readonly paidCustomerDocument: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly createdBy: FieldRef<"Payment", 'String'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedBy: FieldRef<"Payment", 'String'>
    readonly deletedAt: FieldRef<"Payment", 'DateTime'>
    readonly deletedBy: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.paidCustomer
   */
  export type Payment$paidCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovementType
   */

  export type AggregateInventoryMovementType = {
    _count: InventoryMovementTypeCountAggregateOutputType | null
    _min: InventoryMovementTypeMinAggregateOutputType | null
    _max: InventoryMovementTypeMaxAggregateOutputType | null
  }

  export type InventoryMovementTypeMinAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type InventoryMovementTypeMaxAggregateOutputType = {
    code: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type InventoryMovementTypeCountAggregateOutputType = {
    code: number
    name: number
    description: number
    color: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type InventoryMovementTypeMinAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InventoryMovementTypeMaxAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type InventoryMovementTypeCountAggregateInputType = {
    code?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type InventoryMovementTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovementType to aggregate.
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovementTypes to fetch.
     */
    orderBy?: InventoryMovementTypeOrderByWithRelationInput | InventoryMovementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovementTypes
    **/
    _count?: true | InventoryMovementTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementTypeMaxAggregateInputType
  }

  export type GetInventoryMovementTypeAggregateType<T extends InventoryMovementTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovementType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovementType[P]>
      : GetScalarType<T[P], AggregateInventoryMovementType[P]>
  }




  export type InventoryMovementTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementTypeWhereInput
    orderBy?: InventoryMovementTypeOrderByWithAggregationInput | InventoryMovementTypeOrderByWithAggregationInput[]
    by: InventoryMovementTypeScalarFieldEnum[] | InventoryMovementTypeScalarFieldEnum
    having?: InventoryMovementTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementTypeCountAggregateInputType | true
    _min?: InventoryMovementTypeMinAggregateInputType
    _max?: InventoryMovementTypeMaxAggregateInputType
  }

  export type InventoryMovementTypeGroupByOutputType = {
    code: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    _count: InventoryMovementTypeCountAggregateOutputType | null
    _min: InventoryMovementTypeMinAggregateOutputType | null
    _max: InventoryMovementTypeMaxAggregateOutputType | null
  }

  type GetInventoryMovementTypeGroupByPayload<T extends InventoryMovementTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementTypeGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementTypeGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    movements?: boolean | InventoryMovementType$movementsArgs<ExtArgs>
    _count?: boolean | InventoryMovementTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovementType"]>



  export type InventoryMovementTypeSelectScalar = {
    code?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }

  export type InventoryMovementTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"code" | "name" | "description" | "color" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy", ExtArgs["result"]["inventoryMovementType"]>
  export type InventoryMovementTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movements?: boolean | InventoryMovementType$movementsArgs<ExtArgs>
    _count?: boolean | InventoryMovementTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovementType"
    objects: {
      movements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
    }, ExtArgs["result"]["inventoryMovementType"]>
    composites: {}
  }

  type InventoryMovementTypeGetPayload<S extends boolean | null | undefined | InventoryMovementTypeDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementTypePayload, S>

  type InventoryMovementTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementTypeCountAggregateInputType | true
    }

  export interface InventoryMovementTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovementType'], meta: { name: 'InventoryMovementType' } }
    /**
     * Find zero or one InventoryMovementType that matches the filter.
     * @param {InventoryMovementTypeFindUniqueArgs} args - Arguments to find a InventoryMovementType
     * @example
     * // Get one InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementTypeFindUniqueArgs>(args: SelectSubset<T, InventoryMovementTypeFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovementType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementTypeFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovementType
     * @example
     * // Get one InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovementType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeFindFirstArgs} args - Arguments to find a InventoryMovementType
     * @example
     * // Get one InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementTypeFindFirstArgs>(args?: SelectSubset<T, InventoryMovementTypeFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovementType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeFindFirstOrThrowArgs} args - Arguments to find a InventoryMovementType
     * @example
     * // Get one InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovementTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovementTypes
     * const inventoryMovementTypes = await prisma.inventoryMovementType.findMany()
     * 
     * // Get first 10 InventoryMovementTypes
     * const inventoryMovementTypes = await prisma.inventoryMovementType.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const inventoryMovementTypeWithCodeOnly = await prisma.inventoryMovementType.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends InventoryMovementTypeFindManyArgs>(args?: SelectSubset<T, InventoryMovementTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovementType.
     * @param {InventoryMovementTypeCreateArgs} args - Arguments to create a InventoryMovementType.
     * @example
     * // Create one InventoryMovementType
     * const InventoryMovementType = await prisma.inventoryMovementType.create({
     *   data: {
     *     // ... data to create a InventoryMovementType
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementTypeCreateArgs>(args: SelectSubset<T, InventoryMovementTypeCreateArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovementTypes.
     * @param {InventoryMovementTypeCreateManyArgs} args - Arguments to create many InventoryMovementTypes.
     * @example
     * // Create many InventoryMovementTypes
     * const inventoryMovementType = await prisma.inventoryMovementType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementTypeCreateManyArgs>(args?: SelectSubset<T, InventoryMovementTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryMovementType.
     * @param {InventoryMovementTypeDeleteArgs} args - Arguments to delete one InventoryMovementType.
     * @example
     * // Delete one InventoryMovementType
     * const InventoryMovementType = await prisma.inventoryMovementType.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovementType
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementTypeDeleteArgs>(args: SelectSubset<T, InventoryMovementTypeDeleteArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovementType.
     * @param {InventoryMovementTypeUpdateArgs} args - Arguments to update one InventoryMovementType.
     * @example
     * // Update one InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementTypeUpdateArgs>(args: SelectSubset<T, InventoryMovementTypeUpdateArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovementTypes.
     * @param {InventoryMovementTypeDeleteManyArgs} args - Arguments to filter InventoryMovementTypes to delete.
     * @example
     * // Delete a few InventoryMovementTypes
     * const { count } = await prisma.inventoryMovementType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementTypeDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovementTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovementTypes
     * const inventoryMovementType = await prisma.inventoryMovementType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementTypeUpdateManyArgs>(args: SelectSubset<T, InventoryMovementTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryMovementType.
     * @param {InventoryMovementTypeUpsertArgs} args - Arguments to update or create a InventoryMovementType.
     * @example
     * // Update or create a InventoryMovementType
     * const inventoryMovementType = await prisma.inventoryMovementType.upsert({
     *   create: {
     *     // ... data to create a InventoryMovementType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovementType we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementTypeUpsertArgs>(args: SelectSubset<T, InventoryMovementTypeUpsertArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovementTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeCountArgs} args - Arguments to filter InventoryMovementTypes to count.
     * @example
     * // Count the number of InventoryMovementTypes
     * const count = await prisma.inventoryMovementType.count({
     *   where: {
     *     // ... the filter for the InventoryMovementTypes we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementTypeCountArgs>(
      args?: Subset<T, InventoryMovementTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovementType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementTypeAggregateArgs>(args: Subset<T, InventoryMovementTypeAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementTypeAggregateType<T>>

    /**
     * Group by InventoryMovementType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementTypeGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovementType model
   */
  readonly fields: InventoryMovementTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovementType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movements<T extends InventoryMovementType$movementsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovementType$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovementType model
   */
  interface InventoryMovementTypeFieldRefs {
    readonly code: FieldRef<"InventoryMovementType", 'String'>
    readonly name: FieldRef<"InventoryMovementType", 'String'>
    readonly description: FieldRef<"InventoryMovementType", 'String'>
    readonly color: FieldRef<"InventoryMovementType", 'String'>
    readonly createdAt: FieldRef<"InventoryMovementType", 'DateTime'>
    readonly createdBy: FieldRef<"InventoryMovementType", 'String'>
    readonly updatedAt: FieldRef<"InventoryMovementType", 'DateTime'>
    readonly updatedBy: FieldRef<"InventoryMovementType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovementType findUnique
   */
  export type InventoryMovementTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovementType to fetch.
     */
    where: InventoryMovementTypeWhereUniqueInput
  }

  /**
   * InventoryMovementType findUniqueOrThrow
   */
  export type InventoryMovementTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovementType to fetch.
     */
    where: InventoryMovementTypeWhereUniqueInput
  }

  /**
   * InventoryMovementType findFirst
   */
  export type InventoryMovementTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovementType to fetch.
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovementTypes to fetch.
     */
    orderBy?: InventoryMovementTypeOrderByWithRelationInput | InventoryMovementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovementTypes.
     */
    cursor?: InventoryMovementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovementTypes.
     */
    distinct?: InventoryMovementTypeScalarFieldEnum | InventoryMovementTypeScalarFieldEnum[]
  }

  /**
   * InventoryMovementType findFirstOrThrow
   */
  export type InventoryMovementTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovementType to fetch.
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovementTypes to fetch.
     */
    orderBy?: InventoryMovementTypeOrderByWithRelationInput | InventoryMovementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovementTypes.
     */
    cursor?: InventoryMovementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovementTypes.
     */
    distinct?: InventoryMovementTypeScalarFieldEnum | InventoryMovementTypeScalarFieldEnum[]
  }

  /**
   * InventoryMovementType findMany
   */
  export type InventoryMovementTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovementTypes to fetch.
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovementTypes to fetch.
     */
    orderBy?: InventoryMovementTypeOrderByWithRelationInput | InventoryMovementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovementTypes.
     */
    cursor?: InventoryMovementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovementTypes.
     */
    skip?: number
    distinct?: InventoryMovementTypeScalarFieldEnum | InventoryMovementTypeScalarFieldEnum[]
  }

  /**
   * InventoryMovementType create
   */
  export type InventoryMovementTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovementType.
     */
    data: XOR<InventoryMovementTypeCreateInput, InventoryMovementTypeUncheckedCreateInput>
  }

  /**
   * InventoryMovementType createMany
   */
  export type InventoryMovementTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovementTypes.
     */
    data: InventoryMovementTypeCreateManyInput | InventoryMovementTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovementType update
   */
  export type InventoryMovementTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovementType.
     */
    data: XOR<InventoryMovementTypeUpdateInput, InventoryMovementTypeUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovementType to update.
     */
    where: InventoryMovementTypeWhereUniqueInput
  }

  /**
   * InventoryMovementType updateMany
   */
  export type InventoryMovementTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovementTypes.
     */
    data: XOR<InventoryMovementTypeUpdateManyMutationInput, InventoryMovementTypeUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovementTypes to update
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * Limit how many InventoryMovementTypes to update.
     */
    limit?: number
  }

  /**
   * InventoryMovementType upsert
   */
  export type InventoryMovementTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovementType to update in case it exists.
     */
    where: InventoryMovementTypeWhereUniqueInput
    /**
     * In case the InventoryMovementType found by the `where` argument doesn't exist, create a new InventoryMovementType with this data.
     */
    create: XOR<InventoryMovementTypeCreateInput, InventoryMovementTypeUncheckedCreateInput>
    /**
     * In case the InventoryMovementType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementTypeUpdateInput, InventoryMovementTypeUncheckedUpdateInput>
  }

  /**
   * InventoryMovementType delete
   */
  export type InventoryMovementTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovementType to delete.
     */
    where: InventoryMovementTypeWhereUniqueInput
  }

  /**
   * InventoryMovementType deleteMany
   */
  export type InventoryMovementTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovementTypes to delete
     */
    where?: InventoryMovementTypeWhereInput
    /**
     * Limit how many InventoryMovementTypes to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovementType.movements
   */
  export type InventoryMovementType$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovementType without action
   */
  export type InventoryMovementTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovementType
     */
    select?: InventoryMovementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovementType
     */
    omit?: InventoryMovementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementTypeInclude<ExtArgs> | null
  }


  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    currentQuantity: number | null
    minimumStock: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    productId: number | null
    currentQuantity: number | null
    minimumStock: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    productId: number | null
    currentQuantity: number | null
    minimumStock: number | null
    storageLocation: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    currentQuantity: number | null
    minimumStock: number | null
    storageLocation: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    productId: number
    currentQuantity: number
    minimumStock: number
    storageLocation: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    productId?: true
    currentQuantity?: true
    minimumStock?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    productId?: true
    currentQuantity?: true
    minimumStock?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    productId?: true
    currentQuantity?: true
    minimumStock?: true
    storageLocation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    productId?: true
    currentQuantity?: true
    minimumStock?: true
    storageLocation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    productId?: true
    currentQuantity?: true
    minimumStock?: true
    storageLocation?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    productId: number
    currentQuantity: number
    minimumStock: number
    storageLocation: string | null
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    currentQuantity?: boolean
    minimumStock?: boolean
    storageLocation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryMovements?: boolean | Inventory$inventoryMovementsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>



  export type InventorySelectScalar = {
    id?: boolean
    productId?: boolean
    currentQuantity?: boolean
    minimumStock?: boolean
    storageLocation?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type InventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "currentQuantity" | "minimumStock" | "storageLocation" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["inventory"]>
  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryMovements?: boolean | Inventory$inventoryMovementsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      inventoryMovements: Prisma.$InventoryMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      currentQuantity: number
      minimumStock: number
      storageLocation: string | null
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryFindUniqueArgs>(args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryFindFirstArgs>(args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryFindManyArgs>(args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends InventoryCreateArgs>(args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inventories.
     * @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryCreateManyArgs>(args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends InventoryDeleteArgs>(args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryUpdateArgs>(args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryDeleteManyArgs>(args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryUpdateManyArgs>(args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends InventoryUpsertArgs>(args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryMovements<T extends Inventory$inventoryMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$inventoryMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inventory model
   */
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly productId: FieldRef<"Inventory", 'Int'>
    readonly currentQuantity: FieldRef<"Inventory", 'Int'>
    readonly minimumStock: FieldRef<"Inventory", 'Int'>
    readonly storageLocation: FieldRef<"Inventory", 'String'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly createdBy: FieldRef<"Inventory", 'String'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedBy: FieldRef<"Inventory", 'String'>
    readonly deletedAt: FieldRef<"Inventory", 'DateTime'>
    readonly deletedBy: FieldRef<"Inventory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }

  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to update.
     */
    limit?: number
  }

  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }

  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }

  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
    /**
     * Limit how many Inventories to delete.
     */
    limit?: number
  }

  /**
   * Inventory.inventoryMovements
   */
  export type Inventory$inventoryMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    cursor?: InventoryMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inventory
     */
    omit?: InventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryInclude<ExtArgs> | null
  }


  /**
   * Model InventoryMovement
   */

  export type AggregateInventoryMovement = {
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  export type InventoryMovementAvgAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    quantityMovement: number | null
  }

  export type InventoryMovementSumAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    quantityMovement: number | null
  }

  export type InventoryMovementMinAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    movementTypeCode: string | null
    quantityMovement: number | null
    reasonDescription: string | null
    userDocumentNumber: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InventoryMovementMaxAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    movementTypeCode: string | null
    quantityMovement: number | null
    reasonDescription: string | null
    userDocumentNumber: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
  }

  export type InventoryMovementCountAggregateOutputType = {
    id: number
    inventoryId: number
    movementTypeCode: number
    quantityMovement: number
    reasonDescription: number
    userDocumentNumber: number
    createdAt: number
    createdBy: number
    updatedAt: number
    updatedBy: number
    deletedAt: number
    deletedBy: number
    _all: number
  }


  export type InventoryMovementAvgAggregateInputType = {
    id?: true
    inventoryId?: true
    quantityMovement?: true
  }

  export type InventoryMovementSumAggregateInputType = {
    id?: true
    inventoryId?: true
    quantityMovement?: true
  }

  export type InventoryMovementMinAggregateInputType = {
    id?: true
    inventoryId?: true
    movementTypeCode?: true
    quantityMovement?: true
    reasonDescription?: true
    userDocumentNumber?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InventoryMovementMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    movementTypeCode?: true
    quantityMovement?: true
    reasonDescription?: true
    userDocumentNumber?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
  }

  export type InventoryMovementCountAggregateInputType = {
    id?: true
    inventoryId?: true
    movementTypeCode?: true
    quantityMovement?: true
    reasonDescription?: true
    userDocumentNumber?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    updatedBy?: true
    deletedAt?: true
    deletedBy?: true
    _all?: true
  }

  export type InventoryMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovement to aggregate.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryMovements
    **/
    _count?: true | InventoryMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type GetInventoryMovementAggregateType<T extends InventoryMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryMovement[P]>
      : GetScalarType<T[P], AggregateInventoryMovement[P]>
  }




  export type InventoryMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryMovementWhereInput
    orderBy?: InventoryMovementOrderByWithAggregationInput | InventoryMovementOrderByWithAggregationInput[]
    by: InventoryMovementScalarFieldEnum[] | InventoryMovementScalarFieldEnum
    having?: InventoryMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryMovementCountAggregateInputType | true
    _avg?: InventoryMovementAvgAggregateInputType
    _sum?: InventoryMovementSumAggregateInputType
    _min?: InventoryMovementMinAggregateInputType
    _max?: InventoryMovementMaxAggregateInputType
  }

  export type InventoryMovementGroupByOutputType = {
    id: number
    inventoryId: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt: Date
    createdBy: string
    updatedAt: Date | null
    updatedBy: string | null
    deletedAt: Date | null
    deletedBy: string | null
    _count: InventoryMovementCountAggregateOutputType | null
    _avg: InventoryMovementAvgAggregateOutputType | null
    _sum: InventoryMovementSumAggregateOutputType | null
    _min: InventoryMovementMinAggregateOutputType | null
    _max: InventoryMovementMaxAggregateOutputType | null
  }

  type GetInventoryMovementGroupByPayload<T extends InventoryMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryMovementGroupByOutputType[P]>
        }
      >
    >


  export type InventoryMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    movementTypeCode?: boolean
    quantityMovement?: boolean
    reasonDescription?: boolean
    userDocumentNumber?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    movementType?: boolean | InventoryMovementTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryMovement"]>



  export type InventoryMovementSelectScalar = {
    id?: boolean
    inventoryId?: boolean
    movementTypeCode?: boolean
    quantityMovement?: boolean
    reasonDescription?: boolean
    userDocumentNumber?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
  }

  export type InventoryMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inventoryId" | "movementTypeCode" | "quantityMovement" | "reasonDescription" | "userDocumentNumber" | "createdAt" | "createdBy" | "updatedAt" | "updatedBy" | "deletedAt" | "deletedBy", ExtArgs["result"]["inventoryMovement"]>
  export type InventoryMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    movementType?: boolean | InventoryMovementTypeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryMovement"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      movementType: Prisma.$InventoryMovementTypePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inventoryId: number
      movementTypeCode: string
      quantityMovement: number
      reasonDescription: string
      userDocumentNumber: string
      createdAt: Date
      createdBy: string
      updatedAt: Date | null
      updatedBy: string | null
      deletedAt: Date | null
      deletedBy: string | null
    }, ExtArgs["result"]["inventoryMovement"]>
    composites: {}
  }

  type InventoryMovementGetPayload<S extends boolean | null | undefined | InventoryMovementDefaultArgs> = $Result.GetResult<Prisma.$InventoryMovementPayload, S>

  type InventoryMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryMovementCountAggregateInputType | true
    }

  export interface InventoryMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryMovement'], meta: { name: 'InventoryMovement' } }
    /**
     * Find zero or one InventoryMovement that matches the filter.
     * @param {InventoryMovementFindUniqueArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryMovementFindUniqueArgs>(args: SelectSubset<T, InventoryMovementFindUniqueArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryMovementFindUniqueOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryMovementFindFirstArgs>(args?: SelectSubset<T, InventoryMovementFindFirstArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindFirstOrThrowArgs} args - Arguments to find a InventoryMovement
     * @example
     * // Get one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany()
     * 
     * // Get first 10 InventoryMovements
     * const inventoryMovements = await prisma.inventoryMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryMovementWithIdOnly = await prisma.inventoryMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryMovementFindManyArgs>(args?: SelectSubset<T, InventoryMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryMovement.
     * @param {InventoryMovementCreateArgs} args - Arguments to create a InventoryMovement.
     * @example
     * // Create one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.create({
     *   data: {
     *     // ... data to create a InventoryMovement
     *   }
     * })
     * 
     */
    create<T extends InventoryMovementCreateArgs>(args: SelectSubset<T, InventoryMovementCreateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryMovements.
     * @param {InventoryMovementCreateManyArgs} args - Arguments to create many InventoryMovements.
     * @example
     * // Create many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryMovementCreateManyArgs>(args?: SelectSubset<T, InventoryMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InventoryMovement.
     * @param {InventoryMovementDeleteArgs} args - Arguments to delete one InventoryMovement.
     * @example
     * // Delete one InventoryMovement
     * const InventoryMovement = await prisma.inventoryMovement.delete({
     *   where: {
     *     // ... filter to delete one InventoryMovement
     *   }
     * })
     * 
     */
    delete<T extends InventoryMovementDeleteArgs>(args: SelectSubset<T, InventoryMovementDeleteArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryMovement.
     * @param {InventoryMovementUpdateArgs} args - Arguments to update one InventoryMovement.
     * @example
     * // Update one InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryMovementUpdateArgs>(args: SelectSubset<T, InventoryMovementUpdateArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryMovements.
     * @param {InventoryMovementDeleteManyArgs} args - Arguments to filter InventoryMovements to delete.
     * @example
     * // Delete a few InventoryMovements
     * const { count } = await prisma.inventoryMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryMovementDeleteManyArgs>(args?: SelectSubset<T, InventoryMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryMovements
     * const inventoryMovement = await prisma.inventoryMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryMovementUpdateManyArgs>(args: SelectSubset<T, InventoryMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryMovement.
     * @param {InventoryMovementUpsertArgs} args - Arguments to update or create a InventoryMovement.
     * @example
     * // Update or create a InventoryMovement
     * const inventoryMovement = await prisma.inventoryMovement.upsert({
     *   create: {
     *     // ... data to create a InventoryMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryMovement we want to update
     *   }
     * })
     */
    upsert<T extends InventoryMovementUpsertArgs>(args: SelectSubset<T, InventoryMovementUpsertArgs<ExtArgs>>): Prisma__InventoryMovementClient<$Result.GetResult<Prisma.$InventoryMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementCountArgs} args - Arguments to filter InventoryMovements to count.
     * @example
     * // Count the number of InventoryMovements
     * const count = await prisma.inventoryMovement.count({
     *   where: {
     *     // ... the filter for the InventoryMovements we want to count
     *   }
     * })
    **/
    count<T extends InventoryMovementCountArgs>(
      args?: Subset<T, InventoryMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryMovementAggregateArgs>(args: Subset<T, InventoryMovementAggregateArgs>): Prisma.PrismaPromise<GetInventoryMovementAggregateType<T>>

    /**
     * Group by InventoryMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryMovementGroupByArgs['orderBy'] }
        : { orderBy?: InventoryMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryMovement model
   */
  readonly fields: InventoryMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    movementType<T extends InventoryMovementTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryMovementTypeDefaultArgs<ExtArgs>>): Prisma__InventoryMovementTypeClient<$Result.GetResult<Prisma.$InventoryMovementTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryMovement model
   */
  interface InventoryMovementFieldRefs {
    readonly id: FieldRef<"InventoryMovement", 'Int'>
    readonly inventoryId: FieldRef<"InventoryMovement", 'Int'>
    readonly movementTypeCode: FieldRef<"InventoryMovement", 'String'>
    readonly quantityMovement: FieldRef<"InventoryMovement", 'Int'>
    readonly reasonDescription: FieldRef<"InventoryMovement", 'String'>
    readonly userDocumentNumber: FieldRef<"InventoryMovement", 'String'>
    readonly createdAt: FieldRef<"InventoryMovement", 'DateTime'>
    readonly createdBy: FieldRef<"InventoryMovement", 'String'>
    readonly updatedAt: FieldRef<"InventoryMovement", 'DateTime'>
    readonly updatedBy: FieldRef<"InventoryMovement", 'String'>
    readonly deletedAt: FieldRef<"InventoryMovement", 'DateTime'>
    readonly deletedBy: FieldRef<"InventoryMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InventoryMovement findUnique
   */
  export type InventoryMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findUniqueOrThrow
   */
  export type InventoryMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement findFirst
   */
  export type InventoryMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findFirstOrThrow
   */
  export type InventoryMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovement to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryMovements.
     */
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement findMany
   */
  export type InventoryMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter, which InventoryMovements to fetch.
     */
    where?: InventoryMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryMovements to fetch.
     */
    orderBy?: InventoryMovementOrderByWithRelationInput | InventoryMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryMovements.
     */
    cursor?: InventoryMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryMovements.
     */
    skip?: number
    distinct?: InventoryMovementScalarFieldEnum | InventoryMovementScalarFieldEnum[]
  }

  /**
   * InventoryMovement create
   */
  export type InventoryMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryMovement.
     */
    data: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
  }

  /**
   * InventoryMovement createMany
   */
  export type InventoryMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryMovements.
     */
    data: InventoryMovementCreateManyInput | InventoryMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryMovement update
   */
  export type InventoryMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryMovement.
     */
    data: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
    /**
     * Choose, which InventoryMovement to update.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement updateMany
   */
  export type InventoryMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryMovements.
     */
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyInput>
    /**
     * Filter which InventoryMovements to update
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to update.
     */
    limit?: number
  }

  /**
   * InventoryMovement upsert
   */
  export type InventoryMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryMovement to update in case it exists.
     */
    where: InventoryMovementWhereUniqueInput
    /**
     * In case the InventoryMovement found by the `where` argument doesn't exist, create a new InventoryMovement with this data.
     */
    create: XOR<InventoryMovementCreateInput, InventoryMovementUncheckedCreateInput>
    /**
     * In case the InventoryMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryMovementUpdateInput, InventoryMovementUncheckedUpdateInput>
  }

  /**
   * InventoryMovement delete
   */
  export type InventoryMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
    /**
     * Filter which InventoryMovement to delete.
     */
    where: InventoryMovementWhereUniqueInput
  }

  /**
   * InventoryMovement deleteMany
   */
  export type InventoryMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryMovements to delete
     */
    where?: InventoryMovementWhereInput
    /**
     * Limit how many InventoryMovements to delete.
     */
    limit?: number
  }

  /**
   * InventoryMovement without action
   */
  export type InventoryMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryMovement
     */
    select?: InventoryMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryMovement
     */
    omit?: InventoryMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryMovementInclude<ExtArgs> | null
  }


  /**
   * Model OrderSequence
   */

  export type AggregateOrderSequence = {
    _count: OrderSequenceCountAggregateOutputType | null
    _avg: OrderSequenceAvgAggregateOutputType | null
    _sum: OrderSequenceSumAggregateOutputType | null
    _min: OrderSequenceMinAggregateOutputType | null
    _max: OrderSequenceMaxAggregateOutputType | null
  }

  export type OrderSequenceAvgAggregateOutputType = {
    id: number | null
    sequenceYear: number | null
    sequenceMonth: number | null
    sequenceDay: number | null
    lastOrderNumber: number | null
  }

  export type OrderSequenceSumAggregateOutputType = {
    id: number | null
    sequenceYear: number | null
    sequenceMonth: number | null
    sequenceDay: number | null
    lastOrderNumber: number | null
  }

  export type OrderSequenceMinAggregateOutputType = {
    id: number | null
    sequenceYear: number | null
    sequenceMonth: number | null
    sequenceDay: number | null
    lastOrderNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderSequenceMaxAggregateOutputType = {
    id: number | null
    sequenceYear: number | null
    sequenceMonth: number | null
    sequenceDay: number | null
    lastOrderNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderSequenceCountAggregateOutputType = {
    id: number
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
    lastOrderNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderSequenceAvgAggregateInputType = {
    id?: true
    sequenceYear?: true
    sequenceMonth?: true
    sequenceDay?: true
    lastOrderNumber?: true
  }

  export type OrderSequenceSumAggregateInputType = {
    id?: true
    sequenceYear?: true
    sequenceMonth?: true
    sequenceDay?: true
    lastOrderNumber?: true
  }

  export type OrderSequenceMinAggregateInputType = {
    id?: true
    sequenceYear?: true
    sequenceMonth?: true
    sequenceDay?: true
    lastOrderNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderSequenceMaxAggregateInputType = {
    id?: true
    sequenceYear?: true
    sequenceMonth?: true
    sequenceDay?: true
    lastOrderNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderSequenceCountAggregateInputType = {
    id?: true
    sequenceYear?: true
    sequenceMonth?: true
    sequenceDay?: true
    lastOrderNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderSequenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSequence to aggregate.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderSequences
    **/
    _count?: true | OrderSequenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderSequenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSequenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderSequenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderSequenceMaxAggregateInputType
  }

  export type GetOrderSequenceAggregateType<T extends OrderSequenceAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderSequence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderSequence[P]>
      : GetScalarType<T[P], AggregateOrderSequence[P]>
  }




  export type OrderSequenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderSequenceWhereInput
    orderBy?: OrderSequenceOrderByWithAggregationInput | OrderSequenceOrderByWithAggregationInput[]
    by: OrderSequenceScalarFieldEnum[] | OrderSequenceScalarFieldEnum
    having?: OrderSequenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderSequenceCountAggregateInputType | true
    _avg?: OrderSequenceAvgAggregateInputType
    _sum?: OrderSequenceSumAggregateInputType
    _min?: OrderSequenceMinAggregateInputType
    _max?: OrderSequenceMaxAggregateInputType
  }

  export type OrderSequenceGroupByOutputType = {
    id: number
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
    lastOrderNumber: number
    createdAt: Date
    updatedAt: Date | null
    _count: OrderSequenceCountAggregateOutputType | null
    _avg: OrderSequenceAvgAggregateOutputType | null
    _sum: OrderSequenceSumAggregateOutputType | null
    _min: OrderSequenceMinAggregateOutputType | null
    _max: OrderSequenceMaxAggregateOutputType | null
  }

  type GetOrderSequenceGroupByPayload<T extends OrderSequenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderSequenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderSequenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderSequenceGroupByOutputType[P]>
            : GetScalarType<T[P], OrderSequenceGroupByOutputType[P]>
        }
      >
    >


  export type OrderSequenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sequenceYear?: boolean
    sequenceMonth?: boolean
    sequenceDay?: boolean
    lastOrderNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["orderSequence"]>



  export type OrderSequenceSelectScalar = {
    id?: boolean
    sequenceYear?: boolean
    sequenceMonth?: boolean
    sequenceDay?: boolean
    lastOrderNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderSequenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sequenceYear" | "sequenceMonth" | "sequenceDay" | "lastOrderNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["orderSequence"]>

  export type $OrderSequencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderSequence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sequenceYear: number
      sequenceMonth: number
      sequenceDay: number
      lastOrderNumber: number
      createdAt: Date
      updatedAt: Date | null
    }, ExtArgs["result"]["orderSequence"]>
    composites: {}
  }

  type OrderSequenceGetPayload<S extends boolean | null | undefined | OrderSequenceDefaultArgs> = $Result.GetResult<Prisma.$OrderSequencePayload, S>

  type OrderSequenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderSequenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderSequenceCountAggregateInputType | true
    }

  export interface OrderSequenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderSequence'], meta: { name: 'OrderSequence' } }
    /**
     * Find zero or one OrderSequence that matches the filter.
     * @param {OrderSequenceFindUniqueArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderSequenceFindUniqueArgs>(args: SelectSubset<T, OrderSequenceFindUniqueArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderSequence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderSequenceFindUniqueOrThrowArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderSequenceFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderSequenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderSequence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindFirstArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderSequenceFindFirstArgs>(args?: SelectSubset<T, OrderSequenceFindFirstArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderSequence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindFirstOrThrowArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderSequenceFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderSequenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderSequences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderSequences
     * const orderSequences = await prisma.orderSequence.findMany()
     * 
     * // Get first 10 OrderSequences
     * const orderSequences = await prisma.orderSequence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderSequenceWithIdOnly = await prisma.orderSequence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderSequenceFindManyArgs>(args?: SelectSubset<T, OrderSequenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderSequence.
     * @param {OrderSequenceCreateArgs} args - Arguments to create a OrderSequence.
     * @example
     * // Create one OrderSequence
     * const OrderSequence = await prisma.orderSequence.create({
     *   data: {
     *     // ... data to create a OrderSequence
     *   }
     * })
     * 
     */
    create<T extends OrderSequenceCreateArgs>(args: SelectSubset<T, OrderSequenceCreateArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderSequences.
     * @param {OrderSequenceCreateManyArgs} args - Arguments to create many OrderSequences.
     * @example
     * // Create many OrderSequences
     * const orderSequence = await prisma.orderSequence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderSequenceCreateManyArgs>(args?: SelectSubset<T, OrderSequenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderSequence.
     * @param {OrderSequenceDeleteArgs} args - Arguments to delete one OrderSequence.
     * @example
     * // Delete one OrderSequence
     * const OrderSequence = await prisma.orderSequence.delete({
     *   where: {
     *     // ... filter to delete one OrderSequence
     *   }
     * })
     * 
     */
    delete<T extends OrderSequenceDeleteArgs>(args: SelectSubset<T, OrderSequenceDeleteArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderSequence.
     * @param {OrderSequenceUpdateArgs} args - Arguments to update one OrderSequence.
     * @example
     * // Update one OrderSequence
     * const orderSequence = await prisma.orderSequence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderSequenceUpdateArgs>(args: SelectSubset<T, OrderSequenceUpdateArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderSequences.
     * @param {OrderSequenceDeleteManyArgs} args - Arguments to filter OrderSequences to delete.
     * @example
     * // Delete a few OrderSequences
     * const { count } = await prisma.orderSequence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderSequenceDeleteManyArgs>(args?: SelectSubset<T, OrderSequenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderSequences
     * const orderSequence = await prisma.orderSequence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderSequenceUpdateManyArgs>(args: SelectSubset<T, OrderSequenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderSequence.
     * @param {OrderSequenceUpsertArgs} args - Arguments to update or create a OrderSequence.
     * @example
     * // Update or create a OrderSequence
     * const orderSequence = await prisma.orderSequence.upsert({
     *   create: {
     *     // ... data to create a OrderSequence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderSequence we want to update
     *   }
     * })
     */
    upsert<T extends OrderSequenceUpsertArgs>(args: SelectSubset<T, OrderSequenceUpsertArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceCountArgs} args - Arguments to filter OrderSequences to count.
     * @example
     * // Count the number of OrderSequences
     * const count = await prisma.orderSequence.count({
     *   where: {
     *     // ... the filter for the OrderSequences we want to count
     *   }
     * })
    **/
    count<T extends OrderSequenceCountArgs>(
      args?: Subset<T, OrderSequenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderSequenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderSequenceAggregateArgs>(args: Subset<T, OrderSequenceAggregateArgs>): Prisma.PrismaPromise<GetOrderSequenceAggregateType<T>>

    /**
     * Group by OrderSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderSequenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderSequenceGroupByArgs['orderBy'] }
        : { orderBy?: OrderSequenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderSequenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderSequenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderSequence model
   */
  readonly fields: OrderSequenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderSequence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderSequenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderSequence model
   */
  interface OrderSequenceFieldRefs {
    readonly id: FieldRef<"OrderSequence", 'Int'>
    readonly sequenceYear: FieldRef<"OrderSequence", 'Int'>
    readonly sequenceMonth: FieldRef<"OrderSequence", 'Int'>
    readonly sequenceDay: FieldRef<"OrderSequence", 'Int'>
    readonly lastOrderNumber: FieldRef<"OrderSequence", 'Int'>
    readonly createdAt: FieldRef<"OrderSequence", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderSequence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderSequence findUnique
   */
  export type OrderSequenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence findUniqueOrThrow
   */
  export type OrderSequenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence findFirst
   */
  export type OrderSequenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSequences.
     */
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence findFirstOrThrow
   */
  export type OrderSequenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSequences.
     */
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence findMany
   */
  export type OrderSequenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter, which OrderSequences to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence create
   */
  export type OrderSequenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * The data needed to create a OrderSequence.
     */
    data: XOR<OrderSequenceCreateInput, OrderSequenceUncheckedCreateInput>
  }

  /**
   * OrderSequence createMany
   */
  export type OrderSequenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderSequences.
     */
    data: OrderSequenceCreateManyInput | OrderSequenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderSequence update
   */
  export type OrderSequenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * The data needed to update a OrderSequence.
     */
    data: XOR<OrderSequenceUpdateInput, OrderSequenceUncheckedUpdateInput>
    /**
     * Choose, which OrderSequence to update.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence updateMany
   */
  export type OrderSequenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderSequences.
     */
    data: XOR<OrderSequenceUpdateManyMutationInput, OrderSequenceUncheckedUpdateManyInput>
    /**
     * Filter which OrderSequences to update
     */
    where?: OrderSequenceWhereInput
    /**
     * Limit how many OrderSequences to update.
     */
    limit?: number
  }

  /**
   * OrderSequence upsert
   */
  export type OrderSequenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * The filter to search for the OrderSequence to update in case it exists.
     */
    where: OrderSequenceWhereUniqueInput
    /**
     * In case the OrderSequence found by the `where` argument doesn't exist, create a new OrderSequence with this data.
     */
    create: XOR<OrderSequenceCreateInput, OrderSequenceUncheckedCreateInput>
    /**
     * In case the OrderSequence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderSequenceUpdateInput, OrderSequenceUncheckedUpdateInput>
  }

  /**
   * OrderSequence delete
   */
  export type OrderSequenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
    /**
     * Filter which OrderSequence to delete.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence deleteMany
   */
  export type OrderSequenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSequences to delete
     */
    where?: OrderSequenceWhereInput
    /**
     * Limit how many OrderSequences to delete.
     */
    limit?: number
  }

  /**
   * OrderSequence without action
   */
  export type OrderSequenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSequence
     */
    omit?: OrderSequenceOmit<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    entityName: string | null
    entityId: string | null
    action: string | null
    message: string | null
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    createdAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    entityName: string | null
    entityId: string | null
    action: string | null
    message: string | null
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    createdAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    entityName: number
    entityId: number
    action: number
    message: number
    userDocumentNumber: number
    customerDocumentNumber: number
    createdAt: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    entityName?: true
    entityId?: true
    action?: true
    message?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    createdAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    entityName?: true
    entityId?: true
    action?: true
    message?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    createdAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    entityName?: true
    entityId?: true
    action?: true
    message?: true
    userDocumentNumber?: true
    customerDocumentNumber?: true
    createdAt?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    entityName: string
    entityId: string | null
    action: string
    message: string | null
    userDocumentNumber: string | null
    customerDocumentNumber: string | null
    createdAt: Date
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityName?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    userDocumentNumber?: boolean
    customerDocumentNumber?: boolean
    createdAt?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
    customer?: boolean | Log$customerArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>



  export type LogSelectScalar = {
    id?: boolean
    entityName?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    userDocumentNumber?: boolean
    customerDocumentNumber?: boolean
    createdAt?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityName" | "entityId" | "action" | "message" | "userDocumentNumber" | "customerDocumentNumber" | "createdAt", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
    customer?: boolean | Log$customerArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityName: string
      entityId: string | null
      action: string
      message: string | null
      userDocumentNumber: string | null
      customerDocumentNumber: string | null
      createdAt: Date
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Log$customerArgs<ExtArgs> = {}>(args?: Subset<T, Log$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly entityName: FieldRef<"Log", 'String'>
    readonly entityId: FieldRef<"Log", 'String'>
    readonly action: FieldRef<"Log", 'String'>
    readonly message: FieldRef<"Log", 'String'>
    readonly userDocumentNumber: FieldRef<"Log", 'String'>
    readonly customerDocumentNumber: FieldRef<"Log", 'String'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log.customer
   */
  export type Log$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RestaurantConfigScalarFieldEnum: {
    id: 'id',
    name: 'name',
    activeLogoId: 'activeLogoId',
    currency: 'currency',
    address: 'address',
    phone: 'phone',
    email: 'email',
    taxName: 'taxName',
    taxIncluded: 'taxIncluded',
    taxType: 'taxType',
    taxRate: 'taxRate',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type RestaurantConfigScalarFieldEnum = (typeof RestaurantConfigScalarFieldEnum)[keyof typeof RestaurantConfigScalarFieldEnum]


  export const ThemeScalarFieldEnum: {
    name: 'name',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    accentColor: 'accentColor',
    neutralColor: 'neutralColor',
    isSystem: 'isSystem',
    isPublic: 'isPublic',
    createdUserDocument: 'createdUserDocument',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ThemeScalarFieldEnum = (typeof ThemeScalarFieldEnum)[keyof typeof ThemeScalarFieldEnum]


  export const DocumentTypeScalarFieldEnum: {
    name: 'name',
    description: 'description',
    digitLength: 'digitLength',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type DocumentTypeScalarFieldEnum = (typeof DocumentTypeScalarFieldEnum)[keyof typeof DocumentTypeScalarFieldEnum]


  export const AccountStatusScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type AccountStatusScalarFieldEnum = (typeof AccountStatusScalarFieldEnum)[keyof typeof AccountStatusScalarFieldEnum]


  export const PermissionCategoryScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type PermissionCategoryScalarFieldEnum = (typeof PermissionCategoryScalarFieldEnum)[keyof typeof PermissionCategoryScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    categoryCode: 'categoryCode',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleName: 'roleName',
    permissionCode: 'permissionCode',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    documentNumber: 'documentNumber',
    username: 'username',
    email: 'email',
    password: 'password',
    pin: 'pin',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    birthDate: 'birthDate',
    hireDate: 'hireDate',
    salary: 'salary',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    documentTypeName: 'documentTypeName',
    roleName: 'roleName',
    accountStatusCode: 'accountStatusCode',
    themeName: 'themeName',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userDocumentNumber: 'userDocumentNumber',
    customerDocumentNumber: 'customerDocumentNumber',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    closedAt: 'closedAt',
    closedBy: 'closedBy',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    documentNumber: 'documentNumber',
    username: 'username',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    documentTypeName: 'documentTypeName',
    accountStatusCode: 'accountStatusCode',
    themeName: 'themeName',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CashBoxScalarFieldEnum: {
    id: 'id',
    openerUserDocument: 'openerUserDocument',
    openedAt: 'openedAt',
    initialAmount: 'initialAmount',
    closerUserDocument: 'closerUserDocument',
    closedAt: 'closedAt',
    finalAmount: 'finalAmount',
    totalSales: 'totalSales',
    notes: 'notes',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type CashBoxScalarFieldEnum = (typeof CashBoxScalarFieldEnum)[keyof typeof CashBoxScalarFieldEnum]


  export const TableStatusScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type TableStatusScalarFieldEnum = (typeof TableStatusScalarFieldEnum)[keyof typeof TableStatusScalarFieldEnum]


  export const RestaurantZoneScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type RestaurantZoneScalarFieldEnum = (typeof RestaurantZoneScalarFieldEnum)[keyof typeof RestaurantZoneScalarFieldEnum]


  export const TableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    capacity: 'capacity',
    zoneName: 'zoneName',
    statusCode: 'statusCode',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const CombineTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    combinerUserDocument: 'combinerUserDocument',
    combineAt: 'combineAt',
    isActive: 'isActive',
    releaserUserDocument: 'releaserUserDocument',
    releasedAt: 'releasedAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type CombineTableScalarFieldEnum = (typeof CombineTableScalarFieldEnum)[keyof typeof CombineTableScalarFieldEnum]


  export const CombineTableItemScalarFieldEnum: {
    id: 'id',
    combineTableId: 'combineTableId',
    tableId: 'tableId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type CombineTableItemScalarFieldEnum = (typeof CombineTableItemScalarFieldEnum)[keyof typeof CombineTableItemScalarFieldEnum]


  export const TableSessionScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    combineTableId: 'combineTableId',
    openerUserDocument: 'openerUserDocument',
    openedAt: 'openedAt',
    numberPeople: 'numberPeople',
    isActive: 'isActive',
    closerUserDocument: 'closerUserDocument',
    closedAt: 'closedAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type TableSessionScalarFieldEnum = (typeof TableSessionScalarFieldEnum)[keyof typeof TableSessionScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    altText: 'altText',
    url: 'url',
    imageableId: 'imageableId',
    imageableType: 'imageableType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const ProductStatusScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type ProductStatusScalarFieldEnum = (typeof ProductStatusScalarFieldEnum)[keyof typeof ProductStatusScalarFieldEnum]


  export const ProductTypeScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ProductTypeScalarFieldEnum = (typeof ProductTypeScalarFieldEnum)[keyof typeof ProductTypeScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    offerPrice: 'offerPrice',
    productTypeName: 'productTypeName',
    productCategoryName: 'productCategoryName',
    brandName: 'brandName',
    productStatusCode: 'productStatusCode',
    mainImageId: 'mainImageId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const OrderStatusScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type OrderStatusScalarFieldEnum = (typeof OrderStatusScalarFieldEnum)[keyof typeof OrderStatusScalarFieldEnum]


  export const OrderItemStatusScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type OrderItemStatusScalarFieldEnum = (typeof OrderItemStatusScalarFieldEnum)[keyof typeof OrderItemStatusScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    code: 'code',
    tableSessionId: 'tableSessionId',
    creatorUserDocument: 'creatorUserDocument',
    createdAt: 'createdAt',
    customerDocumentNumber: 'customerDocumentNumber',
    subtotalAmount: 'subtotalAmount',
    taxAmount: 'taxAmount',
    totalAmount: 'totalAmount',
    statusCode: 'statusCode',
    closerUserDocument: 'closerUserDocument',
    closedAt: 'closedAt',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderCode: 'orderCode',
    productId: 'productId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subTotal: 'subTotal',
    discount: 'discount',
    statusCode: 'statusCode',
    specialInstructions: 'specialInstructions',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    isActive: 'isActive',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderCode: 'orderCode',
    cashBoxId: 'cashBoxId',
    totalAmount: 'totalAmount',
    paymentMethodName: 'paymentMethodName',
    receivedAmount: 'receivedAmount',
    changeAmount: 'changeAmount',
    transactionNumber: 'transactionNumber',
    notes: 'notes',
    receiveUserDocument: 'receiveUserDocument',
    paidCustomerDocument: 'paidCustomerDocument',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InventoryMovementTypeScalarFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type InventoryMovementTypeScalarFieldEnum = (typeof InventoryMovementTypeScalarFieldEnum)[keyof typeof InventoryMovementTypeScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    currentQuantity: 'currentQuantity',
    minimumStock: 'minimumStock',
    storageLocation: 'storageLocation',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const InventoryMovementScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    movementTypeCode: 'movementTypeCode',
    quantityMovement: 'quantityMovement',
    reasonDescription: 'reasonDescription',
    userDocumentNumber: 'userDocumentNumber',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy'
  };

  export type InventoryMovementScalarFieldEnum = (typeof InventoryMovementScalarFieldEnum)[keyof typeof InventoryMovementScalarFieldEnum]


  export const OrderSequenceScalarFieldEnum: {
    id: 'id',
    sequenceYear: 'sequenceYear',
    sequenceMonth: 'sequenceMonth',
    sequenceDay: 'sequenceDay',
    lastOrderNumber: 'lastOrderNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderSequenceScalarFieldEnum = (typeof OrderSequenceScalarFieldEnum)[keyof typeof OrderSequenceScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    entityName: 'entityName',
    entityId: 'entityId',
    action: 'action',
    message: 'message',
    userDocumentNumber: 'userDocumentNumber',
    customerDocumentNumber: 'customerDocumentNumber',
    createdAt: 'createdAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const RestaurantConfigOrderByRelevanceFieldEnum: {
    name: 'name',
    currency: 'currency',
    address: 'address',
    phone: 'phone',
    email: 'email',
    taxName: 'taxName',
    taxType: 'taxType',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type RestaurantConfigOrderByRelevanceFieldEnum = (typeof RestaurantConfigOrderByRelevanceFieldEnum)[keyof typeof RestaurantConfigOrderByRelevanceFieldEnum]


  export const ThemeOrderByRelevanceFieldEnum: {
    name: 'name',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    accentColor: 'accentColor',
    neutralColor: 'neutralColor',
    createdUserDocument: 'createdUserDocument',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type ThemeOrderByRelevanceFieldEnum = (typeof ThemeOrderByRelevanceFieldEnum)[keyof typeof ThemeOrderByRelevanceFieldEnum]


  export const DocumentTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type DocumentTypeOrderByRelevanceFieldEnum = (typeof DocumentTypeOrderByRelevanceFieldEnum)[keyof typeof DocumentTypeOrderByRelevanceFieldEnum]


  export const AccountStatusOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type AccountStatusOrderByRelevanceFieldEnum = (typeof AccountStatusOrderByRelevanceFieldEnum)[keyof typeof AccountStatusOrderByRelevanceFieldEnum]


  export const PermissionCategoryOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PermissionCategoryOrderByRelevanceFieldEnum = (typeof PermissionCategoryOrderByRelevanceFieldEnum)[keyof typeof PermissionCategoryOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    categoryCode: 'categoryCode',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const RolePermissionOrderByRelevanceFieldEnum: {
    roleName: 'roleName',
    permissionCode: 'permissionCode',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    documentNumber: 'documentNumber',
    username: 'username',
    email: 'email',
    password: 'password',
    pin: 'pin',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    documentTypeName: 'documentTypeName',
    roleName: 'roleName',
    accountStatusCode: 'accountStatusCode',
    themeName: 'themeName',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    userDocumentNumber: 'userDocumentNumber',
    customerDocumentNumber: 'customerDocumentNumber',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    closedBy: 'closedBy',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    documentNumber: 'documentNumber',
    username: 'username',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    phoneNumber: 'phoneNumber',
    documentTypeName: 'documentTypeName',
    accountStatusCode: 'accountStatusCode',
    themeName: 'themeName',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const CashBoxOrderByRelevanceFieldEnum: {
    openerUserDocument: 'openerUserDocument',
    closerUserDocument: 'closerUserDocument',
    notes: 'notes',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type CashBoxOrderByRelevanceFieldEnum = (typeof CashBoxOrderByRelevanceFieldEnum)[keyof typeof CashBoxOrderByRelevanceFieldEnum]


  export const TableStatusOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type TableStatusOrderByRelevanceFieldEnum = (typeof TableStatusOrderByRelevanceFieldEnum)[keyof typeof TableStatusOrderByRelevanceFieldEnum]


  export const RestaurantZoneOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type RestaurantZoneOrderByRelevanceFieldEnum = (typeof RestaurantZoneOrderByRelevanceFieldEnum)[keyof typeof RestaurantZoneOrderByRelevanceFieldEnum]


  export const TableOrderByRelevanceFieldEnum: {
    name: 'name',
    zoneName: 'zoneName',
    statusCode: 'statusCode',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type TableOrderByRelevanceFieldEnum = (typeof TableOrderByRelevanceFieldEnum)[keyof typeof TableOrderByRelevanceFieldEnum]


  export const CombineTableOrderByRelevanceFieldEnum: {
    name: 'name',
    combinerUserDocument: 'combinerUserDocument',
    releaserUserDocument: 'releaserUserDocument',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type CombineTableOrderByRelevanceFieldEnum = (typeof CombineTableOrderByRelevanceFieldEnum)[keyof typeof CombineTableOrderByRelevanceFieldEnum]


  export const CombineTableItemOrderByRelevanceFieldEnum: {
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type CombineTableItemOrderByRelevanceFieldEnum = (typeof CombineTableItemOrderByRelevanceFieldEnum)[keyof typeof CombineTableItemOrderByRelevanceFieldEnum]


  export const TableSessionOrderByRelevanceFieldEnum: {
    openerUserDocument: 'openerUserDocument',
    closerUserDocument: 'closerUserDocument',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type TableSessionOrderByRelevanceFieldEnum = (typeof TableSessionOrderByRelevanceFieldEnum)[keyof typeof TableSessionOrderByRelevanceFieldEnum]


  export const ImageOrderByRelevanceFieldEnum: {
    name: 'name',
    altText: 'altText',
    url: 'url',
    imageableType: 'imageableType',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type ImageOrderByRelevanceFieldEnum = (typeof ImageOrderByRelevanceFieldEnum)[keyof typeof ImageOrderByRelevanceFieldEnum]


  export const BrandOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type BrandOrderByRelevanceFieldEnum = (typeof BrandOrderByRelevanceFieldEnum)[keyof typeof BrandOrderByRelevanceFieldEnum]


  export const ProductStatusOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type ProductStatusOrderByRelevanceFieldEnum = (typeof ProductStatusOrderByRelevanceFieldEnum)[keyof typeof ProductStatusOrderByRelevanceFieldEnum]


  export const ProductTypeOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type ProductTypeOrderByRelevanceFieldEnum = (typeof ProductTypeOrderByRelevanceFieldEnum)[keyof typeof ProductTypeOrderByRelevanceFieldEnum]


  export const ProductCategoryOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type ProductCategoryOrderByRelevanceFieldEnum = (typeof ProductCategoryOrderByRelevanceFieldEnum)[keyof typeof ProductCategoryOrderByRelevanceFieldEnum]


  export const ProductOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    productTypeName: 'productTypeName',
    productCategoryName: 'productCategoryName',
    brandName: 'brandName',
    productStatusCode: 'productStatusCode',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type ProductOrderByRelevanceFieldEnum = (typeof ProductOrderByRelevanceFieldEnum)[keyof typeof ProductOrderByRelevanceFieldEnum]


  export const OrderStatusOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type OrderStatusOrderByRelevanceFieldEnum = (typeof OrderStatusOrderByRelevanceFieldEnum)[keyof typeof OrderStatusOrderByRelevanceFieldEnum]


  export const OrderItemStatusOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type OrderItemStatusOrderByRelevanceFieldEnum = (typeof OrderItemStatusOrderByRelevanceFieldEnum)[keyof typeof OrderItemStatusOrderByRelevanceFieldEnum]


  export const OrderOrderByRelevanceFieldEnum: {
    code: 'code',
    creatorUserDocument: 'creatorUserDocument',
    customerDocumentNumber: 'customerDocumentNumber',
    statusCode: 'statusCode',
    closerUserDocument: 'closerUserDocument',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type OrderOrderByRelevanceFieldEnum = (typeof OrderOrderByRelevanceFieldEnum)[keyof typeof OrderOrderByRelevanceFieldEnum]


  export const OrderItemOrderByRelevanceFieldEnum: {
    orderCode: 'orderCode',
    statusCode: 'statusCode',
    specialInstructions: 'specialInstructions',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type OrderItemOrderByRelevanceFieldEnum = (typeof OrderItemOrderByRelevanceFieldEnum)[keyof typeof OrderItemOrderByRelevanceFieldEnum]


  export const PaymentMethodOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type PaymentMethodOrderByRelevanceFieldEnum = (typeof PaymentMethodOrderByRelevanceFieldEnum)[keyof typeof PaymentMethodOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    orderCode: 'orderCode',
    paymentMethodName: 'paymentMethodName',
    transactionNumber: 'transactionNumber',
    notes: 'notes',
    receiveUserDocument: 'receiveUserDocument',
    paidCustomerDocument: 'paidCustomerDocument',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const InventoryMovementTypeOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    color: 'color',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy'
  };

  export type InventoryMovementTypeOrderByRelevanceFieldEnum = (typeof InventoryMovementTypeOrderByRelevanceFieldEnum)[keyof typeof InventoryMovementTypeOrderByRelevanceFieldEnum]


  export const InventoryOrderByRelevanceFieldEnum: {
    storageLocation: 'storageLocation',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type InventoryOrderByRelevanceFieldEnum = (typeof InventoryOrderByRelevanceFieldEnum)[keyof typeof InventoryOrderByRelevanceFieldEnum]


  export const InventoryMovementOrderByRelevanceFieldEnum: {
    movementTypeCode: 'movementTypeCode',
    reasonDescription: 'reasonDescription',
    userDocumentNumber: 'userDocumentNumber',
    createdBy: 'createdBy',
    updatedBy: 'updatedBy',
    deletedBy: 'deletedBy'
  };

  export type InventoryMovementOrderByRelevanceFieldEnum = (typeof InventoryMovementOrderByRelevanceFieldEnum)[keyof typeof InventoryMovementOrderByRelevanceFieldEnum]


  export const LogOrderByRelevanceFieldEnum: {
    entityName: 'entityName',
    entityId: 'entityId',
    action: 'action',
    message: 'message',
    userDocumentNumber: 'userDocumentNumber',
    customerDocumentNumber: 'customerDocumentNumber'
  };

  export type LogOrderByRelevanceFieldEnum = (typeof LogOrderByRelevanceFieldEnum)[keyof typeof LogOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type RestaurantConfigWhereInput = {
    AND?: RestaurantConfigWhereInput | RestaurantConfigWhereInput[]
    OR?: RestaurantConfigWhereInput[]
    NOT?: RestaurantConfigWhereInput | RestaurantConfigWhereInput[]
    id?: IntFilter<"RestaurantConfig"> | number
    name?: StringFilter<"RestaurantConfig"> | string
    activeLogoId?: IntNullableFilter<"RestaurantConfig"> | number | null
    currency?: StringFilter<"RestaurantConfig"> | string
    address?: StringNullableFilter<"RestaurantConfig"> | string | null
    phone?: StringNullableFilter<"RestaurantConfig"> | string | null
    email?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxName?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxIncluded?: BoolFilter<"RestaurantConfig"> | boolean
    taxType?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxRate?: DecimalNullableFilter<"RestaurantConfig"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"RestaurantConfig"> | Date | string
    createdBy?: StringFilter<"RestaurantConfig"> | string
    updatedAt?: DateTimeNullableFilter<"RestaurantConfig"> | Date | string | null
    updatedBy?: StringNullableFilter<"RestaurantConfig"> | string | null
  }

  export type RestaurantConfigOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    activeLogoId?: SortOrderInput | SortOrder
    currency?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxName?: SortOrderInput | SortOrder
    taxIncluded?: SortOrder
    taxType?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _relevance?: RestaurantConfigOrderByRelevanceInput
  }

  export type RestaurantConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RestaurantConfigWhereInput | RestaurantConfigWhereInput[]
    OR?: RestaurantConfigWhereInput[]
    NOT?: RestaurantConfigWhereInput | RestaurantConfigWhereInput[]
    name?: StringFilter<"RestaurantConfig"> | string
    activeLogoId?: IntNullableFilter<"RestaurantConfig"> | number | null
    currency?: StringFilter<"RestaurantConfig"> | string
    address?: StringNullableFilter<"RestaurantConfig"> | string | null
    phone?: StringNullableFilter<"RestaurantConfig"> | string | null
    email?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxName?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxIncluded?: BoolFilter<"RestaurantConfig"> | boolean
    taxType?: StringNullableFilter<"RestaurantConfig"> | string | null
    taxRate?: DecimalNullableFilter<"RestaurantConfig"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"RestaurantConfig"> | Date | string
    createdBy?: StringFilter<"RestaurantConfig"> | string
    updatedAt?: DateTimeNullableFilter<"RestaurantConfig"> | Date | string | null
    updatedBy?: StringNullableFilter<"RestaurantConfig"> | string | null
  }, "id">

  export type RestaurantConfigOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    activeLogoId?: SortOrderInput | SortOrder
    currency?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    taxName?: SortOrderInput | SortOrder
    taxIncluded?: SortOrder
    taxType?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: RestaurantConfigCountOrderByAggregateInput
    _avg?: RestaurantConfigAvgOrderByAggregateInput
    _max?: RestaurantConfigMaxOrderByAggregateInput
    _min?: RestaurantConfigMinOrderByAggregateInput
    _sum?: RestaurantConfigSumOrderByAggregateInput
  }

  export type RestaurantConfigScalarWhereWithAggregatesInput = {
    AND?: RestaurantConfigScalarWhereWithAggregatesInput | RestaurantConfigScalarWhereWithAggregatesInput[]
    OR?: RestaurantConfigScalarWhereWithAggregatesInput[]
    NOT?: RestaurantConfigScalarWhereWithAggregatesInput | RestaurantConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RestaurantConfig"> | number
    name?: StringWithAggregatesFilter<"RestaurantConfig"> | string
    activeLogoId?: IntNullableWithAggregatesFilter<"RestaurantConfig"> | number | null
    currency?: StringWithAggregatesFilter<"RestaurantConfig"> | string
    address?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
    phone?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
    email?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
    taxName?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
    taxIncluded?: BoolWithAggregatesFilter<"RestaurantConfig"> | boolean
    taxType?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
    taxRate?: DecimalNullableWithAggregatesFilter<"RestaurantConfig"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RestaurantConfig"> | Date | string
    createdBy?: StringWithAggregatesFilter<"RestaurantConfig"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RestaurantConfig"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"RestaurantConfig"> | string | null
  }

  export type ThemeWhereInput = {
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    name?: StringFilter<"Theme"> | string
    primaryColor?: StringFilter<"Theme"> | string
    secondaryColor?: StringFilter<"Theme"> | string
    accentColor?: StringFilter<"Theme"> | string
    neutralColor?: StringFilter<"Theme"> | string
    isSystem?: BoolFilter<"Theme"> | boolean
    isPublic?: BoolFilter<"Theme"> | boolean
    createdUserDocument?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    updatedBy?: StringNullableFilter<"Theme"> | string | null
    deletedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    deletedBy?: StringNullableFilter<"Theme"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usersUsingThisTheme?: UserListRelationFilter
    customerUsingThisTheme?: CustomerListRelationFilter
  }

  export type ThemeOrderByWithRelationInput = {
    name?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    accentColor?: SortOrder
    neutralColor?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    createdUserDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    usersUsingThisTheme?: UserOrderByRelationAggregateInput
    customerUsingThisTheme?: CustomerOrderByRelationAggregateInput
    _relevance?: ThemeOrderByRelevanceInput
  }

  export type ThemeWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    primaryColor?: StringFilter<"Theme"> | string
    secondaryColor?: StringFilter<"Theme"> | string
    accentColor?: StringFilter<"Theme"> | string
    neutralColor?: StringFilter<"Theme"> | string
    isSystem?: BoolFilter<"Theme"> | boolean
    isPublic?: BoolFilter<"Theme"> | boolean
    createdUserDocument?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    updatedBy?: StringNullableFilter<"Theme"> | string | null
    deletedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    deletedBy?: StringNullableFilter<"Theme"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    usersUsingThisTheme?: UserListRelationFilter
    customerUsingThisTheme?: CustomerListRelationFilter
  }, "name">

  export type ThemeOrderByWithAggregationInput = {
    name?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    accentColor?: SortOrder
    neutralColor?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    createdUserDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ThemeCountOrderByAggregateInput
    _max?: ThemeMaxOrderByAggregateInput
    _min?: ThemeMinOrderByAggregateInput
  }

  export type ThemeScalarWhereWithAggregatesInput = {
    AND?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    OR?: ThemeScalarWhereWithAggregatesInput[]
    NOT?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Theme"> | string
    primaryColor?: StringWithAggregatesFilter<"Theme"> | string
    secondaryColor?: StringWithAggregatesFilter<"Theme"> | string
    accentColor?: StringWithAggregatesFilter<"Theme"> | string
    neutralColor?: StringWithAggregatesFilter<"Theme"> | string
    isSystem?: BoolWithAggregatesFilter<"Theme"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Theme"> | boolean
    createdUserDocument?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Theme"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Theme"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Theme"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Theme"> | string | null
  }

  export type DocumentTypeWhereInput = {
    AND?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    OR?: DocumentTypeWhereInput[]
    NOT?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    name?: StringFilter<"DocumentType"> | string
    description?: StringNullableFilter<"DocumentType"> | string | null
    digitLength?: IntFilter<"DocumentType"> | number
    color?: StringNullableFilter<"DocumentType"> | string | null
    isActive?: BoolFilter<"DocumentType"> | boolean
    createdAt?: DateTimeFilter<"DocumentType"> | Date | string
    createdBy?: StringFilter<"DocumentType"> | string
    updatedAt?: DateTimeNullableFilter<"DocumentType"> | Date | string | null
    updatedBy?: StringNullableFilter<"DocumentType"> | string | null
    deletedAt?: DateTimeNullableFilter<"DocumentType"> | Date | string | null
    deletedBy?: StringNullableFilter<"DocumentType"> | string | null
    customers?: CustomerListRelationFilter
    users?: UserListRelationFilter
  }

  export type DocumentTypeOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    digitLength?: SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    customers?: CustomerOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: DocumentTypeOrderByRelevanceInput
  }

  export type DocumentTypeWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    OR?: DocumentTypeWhereInput[]
    NOT?: DocumentTypeWhereInput | DocumentTypeWhereInput[]
    description?: StringNullableFilter<"DocumentType"> | string | null
    digitLength?: IntFilter<"DocumentType"> | number
    color?: StringNullableFilter<"DocumentType"> | string | null
    isActive?: BoolFilter<"DocumentType"> | boolean
    createdAt?: DateTimeFilter<"DocumentType"> | Date | string
    createdBy?: StringFilter<"DocumentType"> | string
    updatedAt?: DateTimeNullableFilter<"DocumentType"> | Date | string | null
    updatedBy?: StringNullableFilter<"DocumentType"> | string | null
    deletedAt?: DateTimeNullableFilter<"DocumentType"> | Date | string | null
    deletedBy?: StringNullableFilter<"DocumentType"> | string | null
    customers?: CustomerListRelationFilter
    users?: UserListRelationFilter
  }, "name">

  export type DocumentTypeOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    digitLength?: SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: DocumentTypeCountOrderByAggregateInput
    _avg?: DocumentTypeAvgOrderByAggregateInput
    _max?: DocumentTypeMaxOrderByAggregateInput
    _min?: DocumentTypeMinOrderByAggregateInput
    _sum?: DocumentTypeSumOrderByAggregateInput
  }

  export type DocumentTypeScalarWhereWithAggregatesInput = {
    AND?: DocumentTypeScalarWhereWithAggregatesInput | DocumentTypeScalarWhereWithAggregatesInput[]
    OR?: DocumentTypeScalarWhereWithAggregatesInput[]
    NOT?: DocumentTypeScalarWhereWithAggregatesInput | DocumentTypeScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"DocumentType"> | string
    description?: StringNullableWithAggregatesFilter<"DocumentType"> | string | null
    digitLength?: IntWithAggregatesFilter<"DocumentType"> | number
    color?: StringNullableWithAggregatesFilter<"DocumentType"> | string | null
    isActive?: BoolWithAggregatesFilter<"DocumentType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DocumentType"> | Date | string
    createdBy?: StringWithAggregatesFilter<"DocumentType"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"DocumentType"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"DocumentType"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DocumentType"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"DocumentType"> | string | null
  }

  export type AccountStatusWhereInput = {
    AND?: AccountStatusWhereInput | AccountStatusWhereInput[]
    OR?: AccountStatusWhereInput[]
    NOT?: AccountStatusWhereInput | AccountStatusWhereInput[]
    code?: StringFilter<"AccountStatus"> | string
    name?: StringFilter<"AccountStatus"> | string
    description?: StringNullableFilter<"AccountStatus"> | string | null
    color?: StringNullableFilter<"AccountStatus"> | string | null
    createdAt?: DateTimeFilter<"AccountStatus"> | Date | string
    createdBy?: StringFilter<"AccountStatus"> | string
    updatedAt?: DateTimeNullableFilter<"AccountStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"AccountStatus"> | string | null
    users?: UserListRelationFilter
    customers?: CustomerListRelationFilter
  }

  export type AccountStatusOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    _relevance?: AccountStatusOrderByRelevanceInput
  }

  export type AccountStatusWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: AccountStatusWhereInput | AccountStatusWhereInput[]
    OR?: AccountStatusWhereInput[]
    NOT?: AccountStatusWhereInput | AccountStatusWhereInput[]
    name?: StringFilter<"AccountStatus"> | string
    description?: StringNullableFilter<"AccountStatus"> | string | null
    color?: StringNullableFilter<"AccountStatus"> | string | null
    createdAt?: DateTimeFilter<"AccountStatus"> | Date | string
    createdBy?: StringFilter<"AccountStatus"> | string
    updatedAt?: DateTimeNullableFilter<"AccountStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"AccountStatus"> | string | null
    users?: UserListRelationFilter
    customers?: CustomerListRelationFilter
  }, "code">

  export type AccountStatusOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: AccountStatusCountOrderByAggregateInput
    _max?: AccountStatusMaxOrderByAggregateInput
    _min?: AccountStatusMinOrderByAggregateInput
  }

  export type AccountStatusScalarWhereWithAggregatesInput = {
    AND?: AccountStatusScalarWhereWithAggregatesInput | AccountStatusScalarWhereWithAggregatesInput[]
    OR?: AccountStatusScalarWhereWithAggregatesInput[]
    NOT?: AccountStatusScalarWhereWithAggregatesInput | AccountStatusScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"AccountStatus"> | string
    name?: StringWithAggregatesFilter<"AccountStatus"> | string
    description?: StringNullableWithAggregatesFilter<"AccountStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"AccountStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccountStatus"> | Date | string
    createdBy?: StringWithAggregatesFilter<"AccountStatus"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"AccountStatus"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"AccountStatus"> | string | null
  }

  export type PermissionCategoryWhereInput = {
    AND?: PermissionCategoryWhereInput | PermissionCategoryWhereInput[]
    OR?: PermissionCategoryWhereInput[]
    NOT?: PermissionCategoryWhereInput | PermissionCategoryWhereInput[]
    code?: StringFilter<"PermissionCategory"> | string
    name?: StringFilter<"PermissionCategory"> | string
    description?: StringNullableFilter<"PermissionCategory"> | string | null
    color?: StringNullableFilter<"PermissionCategory"> | string | null
    createdAt?: DateTimeFilter<"PermissionCategory"> | Date | string
    createdBy?: StringFilter<"PermissionCategory"> | string
    updatedAt?: DateTimeNullableFilter<"PermissionCategory"> | Date | string | null
    updatedBy?: StringNullableFilter<"PermissionCategory"> | string | null
    permissions?: PermissionListRelationFilter
  }

  export type PermissionCategoryOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    permissions?: PermissionOrderByRelationAggregateInput
    _relevance?: PermissionCategoryOrderByRelevanceInput
  }

  export type PermissionCategoryWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: PermissionCategoryWhereInput | PermissionCategoryWhereInput[]
    OR?: PermissionCategoryWhereInput[]
    NOT?: PermissionCategoryWhereInput | PermissionCategoryWhereInput[]
    name?: StringFilter<"PermissionCategory"> | string
    description?: StringNullableFilter<"PermissionCategory"> | string | null
    color?: StringNullableFilter<"PermissionCategory"> | string | null
    createdAt?: DateTimeFilter<"PermissionCategory"> | Date | string
    createdBy?: StringFilter<"PermissionCategory"> | string
    updatedAt?: DateTimeNullableFilter<"PermissionCategory"> | Date | string | null
    updatedBy?: StringNullableFilter<"PermissionCategory"> | string | null
    permissions?: PermissionListRelationFilter
  }, "code">

  export type PermissionCategoryOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PermissionCategoryCountOrderByAggregateInput
    _max?: PermissionCategoryMaxOrderByAggregateInput
    _min?: PermissionCategoryMinOrderByAggregateInput
  }

  export type PermissionCategoryScalarWhereWithAggregatesInput = {
    AND?: PermissionCategoryScalarWhereWithAggregatesInput | PermissionCategoryScalarWhereWithAggregatesInput[]
    OR?: PermissionCategoryScalarWhereWithAggregatesInput[]
    NOT?: PermissionCategoryScalarWhereWithAggregatesInput | PermissionCategoryScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"PermissionCategory"> | string
    name?: StringWithAggregatesFilter<"PermissionCategory"> | string
    description?: StringNullableWithAggregatesFilter<"PermissionCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"PermissionCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PermissionCategory"> | Date | string
    createdBy?: StringWithAggregatesFilter<"PermissionCategory"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PermissionCategory"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"PermissionCategory"> | string | null
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    code?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    categoryCode?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    createdBy?: StringFilter<"Permission"> | string
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedBy?: StringNullableFilter<"Permission"> | string | null
    category?: XOR<PermissionCategoryScalarRelationFilter, PermissionCategoryWhereInput>
    rolePermissions?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    category?: PermissionCategoryOrderByWithRelationInput
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    categoryCode?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    createdBy?: StringFilter<"Permission"> | string
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedBy?: StringNullableFilter<"Permission"> | string | null
    category?: XOR<PermissionCategoryScalarRelationFilter, PermissionCategoryWhereInput>
    rolePermissions?: RolePermissionListRelationFilter
  }, "code" | "name">

  export type PermissionOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    categoryCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    categoryCode?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Permission"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Permission"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    color?: StringNullableFilter<"Role"> | string | null
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    createdBy?: StringFilter<"Role"> | string
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    updatedBy?: StringNullableFilter<"Role"> | string | null
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableFilter<"Role"> | string | null
    rolePermissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    rolePermissions?: RolePermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    color?: StringNullableFilter<"Role"> | string | null
    isActive?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    createdBy?: StringFilter<"Role"> | string
    updatedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    updatedBy?: StringNullableFilter<"Role"> | string | null
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableFilter<"Role"> | string | null
    rolePermissions?: RolePermissionListRelationFilter
    users?: UserListRelationFilter
  }, "name">

  export type RoleOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    color?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isActive?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Role"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    permissionCode?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    createdBy?: StringFilter<"RolePermission"> | string
    updatedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    updatedBy?: StringNullableFilter<"RolePermission"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissionCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
    _relevance?: RolePermissionOrderByRelevanceInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleName_permissionCode?: RolePermissionRoleNamePermissionCodeCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleName?: StringFilter<"RolePermission"> | string
    permissionCode?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    createdBy?: StringFilter<"RolePermission"> | string
    updatedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    updatedBy?: StringNullableFilter<"RolePermission"> | string | null
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleName_permissionCode">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissionCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _avg?: RolePermissionAvgOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
    _sum?: RolePermissionSumOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermission"> | number
    roleName?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionCode?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
    createdBy?: StringWithAggregatesFilter<"RolePermission"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RolePermission"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"RolePermission"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    documentNumber?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    pin?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    hireDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    documentTypeName?: StringFilter<"User"> | string
    roleName?: StringFilter<"User"> | string
    accountStatusCode?: StringFilter<"User"> | string
    themeName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringFilter<"User"> | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    documentType?: XOR<DocumentTypeScalarRelationFilter, DocumentTypeWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    accountStatus?: XOR<AccountStatusScalarRelationFilter, AccountStatusWhereInput>
    theme?: XOR<ThemeNullableScalarRelationFilter, ThemeWhereInput> | null
    openedCashBoxes?: CashBoxListRelationFilter
    closedCashBoxes?: CashBoxListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    logs?: LogListRelationFilter
    sessions?: SessionListRelationFilter
    combinedTables?: CombineTableListRelationFilter
    releasedTables?: CombineTableListRelationFilter
    tablesSessionOpened?: TableSessionListRelationFilter
    tablesSessionClosed?: TableSessionListRelationFilter
    ordersCreated?: OrderListRelationFilter
    ordersClosed?: OrderListRelationFilter
    createdThemes?: ThemeListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    pin?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    documentTypeName?: SortOrder
    roleName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    documentType?: DocumentTypeOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    accountStatus?: AccountStatusOrderByWithRelationInput
    theme?: ThemeOrderByWithRelationInput
    openedCashBoxes?: CashBoxOrderByRelationAggregateInput
    closedCashBoxes?: CashBoxOrderByRelationAggregateInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    combinedTables?: CombineTableOrderByRelationAggregateInput
    releasedTables?: CombineTableOrderByRelationAggregateInput
    tablesSessionOpened?: TableSessionOrderByRelationAggregateInput
    tablesSessionClosed?: TableSessionOrderByRelationAggregateInput
    ordersCreated?: OrderOrderByRelationAggregateInput
    ordersClosed?: OrderOrderByRelationAggregateInput
    createdThemes?: ThemeOrderByRelationAggregateInput
    paymentsReceived?: PaymentOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    documentNumber?: string
    username?: string
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    pin?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    hireDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    documentTypeName?: StringFilter<"User"> | string
    roleName?: StringFilter<"User"> | string
    accountStatusCode?: StringFilter<"User"> | string
    themeName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringFilter<"User"> | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    documentType?: XOR<DocumentTypeScalarRelationFilter, DocumentTypeWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    accountStatus?: XOR<AccountStatusScalarRelationFilter, AccountStatusWhereInput>
    theme?: XOR<ThemeNullableScalarRelationFilter, ThemeWhereInput> | null
    openedCashBoxes?: CashBoxListRelationFilter
    closedCashBoxes?: CashBoxListRelationFilter
    inventoryMovements?: InventoryMovementListRelationFilter
    logs?: LogListRelationFilter
    sessions?: SessionListRelationFilter
    combinedTables?: CombineTableListRelationFilter
    releasedTables?: CombineTableListRelationFilter
    tablesSessionOpened?: TableSessionListRelationFilter
    tablesSessionClosed?: TableSessionListRelationFilter
    ordersCreated?: OrderListRelationFilter
    ordersClosed?: OrderListRelationFilter
    createdThemes?: ThemeListRelationFilter
    paymentsReceived?: PaymentListRelationFilter
  }, "documentNumber" | "username" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    pin?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    hireDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    documentTypeName?: SortOrder
    roleName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    documentNumber?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    pin?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    hireDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    salary?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    documentTypeName?: StringWithAggregatesFilter<"User"> | string
    roleName?: StringWithAggregatesFilter<"User"> | string
    accountStatusCode?: StringWithAggregatesFilter<"User"> | string
    themeName?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdBy?: StringWithAggregatesFilter<"User"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userDocumentNumber?: StringNullableFilter<"Session"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Session"> | string | null
    token?: StringFilter<"Session"> | string
    deviceInfo?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isActive?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    closedBy?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    updatedBy?: StringNullableFilter<"Session"> | string | null
    deletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    deletedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userDocumentNumber?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrderInput | SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userDocumentNumber?: StringNullableFilter<"Session"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Session"> | string | null
    deviceInfo?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isActive?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    closedBy?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    updatedBy?: StringNullableFilter<"Session"> | string | null
    deletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    deletedBy?: StringNullableFilter<"Session"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userDocumentNumber?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrderInput | SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    closedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userDocumentNumber?: StringNullableWithAggregatesFilter<"Session"> | string | null
    customerDocumentNumber?: StringNullableWithAggregatesFilter<"Session"> | string | null
    token?: StringWithAggregatesFilter<"Session"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    isActive?: BoolWithAggregatesFilter<"Session"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    closedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Session"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Session"> | string | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    documentNumber?: StringFilter<"Customer"> | string
    username?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    password?: StringNullableFilter<"Customer"> | string | null
    fullName?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    documentTypeName?: StringFilter<"Customer"> | string
    accountStatusCode?: StringFilter<"Customer"> | string
    themeName?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: StringFilter<"Customer"> | string
    updatedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    updatedBy?: StringNullableFilter<"Customer"> | string | null
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deletedBy?: StringNullableFilter<"Customer"> | string | null
    documentType?: XOR<DocumentTypeScalarRelationFilter, DocumentTypeWhereInput>
    accountStatus?: XOR<AccountStatusScalarRelationFilter, AccountStatusWhereInput>
    theme?: XOR<ThemeNullableScalarRelationFilter, ThemeWhereInput> | null
    sessions?: SessionListRelationFilter
    orders?: OrderListRelationFilter
    logs?: LogListRelationFilter
    paymentsMade?: PaymentListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    documentNumber?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    documentTypeName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    documentType?: DocumentTypeOrderByWithRelationInput
    accountStatus?: AccountStatusOrderByWithRelationInput
    theme?: ThemeOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    paymentsMade?: PaymentOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    documentNumber?: string
    username?: string
    email?: string
    phoneNumber?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    password?: StringNullableFilter<"Customer"> | string | null
    fullName?: StringFilter<"Customer"> | string
    documentTypeName?: StringFilter<"Customer"> | string
    accountStatusCode?: StringFilter<"Customer"> | string
    themeName?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: StringFilter<"Customer"> | string
    updatedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    updatedBy?: StringNullableFilter<"Customer"> | string | null
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deletedBy?: StringNullableFilter<"Customer"> | string | null
    documentType?: XOR<DocumentTypeScalarRelationFilter, DocumentTypeWhereInput>
    accountStatus?: XOR<AccountStatusScalarRelationFilter, AccountStatusWhereInput>
    theme?: XOR<ThemeNullableScalarRelationFilter, ThemeWhereInput> | null
    sessions?: SessionListRelationFilter
    orders?: OrderListRelationFilter
    logs?: LogListRelationFilter
    paymentsMade?: PaymentListRelationFilter
  }, "documentNumber" | "username" | "email" | "phoneNumber">

  export type CustomerOrderByWithAggregationInput = {
    documentNumber?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    documentTypeName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    documentNumber?: StringWithAggregatesFilter<"Customer"> | string
    username?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    password?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    fullName?: StringWithAggregatesFilter<"Customer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    documentTypeName?: StringWithAggregatesFilter<"Customer"> | string
    accountStatusCode?: StringWithAggregatesFilter<"Customer"> | string
    themeName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Customer"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type CashBoxWhereInput = {
    AND?: CashBoxWhereInput | CashBoxWhereInput[]
    OR?: CashBoxWhereInput[]
    NOT?: CashBoxWhereInput | CashBoxWhereInput[]
    id?: IntFilter<"CashBox"> | number
    openerUserDocument?: StringFilter<"CashBox"> | string
    openedAt?: DateTimeFilter<"CashBox"> | Date | string
    initialAmount?: DecimalFilter<"CashBox"> | Decimal | DecimalJsLike | number | string
    closerUserDocument?: StringNullableFilter<"CashBox"> | string | null
    closedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    finalAmount?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    totalSales?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"CashBox"> | string | null
    updatedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    updatedBy?: StringNullableFilter<"CashBox"> | string | null
    deletedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    deletedBy?: StringNullableFilter<"CashBox"> | string | null
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
  }

  export type CashBoxOrderByWithRelationInput = {
    id?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    initialAmount?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    totalSales?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    opener?: UserOrderByWithRelationInput
    closer?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: CashBoxOrderByRelevanceInput
  }

  export type CashBoxWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CashBoxWhereInput | CashBoxWhereInput[]
    OR?: CashBoxWhereInput[]
    NOT?: CashBoxWhereInput | CashBoxWhereInput[]
    openerUserDocument?: StringFilter<"CashBox"> | string
    openedAt?: DateTimeFilter<"CashBox"> | Date | string
    initialAmount?: DecimalFilter<"CashBox"> | Decimal | DecimalJsLike | number | string
    closerUserDocument?: StringNullableFilter<"CashBox"> | string | null
    closedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    finalAmount?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    totalSales?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"CashBox"> | string | null
    updatedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    updatedBy?: StringNullableFilter<"CashBox"> | string | null
    deletedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    deletedBy?: StringNullableFilter<"CashBox"> | string | null
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payments?: PaymentListRelationFilter
  }, "id">

  export type CashBoxOrderByWithAggregationInput = {
    id?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    initialAmount?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    finalAmount?: SortOrderInput | SortOrder
    totalSales?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: CashBoxCountOrderByAggregateInput
    _avg?: CashBoxAvgOrderByAggregateInput
    _max?: CashBoxMaxOrderByAggregateInput
    _min?: CashBoxMinOrderByAggregateInput
    _sum?: CashBoxSumOrderByAggregateInput
  }

  export type CashBoxScalarWhereWithAggregatesInput = {
    AND?: CashBoxScalarWhereWithAggregatesInput | CashBoxScalarWhereWithAggregatesInput[]
    OR?: CashBoxScalarWhereWithAggregatesInput[]
    NOT?: CashBoxScalarWhereWithAggregatesInput | CashBoxScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CashBox"> | number
    openerUserDocument?: StringWithAggregatesFilter<"CashBox"> | string
    openedAt?: DateTimeWithAggregatesFilter<"CashBox"> | Date | string
    initialAmount?: DecimalWithAggregatesFilter<"CashBox"> | Decimal | DecimalJsLike | number | string
    closerUserDocument?: StringNullableWithAggregatesFilter<"CashBox"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"CashBox"> | Date | string | null
    finalAmount?: DecimalNullableWithAggregatesFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    totalSales?: DecimalNullableWithAggregatesFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"CashBox"> | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CashBox"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"CashBox"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CashBox"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"CashBox"> | string | null
  }

  export type TableStatusWhereInput = {
    AND?: TableStatusWhereInput | TableStatusWhereInput[]
    OR?: TableStatusWhereInput[]
    NOT?: TableStatusWhereInput | TableStatusWhereInput[]
    code?: StringFilter<"TableStatus"> | string
    name?: StringFilter<"TableStatus"> | string
    description?: StringNullableFilter<"TableStatus"> | string | null
    color?: StringNullableFilter<"TableStatus"> | string | null
    createdAt?: DateTimeFilter<"TableStatus"> | Date | string
    createdBy?: StringFilter<"TableStatus"> | string
    updatedAt?: DateTimeNullableFilter<"TableStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"TableStatus"> | string | null
    tables?: TableListRelationFilter
  }

  export type TableStatusOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    tables?: TableOrderByRelationAggregateInput
    _relevance?: TableStatusOrderByRelevanceInput
  }

  export type TableStatusWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: TableStatusWhereInput | TableStatusWhereInput[]
    OR?: TableStatusWhereInput[]
    NOT?: TableStatusWhereInput | TableStatusWhereInput[]
    name?: StringFilter<"TableStatus"> | string
    description?: StringNullableFilter<"TableStatus"> | string | null
    color?: StringNullableFilter<"TableStatus"> | string | null
    createdAt?: DateTimeFilter<"TableStatus"> | Date | string
    createdBy?: StringFilter<"TableStatus"> | string
    updatedAt?: DateTimeNullableFilter<"TableStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"TableStatus"> | string | null
    tables?: TableListRelationFilter
  }, "code">

  export type TableStatusOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: TableStatusCountOrderByAggregateInput
    _max?: TableStatusMaxOrderByAggregateInput
    _min?: TableStatusMinOrderByAggregateInput
  }

  export type TableStatusScalarWhereWithAggregatesInput = {
    AND?: TableStatusScalarWhereWithAggregatesInput | TableStatusScalarWhereWithAggregatesInput[]
    OR?: TableStatusScalarWhereWithAggregatesInput[]
    NOT?: TableStatusScalarWhereWithAggregatesInput | TableStatusScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"TableStatus"> | string
    name?: StringWithAggregatesFilter<"TableStatus"> | string
    description?: StringNullableWithAggregatesFilter<"TableStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"TableStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TableStatus"> | Date | string
    createdBy?: StringWithAggregatesFilter<"TableStatus"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TableStatus"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"TableStatus"> | string | null
  }

  export type RestaurantZoneWhereInput = {
    AND?: RestaurantZoneWhereInput | RestaurantZoneWhereInput[]
    OR?: RestaurantZoneWhereInput[]
    NOT?: RestaurantZoneWhereInput | RestaurantZoneWhereInput[]
    name?: StringFilter<"RestaurantZone"> | string
    description?: StringNullableFilter<"RestaurantZone"> | string | null
    color?: StringNullableFilter<"RestaurantZone"> | string | null
    isActive?: BoolFilter<"RestaurantZone"> | boolean
    createdAt?: DateTimeFilter<"RestaurantZone"> | Date | string
    createdBy?: StringFilter<"RestaurantZone"> | string
    updatedAt?: DateTimeNullableFilter<"RestaurantZone"> | Date | string | null
    updatedBy?: StringNullableFilter<"RestaurantZone"> | string | null
    deletedAt?: DateTimeNullableFilter<"RestaurantZone"> | Date | string | null
    deletedBy?: StringNullableFilter<"RestaurantZone"> | string | null
    tables?: TableListRelationFilter
  }

  export type RestaurantZoneOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    tables?: TableOrderByRelationAggregateInput
    _relevance?: RestaurantZoneOrderByRelevanceInput
  }

  export type RestaurantZoneWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: RestaurantZoneWhereInput | RestaurantZoneWhereInput[]
    OR?: RestaurantZoneWhereInput[]
    NOT?: RestaurantZoneWhereInput | RestaurantZoneWhereInput[]
    description?: StringNullableFilter<"RestaurantZone"> | string | null
    color?: StringNullableFilter<"RestaurantZone"> | string | null
    isActive?: BoolFilter<"RestaurantZone"> | boolean
    createdAt?: DateTimeFilter<"RestaurantZone"> | Date | string
    createdBy?: StringFilter<"RestaurantZone"> | string
    updatedAt?: DateTimeNullableFilter<"RestaurantZone"> | Date | string | null
    updatedBy?: StringNullableFilter<"RestaurantZone"> | string | null
    deletedAt?: DateTimeNullableFilter<"RestaurantZone"> | Date | string | null
    deletedBy?: StringNullableFilter<"RestaurantZone"> | string | null
    tables?: TableListRelationFilter
  }, "name">

  export type RestaurantZoneOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: RestaurantZoneCountOrderByAggregateInput
    _max?: RestaurantZoneMaxOrderByAggregateInput
    _min?: RestaurantZoneMinOrderByAggregateInput
  }

  export type RestaurantZoneScalarWhereWithAggregatesInput = {
    AND?: RestaurantZoneScalarWhereWithAggregatesInput | RestaurantZoneScalarWhereWithAggregatesInput[]
    OR?: RestaurantZoneScalarWhereWithAggregatesInput[]
    NOT?: RestaurantZoneScalarWhereWithAggregatesInput | RestaurantZoneScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"RestaurantZone"> | string
    description?: StringNullableWithAggregatesFilter<"RestaurantZone"> | string | null
    color?: StringNullableWithAggregatesFilter<"RestaurantZone"> | string | null
    isActive?: BoolWithAggregatesFilter<"RestaurantZone"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RestaurantZone"> | Date | string
    createdBy?: StringWithAggregatesFilter<"RestaurantZone"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RestaurantZone"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"RestaurantZone"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RestaurantZone"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"RestaurantZone"> | string | null
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    id?: IntFilter<"Table"> | number
    name?: StringFilter<"Table"> | string
    capacity?: IntFilter<"Table"> | number
    zoneName?: StringNullableFilter<"Table"> | string | null
    statusCode?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    createdBy?: StringFilter<"Table"> | string
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedBy?: StringNullableFilter<"Table"> | string | null
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    deletedBy?: StringNullableFilter<"Table"> | string | null
    zone?: XOR<RestaurantZoneNullableScalarRelationFilter, RestaurantZoneWhereInput> | null
    status?: XOR<TableStatusScalarRelationFilter, TableStatusWhereInput>
    tableSessions?: TableSessionListRelationFilter
    combineTableItems?: CombineTableItemListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    zoneName?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    zone?: RestaurantZoneOrderByWithRelationInput
    status?: TableStatusOrderByWithRelationInput
    tableSessions?: TableSessionOrderByRelationAggregateInput
    combineTableItems?: CombineTableItemOrderByRelationAggregateInput
    _relevance?: TableOrderByRelevanceInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    capacity?: IntFilter<"Table"> | number
    zoneName?: StringNullableFilter<"Table"> | string | null
    statusCode?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    createdBy?: StringFilter<"Table"> | string
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedBy?: StringNullableFilter<"Table"> | string | null
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    deletedBy?: StringNullableFilter<"Table"> | string | null
    zone?: XOR<RestaurantZoneNullableScalarRelationFilter, RestaurantZoneWhereInput> | null
    status?: XOR<TableStatusScalarRelationFilter, TableStatusWhereInput>
    tableSessions?: TableSessionListRelationFilter
    combineTableItems?: CombineTableItemListRelationFilter
  }, "id" | "name">

  export type TableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    zoneName?: SortOrderInput | SortOrder
    statusCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: TableCountOrderByAggregateInput
    _avg?: TableAvgOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
    _sum?: TableSumOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Table"> | number
    name?: StringWithAggregatesFilter<"Table"> | string
    capacity?: IntWithAggregatesFilter<"Table"> | number
    zoneName?: StringNullableWithAggregatesFilter<"Table"> | string | null
    statusCode?: StringWithAggregatesFilter<"Table"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Table"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Table"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Table"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Table"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Table"> | string | null
  }

  export type CombineTableWhereInput = {
    AND?: CombineTableWhereInput | CombineTableWhereInput[]
    OR?: CombineTableWhereInput[]
    NOT?: CombineTableWhereInput | CombineTableWhereInput[]
    id?: IntFilter<"CombineTable"> | number
    name?: StringFilter<"CombineTable"> | string
    combinerUserDocument?: StringFilter<"CombineTable"> | string
    combineAt?: DateTimeFilter<"CombineTable"> | Date | string
    isActive?: BoolFilter<"CombineTable"> | boolean
    releaserUserDocument?: StringNullableFilter<"CombineTable"> | string | null
    releasedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTable"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTable"> | string | null
    combiner?: XOR<UserScalarRelationFilter, UserWhereInput>
    releaser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tables?: CombineTableItemListRelationFilter
    tableSessions?: TableSessionListRelationFilter
  }

  export type CombineTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    combinerUserDocument?: SortOrder
    combineAt?: SortOrder
    isActive?: SortOrder
    releaserUserDocument?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    combiner?: UserOrderByWithRelationInput
    releaser?: UserOrderByWithRelationInput
    tables?: CombineTableItemOrderByRelationAggregateInput
    tableSessions?: TableSessionOrderByRelationAggregateInput
    _relevance?: CombineTableOrderByRelevanceInput
  }

  export type CombineTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CombineTableWhereInput | CombineTableWhereInput[]
    OR?: CombineTableWhereInput[]
    NOT?: CombineTableWhereInput | CombineTableWhereInput[]
    name?: StringFilter<"CombineTable"> | string
    combinerUserDocument?: StringFilter<"CombineTable"> | string
    combineAt?: DateTimeFilter<"CombineTable"> | Date | string
    isActive?: BoolFilter<"CombineTable"> | boolean
    releaserUserDocument?: StringNullableFilter<"CombineTable"> | string | null
    releasedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTable"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTable"> | string | null
    combiner?: XOR<UserScalarRelationFilter, UserWhereInput>
    releaser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tables?: CombineTableItemListRelationFilter
    tableSessions?: TableSessionListRelationFilter
  }, "id">

  export type CombineTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    combinerUserDocument?: SortOrder
    combineAt?: SortOrder
    isActive?: SortOrder
    releaserUserDocument?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: CombineTableCountOrderByAggregateInput
    _avg?: CombineTableAvgOrderByAggregateInput
    _max?: CombineTableMaxOrderByAggregateInput
    _min?: CombineTableMinOrderByAggregateInput
    _sum?: CombineTableSumOrderByAggregateInput
  }

  export type CombineTableScalarWhereWithAggregatesInput = {
    AND?: CombineTableScalarWhereWithAggregatesInput | CombineTableScalarWhereWithAggregatesInput[]
    OR?: CombineTableScalarWhereWithAggregatesInput[]
    NOT?: CombineTableScalarWhereWithAggregatesInput | CombineTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CombineTable"> | number
    name?: StringWithAggregatesFilter<"CombineTable"> | string
    combinerUserDocument?: StringWithAggregatesFilter<"CombineTable"> | string
    combineAt?: DateTimeWithAggregatesFilter<"CombineTable"> | Date | string
    isActive?: BoolWithAggregatesFilter<"CombineTable"> | boolean
    releaserUserDocument?: StringNullableWithAggregatesFilter<"CombineTable"> | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"CombineTable"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CombineTable"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"CombineTable"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CombineTable"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"CombineTable"> | string | null
  }

  export type CombineTableItemWhereInput = {
    AND?: CombineTableItemWhereInput | CombineTableItemWhereInput[]
    OR?: CombineTableItemWhereInput[]
    NOT?: CombineTableItemWhereInput | CombineTableItemWhereInput[]
    id?: IntFilter<"CombineTableItem"> | number
    combineTableId?: IntFilter<"CombineTableItem"> | number
    tableId?: IntFilter<"CombineTableItem"> | number
    createdAt?: DateTimeFilter<"CombineTableItem"> | Date | string
    createdBy?: StringFilter<"CombineTableItem"> | string
    updatedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTableItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTableItem"> | string | null
    combineTable?: XOR<CombineTableScalarRelationFilter, CombineTableWhereInput>
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }

  export type CombineTableItemOrderByWithRelationInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    combineTable?: CombineTableOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    _relevance?: CombineTableItemOrderByRelevanceInput
  }

  export type CombineTableItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    combineTableId_tableId?: CombineTableItemCombineTableIdTableIdCompoundUniqueInput
    AND?: CombineTableItemWhereInput | CombineTableItemWhereInput[]
    OR?: CombineTableItemWhereInput[]
    NOT?: CombineTableItemWhereInput | CombineTableItemWhereInput[]
    combineTableId?: IntFilter<"CombineTableItem"> | number
    tableId?: IntFilter<"CombineTableItem"> | number
    createdAt?: DateTimeFilter<"CombineTableItem"> | Date | string
    createdBy?: StringFilter<"CombineTableItem"> | string
    updatedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTableItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTableItem"> | string | null
    combineTable?: XOR<CombineTableScalarRelationFilter, CombineTableWhereInput>
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
  }, "id" | "combineTableId_tableId">

  export type CombineTableItemOrderByWithAggregationInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: CombineTableItemCountOrderByAggregateInput
    _avg?: CombineTableItemAvgOrderByAggregateInput
    _max?: CombineTableItemMaxOrderByAggregateInput
    _min?: CombineTableItemMinOrderByAggregateInput
    _sum?: CombineTableItemSumOrderByAggregateInput
  }

  export type CombineTableItemScalarWhereWithAggregatesInput = {
    AND?: CombineTableItemScalarWhereWithAggregatesInput | CombineTableItemScalarWhereWithAggregatesInput[]
    OR?: CombineTableItemScalarWhereWithAggregatesInput[]
    NOT?: CombineTableItemScalarWhereWithAggregatesInput | CombineTableItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CombineTableItem"> | number
    combineTableId?: IntWithAggregatesFilter<"CombineTableItem"> | number
    tableId?: IntWithAggregatesFilter<"CombineTableItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CombineTableItem"> | Date | string
    createdBy?: StringWithAggregatesFilter<"CombineTableItem"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"CombineTableItem"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"CombineTableItem"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CombineTableItem"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"CombineTableItem"> | string | null
  }

  export type TableSessionWhereInput = {
    AND?: TableSessionWhereInput | TableSessionWhereInput[]
    OR?: TableSessionWhereInput[]
    NOT?: TableSessionWhereInput | TableSessionWhereInput[]
    id?: IntFilter<"TableSession"> | number
    tableId?: IntNullableFilter<"TableSession"> | number | null
    combineTableId?: IntNullableFilter<"TableSession"> | number | null
    openerUserDocument?: StringFilter<"TableSession"> | string
    openedAt?: DateTimeFilter<"TableSession"> | Date | string
    numberPeople?: IntFilter<"TableSession"> | number
    isActive?: BoolFilter<"TableSession"> | boolean
    closerUserDocument?: StringNullableFilter<"TableSession"> | string | null
    closedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedBy?: StringNullableFilter<"TableSession"> | string | null
    deletedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    deletedBy?: StringNullableFilter<"TableSession"> | string | null
    table?: XOR<TableNullableScalarRelationFilter, TableWhereInput> | null
    combineTable?: XOR<CombineTableNullableScalarRelationFilter, CombineTableWhereInput> | null
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orders?: OrderListRelationFilter
  }

  export type TableSessionOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrderInput | SortOrder
    combineTableId?: SortOrderInput | SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    numberPeople?: SortOrder
    isActive?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    table?: TableOrderByWithRelationInput
    combineTable?: CombineTableOrderByWithRelationInput
    opener?: UserOrderByWithRelationInput
    closer?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    _relevance?: TableSessionOrderByRelevanceInput
  }

  export type TableSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tableId_combineTableId_isActive?: TableSessionTableIdCombineTableIdIsActiveCompoundUniqueInput
    AND?: TableSessionWhereInput | TableSessionWhereInput[]
    OR?: TableSessionWhereInput[]
    NOT?: TableSessionWhereInput | TableSessionWhereInput[]
    tableId?: IntNullableFilter<"TableSession"> | number | null
    combineTableId?: IntNullableFilter<"TableSession"> | number | null
    openerUserDocument?: StringFilter<"TableSession"> | string
    openedAt?: DateTimeFilter<"TableSession"> | Date | string
    numberPeople?: IntFilter<"TableSession"> | number
    isActive?: BoolFilter<"TableSession"> | boolean
    closerUserDocument?: StringNullableFilter<"TableSession"> | string | null
    closedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedBy?: StringNullableFilter<"TableSession"> | string | null
    deletedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    deletedBy?: StringNullableFilter<"TableSession"> | string | null
    table?: XOR<TableNullableScalarRelationFilter, TableWhereInput> | null
    combineTable?: XOR<CombineTableNullableScalarRelationFilter, CombineTableWhereInput> | null
    opener?: XOR<UserScalarRelationFilter, UserWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orders?: OrderListRelationFilter
  }, "id" | "tableId_combineTableId_isActive">

  export type TableSessionOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrderInput | SortOrder
    combineTableId?: SortOrderInput | SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    numberPeople?: SortOrder
    isActive?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: TableSessionCountOrderByAggregateInput
    _avg?: TableSessionAvgOrderByAggregateInput
    _max?: TableSessionMaxOrderByAggregateInput
    _min?: TableSessionMinOrderByAggregateInput
    _sum?: TableSessionSumOrderByAggregateInput
  }

  export type TableSessionScalarWhereWithAggregatesInput = {
    AND?: TableSessionScalarWhereWithAggregatesInput | TableSessionScalarWhereWithAggregatesInput[]
    OR?: TableSessionScalarWhereWithAggregatesInput[]
    NOT?: TableSessionScalarWhereWithAggregatesInput | TableSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TableSession"> | number
    tableId?: IntNullableWithAggregatesFilter<"TableSession"> | number | null
    combineTableId?: IntNullableWithAggregatesFilter<"TableSession"> | number | null
    openerUserDocument?: StringWithAggregatesFilter<"TableSession"> | string
    openedAt?: DateTimeWithAggregatesFilter<"TableSession"> | Date | string
    numberPeople?: IntWithAggregatesFilter<"TableSession"> | number
    isActive?: BoolWithAggregatesFilter<"TableSession"> | boolean
    closerUserDocument?: StringNullableWithAggregatesFilter<"TableSession"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"TableSession"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TableSession"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"TableSession"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TableSession"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"TableSession"> | string | null
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    name?: StringFilter<"Image"> | string
    altText?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    imageableId?: IntFilter<"Image"> | number
    imageableType?: StringFilter<"Image"> | string
    isActive?: BoolFilter<"Image"> | boolean
    createdAt?: DateTimeFilter<"Image"> | Date | string
    createdBy?: StringFilter<"Image"> | string
    updatedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    updatedBy?: StringNullableFilter<"Image"> | string | null
    deletedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    deletedBy?: StringNullableFilter<"Image"> | string | null
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    altText?: SortOrder
    url?: SortOrder
    imageableId?: SortOrder
    imageableType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _relevance?: ImageOrderByRelevanceInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    name?: StringFilter<"Image"> | string
    altText?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    imageableId?: IntFilter<"Image"> | number
    imageableType?: StringFilter<"Image"> | string
    isActive?: BoolFilter<"Image"> | boolean
    createdAt?: DateTimeFilter<"Image"> | Date | string
    createdBy?: StringFilter<"Image"> | string
    updatedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    updatedBy?: StringNullableFilter<"Image"> | string | null
    deletedAt?: DateTimeNullableFilter<"Image"> | Date | string | null
    deletedBy?: StringNullableFilter<"Image"> | string | null
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    altText?: SortOrder
    url?: SortOrder
    imageableId?: SortOrder
    imageableType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    name?: StringWithAggregatesFilter<"Image"> | string
    altText?: StringWithAggregatesFilter<"Image"> | string
    url?: StringWithAggregatesFilter<"Image"> | string
    imageableId?: IntWithAggregatesFilter<"Image"> | number
    imageableType?: StringWithAggregatesFilter<"Image"> | string
    isActive?: BoolWithAggregatesFilter<"Image"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Image"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Image"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Image"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Image"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Image"> | string | null
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    description?: StringNullableFilter<"Brand"> | string | null
    color?: StringNullableFilter<"Brand"> | string | null
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    createdBy?: StringFilter<"Brand"> | string
    updatedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    updatedBy?: StringNullableFilter<"Brand"> | string | null
    deletedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    deletedBy?: StringNullableFilter<"Brand"> | string | null
    products?: ProductListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    _relevance?: BrandOrderByRelevanceInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    description?: StringNullableFilter<"Brand"> | string | null
    color?: StringNullableFilter<"Brand"> | string | null
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    createdBy?: StringFilter<"Brand"> | string
    updatedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    updatedBy?: StringNullableFilter<"Brand"> | string | null
    deletedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    deletedBy?: StringNullableFilter<"Brand"> | string | null
    products?: ProductListRelationFilter
  }, "name">

  export type BrandOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Brand"> | string
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    color?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    isActive?: BoolWithAggregatesFilter<"Brand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Brand"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Brand"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Brand"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Brand"> | string | null
  }

  export type ProductStatusWhereInput = {
    AND?: ProductStatusWhereInput | ProductStatusWhereInput[]
    OR?: ProductStatusWhereInput[]
    NOT?: ProductStatusWhereInput | ProductStatusWhereInput[]
    code?: StringFilter<"ProductStatus"> | string
    name?: StringFilter<"ProductStatus"> | string
    description?: StringNullableFilter<"ProductStatus"> | string | null
    color?: StringNullableFilter<"ProductStatus"> | string | null
    createdAt?: DateTimeFilter<"ProductStatus"> | Date | string
    createdBy?: StringFilter<"ProductStatus"> | string
    updatedAt?: DateTimeNullableFilter<"ProductStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductStatus"> | string | null
    products?: ProductListRelationFilter
  }

  export type ProductStatusOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    _relevance?: ProductStatusOrderByRelevanceInput
  }

  export type ProductStatusWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: ProductStatusWhereInput | ProductStatusWhereInput[]
    OR?: ProductStatusWhereInput[]
    NOT?: ProductStatusWhereInput | ProductStatusWhereInput[]
    description?: StringNullableFilter<"ProductStatus"> | string | null
    color?: StringNullableFilter<"ProductStatus"> | string | null
    createdAt?: DateTimeFilter<"ProductStatus"> | Date | string
    createdBy?: StringFilter<"ProductStatus"> | string
    updatedAt?: DateTimeNullableFilter<"ProductStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductStatus"> | string | null
    products?: ProductListRelationFilter
  }, "code" | "name">

  export type ProductStatusOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: ProductStatusCountOrderByAggregateInput
    _max?: ProductStatusMaxOrderByAggregateInput
    _min?: ProductStatusMinOrderByAggregateInput
  }

  export type ProductStatusScalarWhereWithAggregatesInput = {
    AND?: ProductStatusScalarWhereWithAggregatesInput | ProductStatusScalarWhereWithAggregatesInput[]
    OR?: ProductStatusScalarWhereWithAggregatesInput[]
    NOT?: ProductStatusScalarWhereWithAggregatesInput | ProductStatusScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"ProductStatus"> | string
    name?: StringWithAggregatesFilter<"ProductStatus"> | string
    description?: StringNullableWithAggregatesFilter<"ProductStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductStatus"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductStatus"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductStatus"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ProductStatus"> | string | null
  }

  export type ProductTypeWhereInput = {
    AND?: ProductTypeWhereInput | ProductTypeWhereInput[]
    OR?: ProductTypeWhereInput[]
    NOT?: ProductTypeWhereInput | ProductTypeWhereInput[]
    name?: StringFilter<"ProductType"> | string
    description?: StringNullableFilter<"ProductType"> | string | null
    color?: StringNullableFilter<"ProductType"> | string | null
    isActive?: BoolFilter<"ProductType"> | boolean
    createdAt?: DateTimeFilter<"ProductType"> | Date | string
    createdBy?: StringFilter<"ProductType"> | string
    updatedAt?: DateTimeNullableFilter<"ProductType"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductType"> | string | null
    deletedAt?: DateTimeNullableFilter<"ProductType"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductType"> | string | null
    products?: ProductListRelationFilter
  }

  export type ProductTypeOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    _relevance?: ProductTypeOrderByRelevanceInput
  }

  export type ProductTypeWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: ProductTypeWhereInput | ProductTypeWhereInput[]
    OR?: ProductTypeWhereInput[]
    NOT?: ProductTypeWhereInput | ProductTypeWhereInput[]
    description?: StringNullableFilter<"ProductType"> | string | null
    color?: StringNullableFilter<"ProductType"> | string | null
    isActive?: BoolFilter<"ProductType"> | boolean
    createdAt?: DateTimeFilter<"ProductType"> | Date | string
    createdBy?: StringFilter<"ProductType"> | string
    updatedAt?: DateTimeNullableFilter<"ProductType"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductType"> | string | null
    deletedAt?: DateTimeNullableFilter<"ProductType"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductType"> | string | null
    products?: ProductListRelationFilter
  }, "name">

  export type ProductTypeOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ProductTypeCountOrderByAggregateInput
    _max?: ProductTypeMaxOrderByAggregateInput
    _min?: ProductTypeMinOrderByAggregateInput
  }

  export type ProductTypeScalarWhereWithAggregatesInput = {
    AND?: ProductTypeScalarWhereWithAggregatesInput | ProductTypeScalarWhereWithAggregatesInput[]
    OR?: ProductTypeScalarWhereWithAggregatesInput[]
    NOT?: ProductTypeScalarWhereWithAggregatesInput | ProductTypeScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"ProductType"> | string
    description?: StringNullableWithAggregatesFilter<"ProductType"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductType"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductType"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductType"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductType"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ProductType"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProductType"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ProductType"> | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    name?: StringFilter<"ProductCategory"> | string
    description?: StringNullableFilter<"ProductCategory"> | string | null
    color?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    createdBy?: StringFilter<"ProductCategory"> | string
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductCategory"> | string | null
    deletedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductCategory"> | string | null
    products?: ProductListRelationFilter
  }

  export type ProductCategoryOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
    _relevance?: ProductCategoryOrderByRelevanceInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    description?: StringNullableFilter<"ProductCategory"> | string | null
    color?: StringNullableFilter<"ProductCategory"> | string | null
    isActive?: BoolFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    createdBy?: StringFilter<"ProductCategory"> | string
    updatedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    updatedBy?: StringNullableFilter<"ProductCategory"> | string | null
    deletedAt?: DateTimeNullableFilter<"ProductCategory"> | Date | string | null
    deletedBy?: StringNullableFilter<"ProductCategory"> | string | null
    products?: ProductListRelationFilter
  }, "name">

  export type ProductCategoryOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"ProductCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    createdBy?: StringWithAggregatesFilter<"ProductCategory"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ProductCategory"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProductCategory"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"ProductCategory"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    offerPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFilter<"Product"> | string
    productCategoryName?: StringFilter<"Product"> | string
    brandName?: StringNullableFilter<"Product"> | string | null
    productStatusCode?: StringFilter<"Product"> | string
    mainImageId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    createdBy?: StringFilter<"Product"> | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedBy?: StringNullableFilter<"Product"> | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableFilter<"Product"> | string | null
    productType?: XOR<ProductTypeScalarRelationFilter, ProductTypeWhereInput>
    productCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    productStatus?: XOR<ProductStatusScalarRelationFilter, ProductStatusWhereInput>
    inventories?: InventoryListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    productTypeName?: SortOrder
    productCategoryName?: SortOrder
    brandName?: SortOrderInput | SortOrder
    productStatusCode?: SortOrder
    mainImageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    productType?: ProductTypeOrderByWithRelationInput
    productCategory?: ProductCategoryOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    productStatus?: ProductStatusOrderByWithRelationInput
    inventories?: InventoryOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    _relevance?: ProductOrderByRelevanceInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    offerPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFilter<"Product"> | string
    productCategoryName?: StringFilter<"Product"> | string
    brandName?: StringNullableFilter<"Product"> | string | null
    productStatusCode?: StringFilter<"Product"> | string
    mainImageId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    createdBy?: StringFilter<"Product"> | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedBy?: StringNullableFilter<"Product"> | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableFilter<"Product"> | string | null
    productType?: XOR<ProductTypeScalarRelationFilter, ProductTypeWhereInput>
    productCategory?: XOR<ProductCategoryScalarRelationFilter, ProductCategoryWhereInput>
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    productStatus?: XOR<ProductStatusScalarRelationFilter, ProductStatusWhereInput>
    inventories?: InventoryListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    offerPrice?: SortOrderInput | SortOrder
    productTypeName?: SortOrder
    productCategoryName?: SortOrder
    brandName?: SortOrderInput | SortOrder
    productStatusCode?: SortOrder
    mainImageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    offerPrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringWithAggregatesFilter<"Product"> | string
    productCategoryName?: StringWithAggregatesFilter<"Product"> | string
    brandName?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productStatusCode?: StringWithAggregatesFilter<"Product"> | string
    mainImageId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Product"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Product"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type OrderStatusWhereInput = {
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    code?: StringFilter<"OrderStatus"> | string
    name?: StringFilter<"OrderStatus"> | string
    description?: StringNullableFilter<"OrderStatus"> | string | null
    color?: StringNullableFilter<"OrderStatus"> | string | null
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    createdBy?: StringFilter<"OrderStatus"> | string
    updatedAt?: DateTimeNullableFilter<"OrderStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderStatus"> | string | null
    orders?: OrderListRelationFilter
  }

  export type OrderStatusOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    orders?: OrderOrderByRelationAggregateInput
    _relevance?: OrderStatusOrderByRelevanceInput
  }

  export type OrderStatusWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    description?: StringNullableFilter<"OrderStatus"> | string | null
    color?: StringNullableFilter<"OrderStatus"> | string | null
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    createdBy?: StringFilter<"OrderStatus"> | string
    updatedAt?: DateTimeNullableFilter<"OrderStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderStatus"> | string | null
    orders?: OrderListRelationFilter
  }, "code" | "name">

  export type OrderStatusOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrderStatusCountOrderByAggregateInput
    _max?: OrderStatusMaxOrderByAggregateInput
    _min?: OrderStatusMinOrderByAggregateInput
  }

  export type OrderStatusScalarWhereWithAggregatesInput = {
    AND?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    OR?: OrderStatusScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"OrderStatus"> | string
    name?: StringWithAggregatesFilter<"OrderStatus"> | string
    description?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderStatus"> | Date | string
    createdBy?: StringWithAggregatesFilter<"OrderStatus"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderStatus"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
  }

  export type OrderItemStatusWhereInput = {
    AND?: OrderItemStatusWhereInput | OrderItemStatusWhereInput[]
    OR?: OrderItemStatusWhereInput[]
    NOT?: OrderItemStatusWhereInput | OrderItemStatusWhereInput[]
    code?: StringFilter<"OrderItemStatus"> | string
    name?: StringFilter<"OrderItemStatus"> | string
    description?: StringNullableFilter<"OrderItemStatus"> | string | null
    color?: StringNullableFilter<"OrderItemStatus"> | string | null
    createdAt?: DateTimeFilter<"OrderItemStatus"> | Date | string
    createdBy?: StringFilter<"OrderItemStatus"> | string
    updatedAt?: DateTimeNullableFilter<"OrderItemStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderItemStatus"> | string | null
    orderItems?: OrderItemListRelationFilter
  }

  export type OrderItemStatusOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    _relevance?: OrderItemStatusOrderByRelevanceInput
  }

  export type OrderItemStatusWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: OrderItemStatusWhereInput | OrderItemStatusWhereInput[]
    OR?: OrderItemStatusWhereInput[]
    NOT?: OrderItemStatusWhereInput | OrderItemStatusWhereInput[]
    description?: StringNullableFilter<"OrderItemStatus"> | string | null
    color?: StringNullableFilter<"OrderItemStatus"> | string | null
    createdAt?: DateTimeFilter<"OrderItemStatus"> | Date | string
    createdBy?: StringFilter<"OrderItemStatus"> | string
    updatedAt?: DateTimeNullableFilter<"OrderItemStatus"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderItemStatus"> | string | null
    orderItems?: OrderItemListRelationFilter
  }, "code" | "name">

  export type OrderItemStatusOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: OrderItemStatusCountOrderByAggregateInput
    _max?: OrderItemStatusMaxOrderByAggregateInput
    _min?: OrderItemStatusMinOrderByAggregateInput
  }

  export type OrderItemStatusScalarWhereWithAggregatesInput = {
    AND?: OrderItemStatusScalarWhereWithAggregatesInput | OrderItemStatusScalarWhereWithAggregatesInput[]
    OR?: OrderItemStatusScalarWhereWithAggregatesInput[]
    NOT?: OrderItemStatusScalarWhereWithAggregatesInput | OrderItemStatusScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"OrderItemStatus"> | string
    name?: StringWithAggregatesFilter<"OrderItemStatus"> | string
    description?: StringNullableWithAggregatesFilter<"OrderItemStatus"> | string | null
    color?: StringNullableWithAggregatesFilter<"OrderItemStatus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItemStatus"> | Date | string
    createdBy?: StringWithAggregatesFilter<"OrderItemStatus"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderItemStatus"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"OrderItemStatus"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    code?: StringFilter<"Order"> | string
    tableSessionId?: IntNullableFilter<"Order"> | number | null
    creatorUserDocument?: StringFilter<"Order"> | string
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerDocumentNumber?: StringFilter<"Order"> | string
    subtotalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"Order"> | string
    closerUserDocument?: StringNullableFilter<"Order"> | string | null
    closedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deletedBy?: StringNullableFilter<"Order"> | string | null
    tableSession?: XOR<TableSessionNullableScalarRelationFilter, TableSessionWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    code?: SortOrder
    tableSessionId?: SortOrderInput | SortOrder
    creatorUserDocument?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    statusCode?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    tableSession?: TableSessionOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    status?: OrderStatusOrderByWithRelationInput
    closer?: UserOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    payment?: PaymentOrderByWithRelationInput
    _relevance?: OrderOrderByRelevanceInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    tableSessionId?: IntNullableFilter<"Order"> | number | null
    creatorUserDocument?: StringFilter<"Order"> | string
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerDocumentNumber?: StringFilter<"Order"> | string
    subtotalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"Order"> | string
    closerUserDocument?: StringNullableFilter<"Order"> | string | null
    closedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deletedBy?: StringNullableFilter<"Order"> | string | null
    tableSession?: XOR<TableSessionNullableScalarRelationFilter, TableSessionWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    closer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
  }, "code">

  export type OrderOrderByWithAggregationInput = {
    code?: SortOrder
    tableSessionId?: SortOrderInput | SortOrder
    creatorUserDocument?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    statusCode?: SortOrder
    closerUserDocument?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Order"> | string
    tableSessionId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    creatorUserDocument?: StringWithAggregatesFilter<"Order"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    customerDocumentNumber?: StringWithAggregatesFilter<"Order"> | string
    subtotalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringWithAggregatesFilter<"Order"> | string
    closerUserDocument?: StringNullableWithAggregatesFilter<"Order"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderCode?: StringFilter<"OrderItem"> | string
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"OrderItem"> | string
    specialInstructions?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    createdBy?: StringFilter<"OrderItem"> | string
    updatedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    status?: XOR<OrderItemStatusScalarRelationFilter, OrderItemStatusWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderCode?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    statusCode?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    status?: OrderItemStatusOrderByWithRelationInput
    _relevance?: OrderItemOrderByRelevanceInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderCode?: StringFilter<"OrderItem"> | string
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"OrderItem"> | string
    specialInstructions?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    createdBy?: StringFilter<"OrderItem"> | string
    updatedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"OrderItem"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    status?: XOR<OrderItemStatusScalarRelationFilter, OrderItemStatusWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderCode?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    statusCode?: SortOrder
    specialInstructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderCode?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringWithAggregatesFilter<"OrderItem"> | string
    specialInstructions?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    createdBy?: StringWithAggregatesFilter<"OrderItem"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"OrderItem"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    name?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    color?: StringNullableFilter<"PaymentMethod"> | string | null
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    createdBy?: StringFilter<"PaymentMethod"> | string
    updatedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    updatedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    deletedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    deletedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    payments?: PaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    payments?: PaymentOrderByRelationAggregateInput
    _relevance?: PaymentMethodOrderByRelevanceInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    color?: StringNullableFilter<"PaymentMethod"> | string | null
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    createdBy?: StringFilter<"PaymentMethod"> | string
    updatedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    updatedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    deletedAt?: DateTimeNullableFilter<"PaymentMethod"> | Date | string | null
    deletedBy?: StringNullableFilter<"PaymentMethod"> | string | null
    payments?: PaymentListRelationFilter
  }, "name">

  export type PaymentMethodOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"PaymentMethod"> | string
    description?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    color?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    createdBy?: StringWithAggregatesFilter<"PaymentMethod"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PaymentMethod"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    orderCode?: StringFilter<"Payment"> | string
    cashBoxId?: IntFilter<"Payment"> | number
    totalAmount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFilter<"Payment"> | string
    receivedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    changeAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receiveUserDocument?: StringFilter<"Payment"> | string
    paidCustomerDocument?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringFilter<"Payment"> | string
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedBy?: StringNullableFilter<"Payment"> | string | null
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    cashBox?: XOR<CashBoxScalarRelationFilter, CashBoxWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    receiveUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    paidCustomer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderCode?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    paymentMethodName?: SortOrder
    receivedAmount?: SortOrderInput | SortOrder
    changeAmount?: SortOrderInput | SortOrder
    transactionNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receiveUserDocument?: SortOrder
    paidCustomerDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    cashBox?: CashBoxOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    receiveUser?: UserOrderByWithRelationInput
    paidCustomer?: CustomerOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderCode?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    cashBoxId?: IntFilter<"Payment"> | number
    totalAmount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFilter<"Payment"> | string
    receivedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    changeAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receiveUserDocument?: StringFilter<"Payment"> | string
    paidCustomerDocument?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringFilter<"Payment"> | string
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedBy?: StringNullableFilter<"Payment"> | string | null
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    cashBox?: XOR<CashBoxScalarRelationFilter, CashBoxWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    receiveUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    paidCustomer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "orderCode">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderCode?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    paymentMethodName?: SortOrder
    receivedAmount?: SortOrderInput | SortOrder
    changeAmount?: SortOrderInput | SortOrder
    transactionNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receiveUserDocument?: SortOrder
    paidCustomerDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    orderCode?: StringWithAggregatesFilter<"Payment"> | string
    cashBoxId?: IntWithAggregatesFilter<"Payment"> | number
    totalAmount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringWithAggregatesFilter<"Payment"> | string
    receivedAmount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    changeAmount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiveUserDocument?: StringWithAggregatesFilter<"Payment"> | string
    paidCustomerDocument?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Payment"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Payment"> | string | null
  }

  export type InventoryMovementTypeWhereInput = {
    AND?: InventoryMovementTypeWhereInput | InventoryMovementTypeWhereInput[]
    OR?: InventoryMovementTypeWhereInput[]
    NOT?: InventoryMovementTypeWhereInput | InventoryMovementTypeWhereInput[]
    code?: StringFilter<"InventoryMovementType"> | string
    name?: StringFilter<"InventoryMovementType"> | string
    description?: StringNullableFilter<"InventoryMovementType"> | string | null
    color?: StringNullableFilter<"InventoryMovementType"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovementType"> | Date | string
    createdBy?: StringFilter<"InventoryMovementType"> | string
    updatedAt?: DateTimeNullableFilter<"InventoryMovementType"> | Date | string | null
    updatedBy?: StringNullableFilter<"InventoryMovementType"> | string | null
    movements?: InventoryMovementListRelationFilter
  }

  export type InventoryMovementTypeOrderByWithRelationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    movements?: InventoryMovementOrderByRelationAggregateInput
    _relevance?: InventoryMovementTypeOrderByRelevanceInput
  }

  export type InventoryMovementTypeWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    name?: string
    AND?: InventoryMovementTypeWhereInput | InventoryMovementTypeWhereInput[]
    OR?: InventoryMovementTypeWhereInput[]
    NOT?: InventoryMovementTypeWhereInput | InventoryMovementTypeWhereInput[]
    description?: StringNullableFilter<"InventoryMovementType"> | string | null
    color?: StringNullableFilter<"InventoryMovementType"> | string | null
    createdAt?: DateTimeFilter<"InventoryMovementType"> | Date | string
    createdBy?: StringFilter<"InventoryMovementType"> | string
    updatedAt?: DateTimeNullableFilter<"InventoryMovementType"> | Date | string | null
    updatedBy?: StringNullableFilter<"InventoryMovementType"> | string | null
    movements?: InventoryMovementListRelationFilter
  }, "code" | "name">

  export type InventoryMovementTypeOrderByWithAggregationInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: InventoryMovementTypeCountOrderByAggregateInput
    _max?: InventoryMovementTypeMaxOrderByAggregateInput
    _min?: InventoryMovementTypeMinOrderByAggregateInput
  }

  export type InventoryMovementTypeScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementTypeScalarWhereWithAggregatesInput | InventoryMovementTypeScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementTypeScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementTypeScalarWhereWithAggregatesInput | InventoryMovementTypeScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"InventoryMovementType"> | string
    name?: StringWithAggregatesFilter<"InventoryMovementType"> | string
    description?: StringNullableWithAggregatesFilter<"InventoryMovementType"> | string | null
    color?: StringNullableWithAggregatesFilter<"InventoryMovementType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovementType"> | Date | string
    createdBy?: StringWithAggregatesFilter<"InventoryMovementType"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"InventoryMovementType"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"InventoryMovementType"> | string | null
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    productId?: IntFilter<"Inventory"> | number
    currentQuantity?: IntFilter<"Inventory"> | number
    minimumStock?: IntFilter<"Inventory"> | number
    storageLocation?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    createdBy?: StringFilter<"Inventory"> | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    updatedBy?: StringNullableFilter<"Inventory"> | string | null
    deletedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    deletedBy?: StringNullableFilter<"Inventory"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryMovements?: InventoryMovementListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    inventoryMovements?: InventoryMovementOrderByRelationAggregateInput
    _relevance?: InventoryOrderByRelevanceInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    productId_storageLocation?: InventoryProductIdStorageLocationCompoundUniqueInput
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    productId?: IntFilter<"Inventory"> | number
    currentQuantity?: IntFilter<"Inventory"> | number
    minimumStock?: IntFilter<"Inventory"> | number
    storageLocation?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    createdBy?: StringFilter<"Inventory"> | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    updatedBy?: StringNullableFilter<"Inventory"> | string | null
    deletedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    deletedBy?: StringNullableFilter<"Inventory"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryMovements?: InventoryMovementListRelationFilter
  }, "id" | "productId_storageLocation">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
    storageLocation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    productId?: IntWithAggregatesFilter<"Inventory"> | number
    currentQuantity?: IntWithAggregatesFilter<"Inventory"> | number
    minimumStock?: IntWithAggregatesFilter<"Inventory"> | number
    storageLocation?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Inventory"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Inventory"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Inventory"> | string | null
  }

  export type InventoryMovementWhereInput = {
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    id?: IntFilter<"InventoryMovement"> | number
    inventoryId?: IntFilter<"InventoryMovement"> | number
    movementTypeCode?: StringFilter<"InventoryMovement"> | string
    quantityMovement?: IntFilter<"InventoryMovement"> | number
    reasonDescription?: StringFilter<"InventoryMovement"> | string
    userDocumentNumber?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    createdBy?: StringFilter<"InventoryMovement"> | string
    updatedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    updatedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    deletedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    deletedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    movementType?: XOR<InventoryMovementTypeScalarRelationFilter, InventoryMovementTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryMovementOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    movementTypeCode?: SortOrder
    quantityMovement?: SortOrder
    reasonDescription?: SortOrder
    userDocumentNumber?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    inventory?: InventoryOrderByWithRelationInput
    movementType?: InventoryMovementTypeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: InventoryMovementOrderByRelevanceInput
  }

  export type InventoryMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    OR?: InventoryMovementWhereInput[]
    NOT?: InventoryMovementWhereInput | InventoryMovementWhereInput[]
    inventoryId?: IntFilter<"InventoryMovement"> | number
    movementTypeCode?: StringFilter<"InventoryMovement"> | string
    quantityMovement?: IntFilter<"InventoryMovement"> | number
    reasonDescription?: StringFilter<"InventoryMovement"> | string
    userDocumentNumber?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    createdBy?: StringFilter<"InventoryMovement"> | string
    updatedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    updatedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    deletedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    deletedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    inventory?: XOR<InventoryScalarRelationFilter, InventoryWhereInput>
    movementType?: XOR<InventoryMovementTypeScalarRelationFilter, InventoryMovementTypeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryMovementOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    movementTypeCode?: SortOrder
    quantityMovement?: SortOrder
    reasonDescription?: SortOrder
    userDocumentNumber?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    updatedBy?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    _count?: InventoryMovementCountOrderByAggregateInput
    _avg?: InventoryMovementAvgOrderByAggregateInput
    _max?: InventoryMovementMaxOrderByAggregateInput
    _min?: InventoryMovementMinOrderByAggregateInput
    _sum?: InventoryMovementSumOrderByAggregateInput
  }

  export type InventoryMovementScalarWhereWithAggregatesInput = {
    AND?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    OR?: InventoryMovementScalarWhereWithAggregatesInput[]
    NOT?: InventoryMovementScalarWhereWithAggregatesInput | InventoryMovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InventoryMovement"> | number
    inventoryId?: IntWithAggregatesFilter<"InventoryMovement"> | number
    movementTypeCode?: StringWithAggregatesFilter<"InventoryMovement"> | string
    quantityMovement?: IntWithAggregatesFilter<"InventoryMovement"> | number
    reasonDescription?: StringWithAggregatesFilter<"InventoryMovement"> | string
    userDocumentNumber?: StringWithAggregatesFilter<"InventoryMovement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InventoryMovement"> | Date | string
    createdBy?: StringWithAggregatesFilter<"InventoryMovement"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"InventoryMovement"> | Date | string | null
    updatedBy?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"InventoryMovement"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"InventoryMovement"> | string | null
  }

  export type OrderSequenceWhereInput = {
    AND?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    OR?: OrderSequenceWhereInput[]
    NOT?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    id?: IntFilter<"OrderSequence"> | number
    sequenceYear?: IntFilter<"OrderSequence"> | number
    sequenceMonth?: IntFilter<"OrderSequence"> | number
    sequenceDay?: IntFilter<"OrderSequence"> | number
    lastOrderNumber?: IntFilter<"OrderSequence"> | number
    createdAt?: DateTimeFilter<"OrderSequence"> | Date | string
    updatedAt?: DateTimeNullableFilter<"OrderSequence"> | Date | string | null
  }

  export type OrderSequenceOrderByWithRelationInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type OrderSequenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sequenceYear_sequenceMonth_sequenceDay?: OrderSequenceSequenceYearSequenceMonthSequenceDayCompoundUniqueInput
    AND?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    OR?: OrderSequenceWhereInput[]
    NOT?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    sequenceYear?: IntFilter<"OrderSequence"> | number
    sequenceMonth?: IntFilter<"OrderSequence"> | number
    sequenceDay?: IntFilter<"OrderSequence"> | number
    lastOrderNumber?: IntFilter<"OrderSequence"> | number
    createdAt?: DateTimeFilter<"OrderSequence"> | Date | string
    updatedAt?: DateTimeNullableFilter<"OrderSequence"> | Date | string | null
  }, "id" | "sequenceYear_sequenceMonth_sequenceDay">

  export type OrderSequenceOrderByWithAggregationInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: OrderSequenceCountOrderByAggregateInput
    _avg?: OrderSequenceAvgOrderByAggregateInput
    _max?: OrderSequenceMaxOrderByAggregateInput
    _min?: OrderSequenceMinOrderByAggregateInput
    _sum?: OrderSequenceSumOrderByAggregateInput
  }

  export type OrderSequenceScalarWhereWithAggregatesInput = {
    AND?: OrderSequenceScalarWhereWithAggregatesInput | OrderSequenceScalarWhereWithAggregatesInput[]
    OR?: OrderSequenceScalarWhereWithAggregatesInput[]
    NOT?: OrderSequenceScalarWhereWithAggregatesInput | OrderSequenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderSequence"> | number
    sequenceYear?: IntWithAggregatesFilter<"OrderSequence"> | number
    sequenceMonth?: IntWithAggregatesFilter<"OrderSequence"> | number
    sequenceDay?: IntWithAggregatesFilter<"OrderSequence"> | number
    lastOrderNumber?: IntWithAggregatesFilter<"OrderSequence"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderSequence"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"OrderSequence"> | Date | string | null
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    entityName?: StringFilter<"Log"> | string
    entityId?: StringNullableFilter<"Log"> | string | null
    action?: StringFilter<"Log"> | string
    message?: StringNullableFilter<"Log"> | string | null
    userDocumentNumber?: StringNullableFilter<"Log"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    entityName?: SortOrder
    entityId?: SortOrderInput | SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    userDocumentNumber?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    _relevance?: LogOrderByRelevanceInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    entityName?: StringFilter<"Log"> | string
    entityId?: StringNullableFilter<"Log"> | string | null
    action?: StringFilter<"Log"> | string
    message?: StringNullableFilter<"Log"> | string | null
    userDocumentNumber?: StringNullableFilter<"Log"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    entityName?: SortOrder
    entityId?: SortOrderInput | SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    userDocumentNumber?: SortOrderInput | SortOrder
    customerDocumentNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    entityName?: StringWithAggregatesFilter<"Log"> | string
    entityId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    action?: StringWithAggregatesFilter<"Log"> | string
    message?: StringNullableWithAggregatesFilter<"Log"> | string | null
    userDocumentNumber?: StringNullableWithAggregatesFilter<"Log"> | string | null
    customerDocumentNumber?: StringNullableWithAggregatesFilter<"Log"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
  }

  export type RestaurantConfigCreateInput = {
    name: string
    activeLogoId?: number | null
    currency?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxName?: string | null
    taxIncluded?: boolean
    taxType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RestaurantConfigUncheckedCreateInput = {
    id?: number
    name: string
    activeLogoId?: number | null
    currency?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxName?: string | null
    taxIncluded?: boolean
    taxType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RestaurantConfigUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxIncluded?: BoolFieldUpdateOperationsInput | boolean
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    activeLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxIncluded?: BoolFieldUpdateOperationsInput | boolean
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantConfigCreateManyInput = {
    id?: number
    name: string
    activeLogoId?: number | null
    currency?: string
    address?: string | null
    phone?: string | null
    email?: string | null
    taxName?: string | null
    taxIncluded?: boolean
    taxType?: string | null
    taxRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RestaurantConfigUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxIncluded?: BoolFieldUpdateOperationsInput | boolean
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    activeLogoId?: NullableIntFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxName?: NullableStringFieldUpdateOperationsInput | string | null
    taxIncluded?: BoolFieldUpdateOperationsInput | boolean
    taxType?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThemeCreateInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    user?: UserCreateNestedOneWithoutCreatedThemesInput
    usersUsingThisTheme?: UserCreateNestedManyWithoutThemeInput
    customerUsingThisTheme?: CustomerCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    usersUsingThisTheme?: UserUncheckedCreateNestedManyWithoutThemeInput
    customerUsingThisTheme?: CustomerUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCreatedThemesNestedInput
    usersUsingThisTheme?: UserUpdateManyWithoutThemeNestedInput
    customerUsingThisTheme?: CustomerUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usersUsingThisTheme?: UserUncheckedUpdateManyWithoutThemeNestedInput
    customerUsingThisTheme?: CustomerUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ThemeCreateManyInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ThemeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThemeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTypeCreateInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customers?: CustomerCreateNestedManyWithoutDocumentTypeInput
    users?: UserCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customers?: CustomerUncheckedCreateNestedManyWithoutDocumentTypeInput
    users?: UserUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateManyWithoutDocumentTypeNestedInput
    users?: UserUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUncheckedUpdateManyWithoutDocumentTypeNestedInput
    users?: UserUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeCreateManyInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type DocumentTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTypeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountStatusCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    users?: UserCreateNestedManyWithoutAccountStatusInput
    customers?: CustomerCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutAccountStatusInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutAccountStatusNestedInput
    customers?: CustomerUpdateManyWithoutAccountStatusNestedInput
  }

  export type AccountStatusUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutAccountStatusNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAccountStatusNestedInput
  }

  export type AccountStatusCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type AccountStatusUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountStatusUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCategoryCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    permissions?: PermissionCreateNestedManyWithoutCategoryInput
  }

  export type PermissionCategoryUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type PermissionCategoryUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUpdateManyWithoutCategoryNestedInput
  }

  export type PermissionCategoryUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: PermissionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type PermissionCategoryCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionCategoryUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCategoryUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    category: PermissionCategoryCreateNestedOneWithoutPermissionsInput
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    categoryCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    category?: PermissionCategoryUpdateOneRequiredWithoutPermissionsNestedInput
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    code: string
    name: string
    description?: string | null
    categoryCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    role: RoleCreateNestedOneWithoutRolePermissionsInput
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: number
    roleName: string
    permissionCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RolePermissionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyInput = {
    id?: number
    roleName: string
    permissionCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RolePermissionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUpdateInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserCreateManyInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserUpdateManyMutationInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    user?: UserCreateNestedOneWithoutSessionsInput
    customer?: CustomerCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userDocumentNumber?: string | null
    customerDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutSessionsNestedInput
    customer?: CustomerUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userDocumentNumber?: string | null
    customerDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUpdateInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashBoxCreateInput = {
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    opener: UserCreateNestedOneWithoutOpenedCashBoxesInput
    closer?: UserCreateNestedOneWithoutClosedCashBoxesInput
    payments?: PaymentCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxUncheckedCreateInput = {
    id?: number
    openerUserDocument: string
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxUpdateInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    opener?: UserUpdateOneRequiredWithoutOpenedCashBoxesNestedInput
    closer?: UserUpdateOneWithoutClosedCashBoxesNestedInput
    payments?: PaymentUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxCreateManyInput = {
    id?: number
    openerUserDocument: string
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CashBoxUpdateManyMutationInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashBoxUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableStatusCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    tables?: TableCreateNestedManyWithoutStatusInput
  }

  export type TableStatusUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    tables?: TableUncheckedCreateNestedManyWithoutStatusInput
  }

  export type TableStatusUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: TableUpdateManyWithoutStatusNestedInput
  }

  export type TableStatusUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: TableUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type TableStatusCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type TableStatusUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableStatusUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantZoneCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: TableCreateNestedManyWithoutZoneInput
  }

  export type RestaurantZoneUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: TableUncheckedCreateNestedManyWithoutZoneInput
  }

  export type RestaurantZoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: TableUpdateManyWithoutZoneNestedInput
  }

  export type RestaurantZoneUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: TableUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type RestaurantZoneCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RestaurantZoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantZoneUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableCreateInput = {
    name: string
    capacity?: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    zone?: RestaurantZoneCreateNestedOneWithoutTablesInput
    status?: TableStatusCreateNestedOneWithoutTablesInput
    tableSessions?: TableSessionCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: RestaurantZoneUpdateOneWithoutTablesNestedInput
    status?: TableStatusUpdateOneRequiredWithoutTablesNestedInput
    tableSessions?: TableSessionUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSessions?: TableSessionUncheckedUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableCreateInput = {
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combiner: UserCreateNestedOneWithoutCombinedTablesInput
    releaser?: UserCreateNestedOneWithoutReleasedTablesInput
    tables?: CombineTableItemCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUncheckedCreateInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: CombineTableItemUncheckedCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combiner?: UserUpdateOneRequiredWithoutCombinedTablesNestedInput
    releaser?: UserUpdateOneWithoutReleasedTablesNestedInput
    tables?: CombineTableItemUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: CombineTableItemUncheckedUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUncheckedUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableCreateManyInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemCreateInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combineTable: CombineTableCreateNestedOneWithoutTablesInput
    table: TableCreateNestedOneWithoutCombineTableItemsInput
  }

  export type CombineTableItemUncheckedCreateInput = {
    id?: number
    combineTableId: number
    tableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combineTable?: CombineTableUpdateOneRequiredWithoutTablesNestedInput
    table?: TableUpdateOneRequiredWithoutCombineTableItemsNestedInput
  }

  export type CombineTableItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemCreateManyInput = {
    id?: number
    combineTableId: number
    tableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionCreateInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table?: TableCreateNestedOneWithoutTableSessionsInput
    combineTable?: CombineTableCreateNestedOneWithoutTableSessionsInput
    opener: UserCreateNestedOneWithoutTablesSessionOpenedInput
    closer?: UserCreateNestedOneWithoutTablesSessionClosedInput
    orders?: OrderCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUncheckedCreateInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUpdateInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutTableSessionsNestedInput
    combineTable?: CombineTableUpdateOneWithoutTableSessionsNestedInput
    opener?: UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput
    closer?: UserUpdateOneWithoutTablesSessionClosedNestedInput
    orders?: OrderUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionCreateManyInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionUpdateManyMutationInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageCreateInput = {
    name: string
    altText: string
    url: string
    imageableId: number
    imageableType: string
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    name: string
    altText: string
    url: string
    imageableId: number
    imageableType: string
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ImageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    imageableId?: IntFieldUpdateOperationsInput | number
    imageableType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    imageableId?: IntFieldUpdateOperationsInput | number
    imageableType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageCreateManyInput = {
    id?: number
    name: string
    altText: string
    url: string
    imageableId: number
    imageableType: string
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ImageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    imageableId?: IntFieldUpdateOperationsInput | number
    imageableType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    altText?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    imageableId?: IntFieldUpdateOperationsInput | number
    imageableType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BrandUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductStatusCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    products?: ProductCreateNestedManyWithoutProductStatusInput
  }

  export type ProductStatusUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutProductStatusInput
  }

  export type ProductStatusUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutProductStatusNestedInput
  }

  export type ProductStatusUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutProductStatusNestedInput
  }

  export type ProductStatusCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ProductStatusUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductStatusUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTypeCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTypeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutProductCategoryInput
  }

  export type ProductCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutProductCategoryNestedInput
  }

  export type ProductCategoryCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    orders?: OrderCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderStatusUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemStatusCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutStatusInput
  }

  export type OrderItemStatusUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutStatusInput
  }

  export type OrderItemStatusUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutStatusNestedInput
  }

  export type OrderItemStatusUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type OrderItemStatusCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderItemStatusUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemStatusUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
    status?: OrderItemStatusCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderCode: string
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    status?: OrderItemStatusUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderCode: string
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentMethodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutPaymentInput
    cashBox: CashBoxCreateNestedOneWithoutPaymentsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
    receiveUser: UserCreateNestedOneWithoutPaymentsReceivedInput
    paidCustomer?: CustomerCreateNestedOneWithoutPaymentsMadeInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
    cashBox?: CashBoxUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    receiveUser?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    paidCustomer?: CustomerUpdateOneWithoutPaymentsMadeNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateManyMutationInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementTypeCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    movements?: InventoryMovementCreateNestedManyWithoutMovementTypeInput
  }

  export type InventoryMovementTypeUncheckedCreateInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    movements?: InventoryMovementUncheckedCreateNestedManyWithoutMovementTypeInput
  }

  export type InventoryMovementTypeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    movements?: InventoryMovementUpdateManyWithoutMovementTypeNestedInput
  }

  export type InventoryMovementTypeUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    movements?: InventoryMovementUncheckedUpdateManyWithoutMovementTypeNestedInput
  }

  export type InventoryMovementTypeCreateManyInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type InventoryMovementTypeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementTypeUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateInput = {
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    product: ProductCreateNestedOneWithoutInventoriesInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    productId: number
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutInventoriesNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: number
    productId: number
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryUpdateManyMutationInput = {
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementCreateInput = {
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventory: InventoryCreateNestedOneWithoutInventoryMovementsInput
    movementType: InventoryMovementTypeCreateNestedOneWithoutMovementsInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateInput = {
    id?: number
    inventoryId: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementUpdateInput = {
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: InventoryUpdateOneRequiredWithoutInventoryMovementsNestedInput
    movementType?: InventoryMovementTypeUpdateOneRequiredWithoutMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementCreateManyInput = {
    id?: number
    inventoryId: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementUpdateManyMutationInput = {
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderSequenceCreateInput = {
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
    lastOrderNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OrderSequenceUncheckedCreateInput = {
    id?: number
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
    lastOrderNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OrderSequenceUpdateInput = {
    sequenceYear?: IntFieldUpdateOperationsInput | number
    sequenceMonth?: IntFieldUpdateOperationsInput | number
    sequenceDay?: IntFieldUpdateOperationsInput | number
    lastOrderNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderSequenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequenceYear?: IntFieldUpdateOperationsInput | number
    sequenceMonth?: IntFieldUpdateOperationsInput | number
    sequenceDay?: IntFieldUpdateOperationsInput | number
    lastOrderNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderSequenceCreateManyInput = {
    id?: number
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
    lastOrderNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string | null
  }

  export type OrderSequenceUpdateManyMutationInput = {
    sequenceYear?: IntFieldUpdateOperationsInput | number
    sequenceMonth?: IntFieldUpdateOperationsInput | number
    sequenceDay?: IntFieldUpdateOperationsInput | number
    lastOrderNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderSequenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sequenceYear?: IntFieldUpdateOperationsInput | number
    sequenceMonth?: IntFieldUpdateOperationsInput | number
    sequenceDay?: IntFieldUpdateOperationsInput | number
    lastOrderNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogCreateInput = {
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
    customer?: CustomerCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    userDocumentNumber?: string | null
    customerDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type LogUpdateInput = {
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
    customer?: CustomerUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateManyInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    userDocumentNumber?: string | null
    customerDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type LogUpdateManyMutationInput = {
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RestaurantConfigOrderByRelevanceInput = {
    fields: RestaurantConfigOrderByRelevanceFieldEnum | RestaurantConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RestaurantConfigCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeLogoId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxName?: SortOrder
    taxIncluded?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RestaurantConfigAvgOrderByAggregateInput = {
    id?: SortOrder
    activeLogoId?: SortOrder
    taxRate?: SortOrder
  }

  export type RestaurantConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeLogoId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxName?: SortOrder
    taxIncluded?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RestaurantConfigMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeLogoId?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    taxName?: SortOrder
    taxIncluded?: SortOrder
    taxType?: SortOrder
    taxRate?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RestaurantConfigSumOrderByAggregateInput = {
    id?: SortOrder
    activeLogoId?: SortOrder
    taxRate?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeOrderByRelevanceInput = {
    fields: ThemeOrderByRelevanceFieldEnum | ThemeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ThemeCountOrderByAggregateInput = {
    name?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    accentColor?: SortOrder
    neutralColor?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    createdUserDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ThemeMaxOrderByAggregateInput = {
    name?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    accentColor?: SortOrder
    neutralColor?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    createdUserDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ThemeMinOrderByAggregateInput = {
    name?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    accentColor?: SortOrder
    neutralColor?: SortOrder
    isSystem?: SortOrder
    isPublic?: SortOrder
    createdUserDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentTypeOrderByRelevanceInput = {
    fields: DocumentTypeOrderByRelevanceFieldEnum | DocumentTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DocumentTypeCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    digitLength?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentTypeAvgOrderByAggregateInput = {
    digitLength?: SortOrder
  }

  export type DocumentTypeMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    digitLength?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentTypeMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    digitLength?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DocumentTypeSumOrderByAggregateInput = {
    digitLength?: SortOrder
  }

  export type AccountStatusOrderByRelevanceInput = {
    fields: AccountStatusOrderByRelevanceFieldEnum | AccountStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountStatusCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AccountStatusMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type AccountStatusMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCategoryOrderByRelevanceInput = {
    fields: PermissionCategoryOrderByRelevanceFieldEnum | PermissionCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionCategoryCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionCategoryMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionCategoryMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionCategoryScalarRelationFilter = {
    is?: PermissionCategoryWhereInput
    isNot?: PermissionCategoryWhereInput
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    categoryCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolePermissionRoleNamePermissionCodeCompoundUniqueInput = {
    roleName: string
    permissionCode: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissionCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RolePermissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissionCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleName?: SortOrder
    permissionCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RolePermissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocumentTypeScalarRelationFilter = {
    is?: DocumentTypeWhereInput
    isNot?: DocumentTypeWhereInput
  }

  export type AccountStatusScalarRelationFilter = {
    is?: AccountStatusWhereInput
    isNot?: AccountStatusWhereInput
  }

  export type ThemeNullableScalarRelationFilter = {
    is?: ThemeWhereInput | null
    isNot?: ThemeWhereInput | null
  }

  export type CashBoxListRelationFilter = {
    every?: CashBoxWhereInput
    some?: CashBoxWhereInput
    none?: CashBoxWhereInput
  }

  export type InventoryMovementListRelationFilter = {
    every?: InventoryMovementWhereInput
    some?: InventoryMovementWhereInput
    none?: InventoryMovementWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CombineTableListRelationFilter = {
    every?: CombineTableWhereInput
    some?: CombineTableWhereInput
    none?: CombineTableWhereInput
  }

  export type TableSessionListRelationFilter = {
    every?: TableSessionWhereInput
    some?: TableSessionWhereInput
    none?: TableSessionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ThemeListRelationFilter = {
    every?: ThemeWhereInput
    some?: ThemeWhereInput
    none?: ThemeWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type CashBoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CombineTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    documentTypeName?: SortOrder
    roleName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    documentTypeName?: SortOrder
    roleName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    birthDate?: SortOrder
    hireDate?: SortOrder
    salary?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    documentTypeName?: SortOrder
    roleName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    closedAt?: SortOrder
    closedBy?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    documentTypeName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    documentTypeName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    documentNumber?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    phoneNumber?: SortOrder
    documentTypeName?: SortOrder
    accountStatusCode?: SortOrder
    themeName?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CashBoxOrderByRelevanceInput = {
    fields: CashBoxOrderByRelevanceFieldEnum | CashBoxOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CashBoxCountOrderByAggregateInput = {
    id?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    initialAmount?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    finalAmount?: SortOrder
    totalSales?: SortOrder
    notes?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CashBoxAvgOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    finalAmount?: SortOrder
    totalSales?: SortOrder
  }

  export type CashBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    initialAmount?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    finalAmount?: SortOrder
    totalSales?: SortOrder
    notes?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CashBoxMinOrderByAggregateInput = {
    id?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    initialAmount?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    finalAmount?: SortOrder
    totalSales?: SortOrder
    notes?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CashBoxSumOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    finalAmount?: SortOrder
    totalSales?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableStatusOrderByRelevanceInput = {
    fields: TableStatusOrderByRelevanceFieldEnum | TableStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TableStatusCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TableStatusMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TableStatusMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type RestaurantZoneOrderByRelevanceInput = {
    fields: RestaurantZoneOrderByRelevanceFieldEnum | RestaurantZoneOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RestaurantZoneCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RestaurantZoneMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RestaurantZoneMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type RestaurantZoneNullableScalarRelationFilter = {
    is?: RestaurantZoneWhereInput | null
    isNot?: RestaurantZoneWhereInput | null
  }

  export type TableStatusScalarRelationFilter = {
    is?: TableStatusWhereInput
    isNot?: TableStatusWhereInput
  }

  export type CombineTableItemListRelationFilter = {
    every?: CombineTableItemWhereInput
    some?: CombineTableItemWhereInput
    none?: CombineTableItemWhereInput
  }

  export type CombineTableItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableOrderByRelevanceInput = {
    fields: TableOrderByRelevanceFieldEnum | TableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    zoneName?: SortOrder
    statusCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    zoneName?: SortOrder
    statusCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    zoneName?: SortOrder
    statusCode?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type CombineTableOrderByRelevanceInput = {
    fields: CombineTableOrderByRelevanceFieldEnum | CombineTableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CombineTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    combinerUserDocument?: SortOrder
    combineAt?: SortOrder
    isActive?: SortOrder
    releaserUserDocument?: SortOrder
    releasedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CombineTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    combinerUserDocument?: SortOrder
    combineAt?: SortOrder
    isActive?: SortOrder
    releaserUserDocument?: SortOrder
    releasedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    combinerUserDocument?: SortOrder
    combineAt?: SortOrder
    isActive?: SortOrder
    releaserUserDocument?: SortOrder
    releasedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CombineTableScalarRelationFilter = {
    is?: CombineTableWhereInput
    isNot?: CombineTableWhereInput
  }

  export type TableScalarRelationFilter = {
    is?: TableWhereInput
    isNot?: TableWhereInput
  }

  export type CombineTableItemOrderByRelevanceInput = {
    fields: CombineTableItemOrderByRelevanceFieldEnum | CombineTableItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CombineTableItemCombineTableIdTableIdCompoundUniqueInput = {
    combineTableId: number
    tableId: number
  }

  export type CombineTableItemCountOrderByAggregateInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableItemAvgOrderByAggregateInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
  }

  export type CombineTableItemMaxOrderByAggregateInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableItemMinOrderByAggregateInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CombineTableItemSumOrderByAggregateInput = {
    id?: SortOrder
    combineTableId?: SortOrder
    tableId?: SortOrder
  }

  export type TableNullableScalarRelationFilter = {
    is?: TableWhereInput | null
    isNot?: TableWhereInput | null
  }

  export type CombineTableNullableScalarRelationFilter = {
    is?: CombineTableWhereInput | null
    isNot?: CombineTableWhereInput | null
  }

  export type TableSessionOrderByRelevanceInput = {
    fields: TableSessionOrderByRelevanceFieldEnum | TableSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TableSessionTableIdCombineTableIdIsActiveCompoundUniqueInput = {
    tableId: number
    combineTableId: number
    isActive: boolean
  }

  export type TableSessionCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    combineTableId?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    numberPeople?: SortOrder
    isActive?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    combineTableId?: SortOrder
    numberPeople?: SortOrder
  }

  export type TableSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    combineTableId?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    numberPeople?: SortOrder
    isActive?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableSessionMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    combineTableId?: SortOrder
    openerUserDocument?: SortOrder
    openedAt?: SortOrder
    numberPeople?: SortOrder
    isActive?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type TableSessionSumOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    combineTableId?: SortOrder
    numberPeople?: SortOrder
  }

  export type ImageOrderByRelevanceInput = {
    fields: ImageOrderByRelevanceFieldEnum | ImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    altText?: SortOrder
    url?: SortOrder
    imageableId?: SortOrder
    imageableType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    imageableId?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    altText?: SortOrder
    url?: SortOrder
    imageableId?: SortOrder
    imageableType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    altText?: SortOrder
    url?: SortOrder
    imageableId?: SortOrder
    imageableType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    imageableId?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandOrderByRelevanceInput = {
    fields: BrandOrderByRelevanceFieldEnum | BrandOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BrandCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductStatusOrderByRelevanceInput = {
    fields: ProductStatusOrderByRelevanceFieldEnum | ProductStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductStatusCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductStatusMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductStatusMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type ProductTypeOrderByRelevanceInput = {
    fields: ProductTypeOrderByRelevanceFieldEnum | ProductTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductTypeCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductTypeMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductTypeMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductCategoryOrderByRelevanceInput = {
    fields: ProductCategoryOrderByRelevanceFieldEnum | ProductCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductTypeScalarRelationFilter = {
    is?: ProductTypeWhereInput
    isNot?: ProductTypeWhereInput
  }

  export type ProductCategoryScalarRelationFilter = {
    is?: ProductCategoryWhereInput
    isNot?: ProductCategoryWhereInput
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type ProductStatusScalarRelationFilter = {
    is?: ProductStatusWhereInput
    isNot?: ProductStatusWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelevanceInput = {
    fields: ProductOrderByRelevanceFieldEnum | ProductOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productTypeName?: SortOrder
    productCategoryName?: SortOrder
    brandName?: SortOrder
    productStatusCode?: SortOrder
    mainImageId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    mainImageId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productTypeName?: SortOrder
    productCategoryName?: SortOrder
    brandName?: SortOrder
    productStatusCode?: SortOrder
    mainImageId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    productTypeName?: SortOrder
    productCategoryName?: SortOrder
    brandName?: SortOrder
    productStatusCode?: SortOrder
    mainImageId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    offerPrice?: SortOrder
    mainImageId?: SortOrder
  }

  export type OrderStatusOrderByRelevanceInput = {
    fields: OrderStatusOrderByRelevanceFieldEnum | OrderStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderStatusCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderStatusMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderStatusMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderItemStatusOrderByRelevanceInput = {
    fields: OrderItemStatusOrderByRelevanceFieldEnum | OrderItemStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemStatusCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderItemStatusMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type OrderItemStatusMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type TableSessionNullableScalarRelationFilter = {
    is?: TableSessionWhereInput | null
    isNot?: TableSessionWhereInput | null
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type OrderStatusScalarRelationFilter = {
    is?: OrderStatusWhereInput
    isNot?: OrderStatusWhereInput
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type OrderOrderByRelevanceInput = {
    fields: OrderOrderByRelevanceFieldEnum | OrderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderCountOrderByAggregateInput = {
    code?: SortOrder
    tableSessionId?: SortOrder
    creatorUserDocument?: SortOrder
    createdAt?: SortOrder
    customerDocumentNumber?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    statusCode?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    tableSessionId?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    code?: SortOrder
    tableSessionId?: SortOrder
    creatorUserDocument?: SortOrder
    createdAt?: SortOrder
    customerDocumentNumber?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    statusCode?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    code?: SortOrder
    tableSessionId?: SortOrder
    creatorUserDocument?: SortOrder
    createdAt?: SortOrder
    customerDocumentNumber?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
    statusCode?: SortOrder
    closerUserDocument?: SortOrder
    closedAt?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    tableSessionId?: SortOrder
    subtotalAmount?: SortOrder
    taxAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type OrderItemStatusScalarRelationFilter = {
    is?: OrderItemStatusWhereInput
    isNot?: OrderItemStatusWhereInput
  }

  export type OrderItemOrderByRelevanceInput = {
    fields: OrderItemOrderByRelevanceFieldEnum | OrderItemOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    statusCode?: SortOrder
    specialInstructions?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    statusCode?: SortOrder
    specialInstructions?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
    statusCode?: SortOrder
    specialInstructions?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subTotal?: SortOrder
    discount?: SortOrder
  }

  export type PaymentMethodOrderByRelevanceInput = {
    fields: PaymentMethodOrderByRelevanceFieldEnum | PaymentMethodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type CashBoxScalarRelationFilter = {
    is?: CashBoxWhereInput
    isNot?: CashBoxWhereInput
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    paymentMethodName?: SortOrder
    receivedAmount?: SortOrder
    changeAmount?: SortOrder
    transactionNumber?: SortOrder
    notes?: SortOrder
    receiveUserDocument?: SortOrder
    paidCustomerDocument?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    receivedAmount?: SortOrder
    changeAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    paymentMethodName?: SortOrder
    receivedAmount?: SortOrder
    changeAmount?: SortOrder
    transactionNumber?: SortOrder
    notes?: SortOrder
    receiveUserDocument?: SortOrder
    paidCustomerDocument?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderCode?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    paymentMethodName?: SortOrder
    receivedAmount?: SortOrder
    changeAmount?: SortOrder
    transactionNumber?: SortOrder
    notes?: SortOrder
    receiveUserDocument?: SortOrder
    paidCustomerDocument?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    cashBoxId?: SortOrder
    totalAmount?: SortOrder
    receivedAmount?: SortOrder
    changeAmount?: SortOrder
  }

  export type InventoryMovementTypeOrderByRelevanceInput = {
    fields: InventoryMovementTypeOrderByRelevanceFieldEnum | InventoryMovementTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryMovementTypeCountOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InventoryMovementTypeMaxOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InventoryMovementTypeMinOrderByAggregateInput = {
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type InventoryOrderByRelevanceInput = {
    fields: InventoryOrderByRelevanceFieldEnum | InventoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryProductIdStorageLocationCompoundUniqueInput = {
    productId: number
    storageLocation: string
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
    storageLocation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
    storageLocation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
    storageLocation?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    currentQuantity?: SortOrder
    minimumStock?: SortOrder
  }

  export type InventoryScalarRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type InventoryMovementTypeScalarRelationFilter = {
    is?: InventoryMovementTypeWhereInput
    isNot?: InventoryMovementTypeWhereInput
  }

  export type InventoryMovementOrderByRelevanceInput = {
    fields: InventoryMovementOrderByRelevanceFieldEnum | InventoryMovementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InventoryMovementCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    movementTypeCode?: SortOrder
    quantityMovement?: SortOrder
    reasonDescription?: SortOrder
    userDocumentNumber?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventoryMovementAvgOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    quantityMovement?: SortOrder
  }

  export type InventoryMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    movementTypeCode?: SortOrder
    quantityMovement?: SortOrder
    reasonDescription?: SortOrder
    userDocumentNumber?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventoryMovementMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    movementTypeCode?: SortOrder
    quantityMovement?: SortOrder
    reasonDescription?: SortOrder
    userDocumentNumber?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
  }

  export type InventoryMovementSumOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    quantityMovement?: SortOrder
  }

  export type OrderSequenceSequenceYearSequenceMonthSequenceDayCompoundUniqueInput = {
    sequenceYear: number
    sequenceMonth: number
    sequenceDay: number
  }

  export type OrderSequenceCountOrderByAggregateInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSequenceAvgOrderByAggregateInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
  }

  export type OrderSequenceMaxOrderByAggregateInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSequenceMinOrderByAggregateInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSequenceSumOrderByAggregateInput = {
    id?: SortOrder
    sequenceYear?: SortOrder
    sequenceMonth?: SortOrder
    sequenceDay?: SortOrder
    lastOrderNumber?: SortOrder
  }

  export type LogOrderByRelevanceInput = {
    fields: LogOrderByRelevanceFieldEnum | LogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    entityName?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    userDocumentNumber?: SortOrder
    customerDocumentNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutCreatedThemesInput = {
    create?: XOR<UserCreateWithoutCreatedThemesInput, UserUncheckedCreateWithoutCreatedThemesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedThemesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutThemeInput = {
    create?: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput> | UserCreateWithoutThemeInput[] | UserUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutThemeInput | UserCreateOrConnectWithoutThemeInput[]
    createMany?: UserCreateManyThemeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutThemeInput = {
    create?: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput> | CustomerCreateWithoutThemeInput[] | CustomerUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutThemeInput | CustomerCreateOrConnectWithoutThemeInput[]
    createMany?: CustomerCreateManyThemeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput> | UserCreateWithoutThemeInput[] | UserUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutThemeInput | UserCreateOrConnectWithoutThemeInput[]
    createMany?: UserCreateManyThemeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput> | CustomerCreateWithoutThemeInput[] | CustomerUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutThemeInput | CustomerCreateOrConnectWithoutThemeInput[]
    createMany?: CustomerCreateManyThemeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedThemesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedThemesInput, UserUncheckedCreateWithoutCreatedThemesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedThemesInput
    upsert?: UserUpsertWithoutCreatedThemesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedThemesInput, UserUpdateWithoutCreatedThemesInput>, UserUncheckedUpdateWithoutCreatedThemesInput>
  }

  export type UserUpdateManyWithoutThemeNestedInput = {
    create?: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput> | UserCreateWithoutThemeInput[] | UserUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutThemeInput | UserCreateOrConnectWithoutThemeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutThemeInput | UserUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: UserCreateManyThemeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutThemeInput | UserUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutThemeInput | UserUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutThemeNestedInput = {
    create?: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput> | CustomerCreateWithoutThemeInput[] | CustomerUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutThemeInput | CustomerCreateOrConnectWithoutThemeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutThemeInput | CustomerUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: CustomerCreateManyThemeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutThemeInput | CustomerUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutThemeInput | CustomerUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput> | UserCreateWithoutThemeInput[] | UserUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutThemeInput | UserCreateOrConnectWithoutThemeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutThemeInput | UserUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: UserCreateManyThemeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutThemeInput | UserUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutThemeInput | UserUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput> | CustomerCreateWithoutThemeInput[] | CustomerUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutThemeInput | CustomerCreateOrConnectWithoutThemeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutThemeInput | CustomerUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: CustomerCreateManyThemeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutThemeInput | CustomerUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutThemeInput | CustomerUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput> | CustomerCreateWithoutDocumentTypeInput[] | CustomerUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentTypeInput | CustomerCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: CustomerCreateManyDocumentTypeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput> | UserCreateWithoutDocumentTypeInput[] | UserUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTypeInput | UserCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: UserCreateManyDocumentTypeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput> | CustomerCreateWithoutDocumentTypeInput[] | CustomerUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentTypeInput | CustomerCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: CustomerCreateManyDocumentTypeInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDocumentTypeInput = {
    create?: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput> | UserCreateWithoutDocumentTypeInput[] | UserUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTypeInput | UserCreateOrConnectWithoutDocumentTypeInput[]
    createMany?: UserCreateManyDocumentTypeInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput> | CustomerCreateWithoutDocumentTypeInput[] | CustomerUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentTypeInput | CustomerCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDocumentTypeInput | CustomerUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: CustomerCreateManyDocumentTypeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDocumentTypeInput | CustomerUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDocumentTypeInput | CustomerUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput> | UserCreateWithoutDocumentTypeInput[] | UserUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTypeInput | UserCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDocumentTypeInput | UserUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: UserCreateManyDocumentTypeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDocumentTypeInput | UserUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDocumentTypeInput | UserUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput> | CustomerCreateWithoutDocumentTypeInput[] | CustomerUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutDocumentTypeInput | CustomerCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutDocumentTypeInput | CustomerUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: CustomerCreateManyDocumentTypeInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutDocumentTypeInput | CustomerUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutDocumentTypeInput | CustomerUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDocumentTypeNestedInput = {
    create?: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput> | UserCreateWithoutDocumentTypeInput[] | UserUncheckedCreateWithoutDocumentTypeInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDocumentTypeInput | UserCreateOrConnectWithoutDocumentTypeInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDocumentTypeInput | UserUpsertWithWhereUniqueWithoutDocumentTypeInput[]
    createMany?: UserCreateManyDocumentTypeInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDocumentTypeInput | UserUpdateWithWhereUniqueWithoutDocumentTypeInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDocumentTypeInput | UserUpdateManyWithWhereWithoutDocumentTypeInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutAccountStatusInput = {
    create?: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput> | UserCreateWithoutAccountStatusInput[] | UserUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountStatusInput | UserCreateOrConnectWithoutAccountStatusInput[]
    createMany?: UserCreateManyAccountStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutAccountStatusInput = {
    create?: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput> | CustomerCreateWithoutAccountStatusInput[] | CustomerUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountStatusInput | CustomerCreateOrConnectWithoutAccountStatusInput[]
    createMany?: CustomerCreateManyAccountStatusInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAccountStatusInput = {
    create?: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput> | UserCreateWithoutAccountStatusInput[] | UserUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountStatusInput | UserCreateOrConnectWithoutAccountStatusInput[]
    createMany?: UserCreateManyAccountStatusInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutAccountStatusInput = {
    create?: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput> | CustomerCreateWithoutAccountStatusInput[] | CustomerUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountStatusInput | CustomerCreateOrConnectWithoutAccountStatusInput[]
    createMany?: CustomerCreateManyAccountStatusInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutAccountStatusNestedInput = {
    create?: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput> | UserCreateWithoutAccountStatusInput[] | UserUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountStatusInput | UserCreateOrConnectWithoutAccountStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountStatusInput | UserUpsertWithWhereUniqueWithoutAccountStatusInput[]
    createMany?: UserCreateManyAccountStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountStatusInput | UserUpdateWithWhereUniqueWithoutAccountStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountStatusInput | UserUpdateManyWithWhereWithoutAccountStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutAccountStatusNestedInput = {
    create?: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput> | CustomerCreateWithoutAccountStatusInput[] | CustomerUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountStatusInput | CustomerCreateOrConnectWithoutAccountStatusInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAccountStatusInput | CustomerUpsertWithWhereUniqueWithoutAccountStatusInput[]
    createMany?: CustomerCreateManyAccountStatusInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAccountStatusInput | CustomerUpdateWithWhereUniqueWithoutAccountStatusInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAccountStatusInput | CustomerUpdateManyWithWhereWithoutAccountStatusInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAccountStatusNestedInput = {
    create?: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput> | UserCreateWithoutAccountStatusInput[] | UserUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAccountStatusInput | UserCreateOrConnectWithoutAccountStatusInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAccountStatusInput | UserUpsertWithWhereUniqueWithoutAccountStatusInput[]
    createMany?: UserCreateManyAccountStatusInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAccountStatusInput | UserUpdateWithWhereUniqueWithoutAccountStatusInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAccountStatusInput | UserUpdateManyWithWhereWithoutAccountStatusInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutAccountStatusNestedInput = {
    create?: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput> | CustomerCreateWithoutAccountStatusInput[] | CustomerUncheckedCreateWithoutAccountStatusInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountStatusInput | CustomerCreateOrConnectWithoutAccountStatusInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAccountStatusInput | CustomerUpsertWithWhereUniqueWithoutAccountStatusInput[]
    createMany?: CustomerCreateManyAccountStatusInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAccountStatusInput | CustomerUpdateWithWhereUniqueWithoutAccountStatusInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAccountStatusInput | CustomerUpdateManyWithWhereWithoutAccountStatusInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type PermissionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput> | PermissionCreateWithoutCategoryInput[] | PermissionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutCategoryInput | PermissionCreateOrConnectWithoutCategoryInput[]
    createMany?: PermissionCreateManyCategoryInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput> | PermissionCreateWithoutCategoryInput[] | PermissionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutCategoryInput | PermissionCreateOrConnectWithoutCategoryInput[]
    createMany?: PermissionCreateManyCategoryInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type PermissionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput> | PermissionCreateWithoutCategoryInput[] | PermissionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutCategoryInput | PermissionCreateOrConnectWithoutCategoryInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutCategoryInput | PermissionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PermissionCreateManyCategoryInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutCategoryInput | PermissionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutCategoryInput | PermissionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput> | PermissionCreateWithoutCategoryInput[] | PermissionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutCategoryInput | PermissionCreateOrConnectWithoutCategoryInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutCategoryInput | PermissionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PermissionCreateManyCategoryInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutCategoryInput | PermissionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutCategoryInput | PermissionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type PermissionCategoryCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<PermissionCategoryCreateWithoutPermissionsInput, PermissionCategoryUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: PermissionCategoryCreateOrConnectWithoutPermissionsInput
    connect?: PermissionCategoryWhereUniqueInput
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type PermissionCategoryUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<PermissionCategoryCreateWithoutPermissionsInput, PermissionCategoryUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: PermissionCategoryCreateOrConnectWithoutPermissionsInput
    upsert?: PermissionCategoryUpsertWithoutPermissionsInput
    connect?: PermissionCategoryWhereUniqueInput
    update?: XOR<XOR<PermissionCategoryUpdateToOneWithWhereWithoutPermissionsInput, PermissionCategoryUpdateWithoutPermissionsInput>, PermissionCategoryUncheckedUpdateWithoutPermissionsInput>
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolePermissionsInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolePermissionsInput
    upsert?: RoleUpsertWithoutRolePermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolePermissionsInput, RoleUpdateWithoutRolePermissionsInput>, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput = {
    create?: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolePermissionsInput
    upsert?: PermissionUpsertWithoutRolePermissionsInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolePermissionsInput, PermissionUpdateWithoutRolePermissionsInput>, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type DocumentTypeCreateNestedOneWithoutUsersInput = {
    create?: XOR<DocumentTypeCreateWithoutUsersInput, DocumentTypeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutUsersInput
    connect?: DocumentTypeWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type AccountStatusCreateNestedOneWithoutUsersInput = {
    create?: XOR<AccountStatusCreateWithoutUsersInput, AccountStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AccountStatusCreateOrConnectWithoutUsersInput
    connect?: AccountStatusWhereUniqueInput
  }

  export type ThemeCreateNestedOneWithoutUsersUsingThisThemeInput = {
    create?: XOR<ThemeCreateWithoutUsersUsingThisThemeInput, ThemeUncheckedCreateWithoutUsersUsingThisThemeInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutUsersUsingThisThemeInput
    connect?: ThemeWhereUniqueInput
  }

  export type CashBoxCreateNestedManyWithoutOpenerInput = {
    create?: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput> | CashBoxCreateWithoutOpenerInput[] | CashBoxUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutOpenerInput | CashBoxCreateOrConnectWithoutOpenerInput[]
    createMany?: CashBoxCreateManyOpenerInputEnvelope
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
  }

  export type CashBoxCreateNestedManyWithoutCloserInput = {
    create?: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput> | CashBoxCreateWithoutCloserInput[] | CashBoxUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutCloserInput | CashBoxCreateOrConnectWithoutCloserInput[]
    createMany?: CashBoxCreateManyCloserInputEnvelope
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
  }

  export type InventoryMovementCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CombineTableCreateNestedManyWithoutCombinerInput = {
    create?: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput> | CombineTableCreateWithoutCombinerInput[] | CombineTableUncheckedCreateWithoutCombinerInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutCombinerInput | CombineTableCreateOrConnectWithoutCombinerInput[]
    createMany?: CombineTableCreateManyCombinerInputEnvelope
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
  }

  export type CombineTableCreateNestedManyWithoutReleaserInput = {
    create?: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput> | CombineTableCreateWithoutReleaserInput[] | CombineTableUncheckedCreateWithoutReleaserInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutReleaserInput | CombineTableCreateOrConnectWithoutReleaserInput[]
    createMany?: CombineTableCreateManyReleaserInputEnvelope
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
  }

  export type TableSessionCreateNestedManyWithoutOpenerInput = {
    create?: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput> | TableSessionCreateWithoutOpenerInput[] | TableSessionUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutOpenerInput | TableSessionCreateOrConnectWithoutOpenerInput[]
    createMany?: TableSessionCreateManyOpenerInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type TableSessionCreateNestedManyWithoutCloserInput = {
    create?: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput> | TableSessionCreateWithoutCloserInput[] | TableSessionUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCloserInput | TableSessionCreateOrConnectWithoutCloserInput[]
    createMany?: TableSessionCreateManyCloserInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput> | OrderCreateWithoutCreatorInput[] | OrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatorInput | OrderCreateOrConnectWithoutCreatorInput[]
    createMany?: OrderCreateManyCreatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCloserInput = {
    create?: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput> | OrderCreateWithoutCloserInput[] | OrderUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCloserInput | OrderCreateOrConnectWithoutCloserInput[]
    createMany?: OrderCreateManyCloserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ThemeCreateNestedManyWithoutUserInput = {
    create?: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput> | ThemeCreateWithoutUserInput[] | ThemeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutUserInput | ThemeCreateOrConnectWithoutUserInput[]
    createMany?: ThemeCreateManyUserInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReceiveUserInput = {
    create?: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput> | PaymentCreateWithoutReceiveUserInput[] | PaymentUncheckedCreateWithoutReceiveUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiveUserInput | PaymentCreateOrConnectWithoutReceiveUserInput[]
    createMany?: PaymentCreateManyReceiveUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type CashBoxUncheckedCreateNestedManyWithoutOpenerInput = {
    create?: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput> | CashBoxCreateWithoutOpenerInput[] | CashBoxUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutOpenerInput | CashBoxCreateOrConnectWithoutOpenerInput[]
    createMany?: CashBoxCreateManyOpenerInputEnvelope
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
  }

  export type CashBoxUncheckedCreateNestedManyWithoutCloserInput = {
    create?: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput> | CashBoxCreateWithoutCloserInput[] | CashBoxUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutCloserInput | CashBoxCreateOrConnectWithoutCloserInput[]
    createMany?: CashBoxCreateManyCloserInputEnvelope
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CombineTableUncheckedCreateNestedManyWithoutCombinerInput = {
    create?: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput> | CombineTableCreateWithoutCombinerInput[] | CombineTableUncheckedCreateWithoutCombinerInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutCombinerInput | CombineTableCreateOrConnectWithoutCombinerInput[]
    createMany?: CombineTableCreateManyCombinerInputEnvelope
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
  }

  export type CombineTableUncheckedCreateNestedManyWithoutReleaserInput = {
    create?: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput> | CombineTableCreateWithoutReleaserInput[] | CombineTableUncheckedCreateWithoutReleaserInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutReleaserInput | CombineTableCreateOrConnectWithoutReleaserInput[]
    createMany?: CombineTableCreateManyReleaserInputEnvelope
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
  }

  export type TableSessionUncheckedCreateNestedManyWithoutOpenerInput = {
    create?: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput> | TableSessionCreateWithoutOpenerInput[] | TableSessionUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutOpenerInput | TableSessionCreateOrConnectWithoutOpenerInput[]
    createMany?: TableSessionCreateManyOpenerInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type TableSessionUncheckedCreateNestedManyWithoutCloserInput = {
    create?: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput> | TableSessionCreateWithoutCloserInput[] | TableSessionUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCloserInput | TableSessionCreateOrConnectWithoutCloserInput[]
    createMany?: TableSessionCreateManyCloserInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput> | OrderCreateWithoutCreatorInput[] | OrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatorInput | OrderCreateOrConnectWithoutCreatorInput[]
    createMany?: OrderCreateManyCreatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCloserInput = {
    create?: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput> | OrderCreateWithoutCloserInput[] | OrderUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCloserInput | OrderCreateOrConnectWithoutCloserInput[]
    createMany?: OrderCreateManyCloserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ThemeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput> | ThemeCreateWithoutUserInput[] | ThemeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutUserInput | ThemeCreateOrConnectWithoutUserInput[]
    createMany?: ThemeCreateManyUserInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReceiveUserInput = {
    create?: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput> | PaymentCreateWithoutReceiveUserInput[] | PaymentUncheckedCreateWithoutReceiveUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiveUserInput | PaymentCreateOrConnectWithoutReceiveUserInput[]
    createMany?: PaymentCreateManyReceiveUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentTypeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<DocumentTypeCreateWithoutUsersInput, DocumentTypeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutUsersInput
    upsert?: DocumentTypeUpsertWithoutUsersInput
    connect?: DocumentTypeWhereUniqueInput
    update?: XOR<XOR<DocumentTypeUpdateToOneWithWhereWithoutUsersInput, DocumentTypeUpdateWithoutUsersInput>, DocumentTypeUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type AccountStatusUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AccountStatusCreateWithoutUsersInput, AccountStatusUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AccountStatusCreateOrConnectWithoutUsersInput
    upsert?: AccountStatusUpsertWithoutUsersInput
    connect?: AccountStatusWhereUniqueInput
    update?: XOR<XOR<AccountStatusUpdateToOneWithWhereWithoutUsersInput, AccountStatusUpdateWithoutUsersInput>, AccountStatusUncheckedUpdateWithoutUsersInput>
  }

  export type ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput = {
    create?: XOR<ThemeCreateWithoutUsersUsingThisThemeInput, ThemeUncheckedCreateWithoutUsersUsingThisThemeInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutUsersUsingThisThemeInput
    upsert?: ThemeUpsertWithoutUsersUsingThisThemeInput
    disconnect?: ThemeWhereInput | boolean
    delete?: ThemeWhereInput | boolean
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutUsersUsingThisThemeInput, ThemeUpdateWithoutUsersUsingThisThemeInput>, ThemeUncheckedUpdateWithoutUsersUsingThisThemeInput>
  }

  export type CashBoxUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput> | CashBoxCreateWithoutOpenerInput[] | CashBoxUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutOpenerInput | CashBoxCreateOrConnectWithoutOpenerInput[]
    upsert?: CashBoxUpsertWithWhereUniqueWithoutOpenerInput | CashBoxUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: CashBoxCreateManyOpenerInputEnvelope
    set?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    disconnect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    delete?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    update?: CashBoxUpdateWithWhereUniqueWithoutOpenerInput | CashBoxUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: CashBoxUpdateManyWithWhereWithoutOpenerInput | CashBoxUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
  }

  export type CashBoxUpdateManyWithoutCloserNestedInput = {
    create?: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput> | CashBoxCreateWithoutCloserInput[] | CashBoxUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutCloserInput | CashBoxCreateOrConnectWithoutCloserInput[]
    upsert?: CashBoxUpsertWithWhereUniqueWithoutCloserInput | CashBoxUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: CashBoxCreateManyCloserInputEnvelope
    set?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    disconnect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    delete?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    update?: CashBoxUpdateWithWhereUniqueWithoutCloserInput | CashBoxUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: CashBoxUpdateManyWithWhereWithoutCloserInput | CashBoxUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
  }

  export type InventoryMovementUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CombineTableUpdateManyWithoutCombinerNestedInput = {
    create?: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput> | CombineTableCreateWithoutCombinerInput[] | CombineTableUncheckedCreateWithoutCombinerInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutCombinerInput | CombineTableCreateOrConnectWithoutCombinerInput[]
    upsert?: CombineTableUpsertWithWhereUniqueWithoutCombinerInput | CombineTableUpsertWithWhereUniqueWithoutCombinerInput[]
    createMany?: CombineTableCreateManyCombinerInputEnvelope
    set?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    disconnect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    delete?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    update?: CombineTableUpdateWithWhereUniqueWithoutCombinerInput | CombineTableUpdateWithWhereUniqueWithoutCombinerInput[]
    updateMany?: CombineTableUpdateManyWithWhereWithoutCombinerInput | CombineTableUpdateManyWithWhereWithoutCombinerInput[]
    deleteMany?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
  }

  export type CombineTableUpdateManyWithoutReleaserNestedInput = {
    create?: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput> | CombineTableCreateWithoutReleaserInput[] | CombineTableUncheckedCreateWithoutReleaserInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutReleaserInput | CombineTableCreateOrConnectWithoutReleaserInput[]
    upsert?: CombineTableUpsertWithWhereUniqueWithoutReleaserInput | CombineTableUpsertWithWhereUniqueWithoutReleaserInput[]
    createMany?: CombineTableCreateManyReleaserInputEnvelope
    set?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    disconnect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    delete?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    update?: CombineTableUpdateWithWhereUniqueWithoutReleaserInput | CombineTableUpdateWithWhereUniqueWithoutReleaserInput[]
    updateMany?: CombineTableUpdateManyWithWhereWithoutReleaserInput | CombineTableUpdateManyWithWhereWithoutReleaserInput[]
    deleteMany?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
  }

  export type TableSessionUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput> | TableSessionCreateWithoutOpenerInput[] | TableSessionUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutOpenerInput | TableSessionCreateOrConnectWithoutOpenerInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutOpenerInput | TableSessionUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: TableSessionCreateManyOpenerInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutOpenerInput | TableSessionUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutOpenerInput | TableSessionUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type TableSessionUpdateManyWithoutCloserNestedInput = {
    create?: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput> | TableSessionCreateWithoutCloserInput[] | TableSessionUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCloserInput | TableSessionCreateOrConnectWithoutCloserInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutCloserInput | TableSessionUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: TableSessionCreateManyCloserInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutCloserInput | TableSessionUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutCloserInput | TableSessionUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput> | OrderCreateWithoutCreatorInput[] | OrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatorInput | OrderCreateOrConnectWithoutCreatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatorInput | OrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: OrderCreateManyCreatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatorInput | OrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatorInput | OrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCloserNestedInput = {
    create?: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput> | OrderCreateWithoutCloserInput[] | OrderUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCloserInput | OrderCreateOrConnectWithoutCloserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCloserInput | OrderUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: OrderCreateManyCloserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCloserInput | OrderUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCloserInput | OrderUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ThemeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput> | ThemeCreateWithoutUserInput[] | ThemeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutUserInput | ThemeCreateOrConnectWithoutUserInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutUserInput | ThemeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ThemeCreateManyUserInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutUserInput | ThemeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutUserInput | ThemeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReceiveUserNestedInput = {
    create?: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput> | PaymentCreateWithoutReceiveUserInput[] | PaymentUncheckedCreateWithoutReceiveUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiveUserInput | PaymentCreateOrConnectWithoutReceiveUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceiveUserInput | PaymentUpsertWithWhereUniqueWithoutReceiveUserInput[]
    createMany?: PaymentCreateManyReceiveUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceiveUserInput | PaymentUpdateWithWhereUniqueWithoutReceiveUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceiveUserInput | PaymentUpdateManyWithWhereWithoutReceiveUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type CashBoxUncheckedUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput> | CashBoxCreateWithoutOpenerInput[] | CashBoxUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutOpenerInput | CashBoxCreateOrConnectWithoutOpenerInput[]
    upsert?: CashBoxUpsertWithWhereUniqueWithoutOpenerInput | CashBoxUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: CashBoxCreateManyOpenerInputEnvelope
    set?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    disconnect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    delete?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    update?: CashBoxUpdateWithWhereUniqueWithoutOpenerInput | CashBoxUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: CashBoxUpdateManyWithWhereWithoutOpenerInput | CashBoxUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
  }

  export type CashBoxUncheckedUpdateManyWithoutCloserNestedInput = {
    create?: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput> | CashBoxCreateWithoutCloserInput[] | CashBoxUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: CashBoxCreateOrConnectWithoutCloserInput | CashBoxCreateOrConnectWithoutCloserInput[]
    upsert?: CashBoxUpsertWithWhereUniqueWithoutCloserInput | CashBoxUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: CashBoxCreateManyCloserInputEnvelope
    set?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    disconnect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    delete?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    connect?: CashBoxWhereUniqueInput | CashBoxWhereUniqueInput[]
    update?: CashBoxUpdateWithWhereUniqueWithoutCloserInput | CashBoxUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: CashBoxUpdateManyWithWhereWithoutCloserInput | CashBoxUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput> | InventoryMovementCreateWithoutUserInput[] | InventoryMovementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutUserInput | InventoryMovementCreateOrConnectWithoutUserInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutUserInput | InventoryMovementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryMovementCreateManyUserInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutUserInput | InventoryMovementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutUserInput | InventoryMovementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CombineTableUncheckedUpdateManyWithoutCombinerNestedInput = {
    create?: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput> | CombineTableCreateWithoutCombinerInput[] | CombineTableUncheckedCreateWithoutCombinerInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutCombinerInput | CombineTableCreateOrConnectWithoutCombinerInput[]
    upsert?: CombineTableUpsertWithWhereUniqueWithoutCombinerInput | CombineTableUpsertWithWhereUniqueWithoutCombinerInput[]
    createMany?: CombineTableCreateManyCombinerInputEnvelope
    set?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    disconnect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    delete?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    update?: CombineTableUpdateWithWhereUniqueWithoutCombinerInput | CombineTableUpdateWithWhereUniqueWithoutCombinerInput[]
    updateMany?: CombineTableUpdateManyWithWhereWithoutCombinerInput | CombineTableUpdateManyWithWhereWithoutCombinerInput[]
    deleteMany?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
  }

  export type CombineTableUncheckedUpdateManyWithoutReleaserNestedInput = {
    create?: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput> | CombineTableCreateWithoutReleaserInput[] | CombineTableUncheckedCreateWithoutReleaserInput[]
    connectOrCreate?: CombineTableCreateOrConnectWithoutReleaserInput | CombineTableCreateOrConnectWithoutReleaserInput[]
    upsert?: CombineTableUpsertWithWhereUniqueWithoutReleaserInput | CombineTableUpsertWithWhereUniqueWithoutReleaserInput[]
    createMany?: CombineTableCreateManyReleaserInputEnvelope
    set?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    disconnect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    delete?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    connect?: CombineTableWhereUniqueInput | CombineTableWhereUniqueInput[]
    update?: CombineTableUpdateWithWhereUniqueWithoutReleaserInput | CombineTableUpdateWithWhereUniqueWithoutReleaserInput[]
    updateMany?: CombineTableUpdateManyWithWhereWithoutReleaserInput | CombineTableUpdateManyWithWhereWithoutReleaserInput[]
    deleteMany?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
  }

  export type TableSessionUncheckedUpdateManyWithoutOpenerNestedInput = {
    create?: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput> | TableSessionCreateWithoutOpenerInput[] | TableSessionUncheckedCreateWithoutOpenerInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutOpenerInput | TableSessionCreateOrConnectWithoutOpenerInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutOpenerInput | TableSessionUpsertWithWhereUniqueWithoutOpenerInput[]
    createMany?: TableSessionCreateManyOpenerInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutOpenerInput | TableSessionUpdateWithWhereUniqueWithoutOpenerInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutOpenerInput | TableSessionUpdateManyWithWhereWithoutOpenerInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type TableSessionUncheckedUpdateManyWithoutCloserNestedInput = {
    create?: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput> | TableSessionCreateWithoutCloserInput[] | TableSessionUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCloserInput | TableSessionCreateOrConnectWithoutCloserInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutCloserInput | TableSessionUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: TableSessionCreateManyCloserInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutCloserInput | TableSessionUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutCloserInput | TableSessionUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput> | OrderCreateWithoutCreatorInput[] | OrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCreatorInput | OrderCreateOrConnectWithoutCreatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCreatorInput | OrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: OrderCreateManyCreatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCreatorInput | OrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCreatorInput | OrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCloserNestedInput = {
    create?: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput> | OrderCreateWithoutCloserInput[] | OrderUncheckedCreateWithoutCloserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCloserInput | OrderCreateOrConnectWithoutCloserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCloserInput | OrderUpsertWithWhereUniqueWithoutCloserInput[]
    createMany?: OrderCreateManyCloserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCloserInput | OrderUpdateWithWhereUniqueWithoutCloserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCloserInput | OrderUpdateManyWithWhereWithoutCloserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ThemeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput> | ThemeCreateWithoutUserInput[] | ThemeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutUserInput | ThemeCreateOrConnectWithoutUserInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutUserInput | ThemeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ThemeCreateManyUserInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutUserInput | ThemeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutUserInput | ThemeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput = {
    create?: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput> | PaymentCreateWithoutReceiveUserInput[] | PaymentUncheckedCreateWithoutReceiveUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReceiveUserInput | PaymentCreateOrConnectWithoutReceiveUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReceiveUserInput | PaymentUpsertWithWhereUniqueWithoutReceiveUserInput[]
    createMany?: PaymentCreateManyReceiveUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReceiveUserInput | PaymentUpdateWithWhereUniqueWithoutReceiveUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReceiveUserInput | PaymentUpdateManyWithWhereWithoutReceiveUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CustomerCreateWithoutSessionsInput, CustomerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSessionsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type CustomerUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<CustomerCreateWithoutSessionsInput, CustomerUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSessionsInput
    upsert?: CustomerUpsertWithoutSessionsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSessionsInput, CustomerUpdateWithoutSessionsInput>, CustomerUncheckedUpdateWithoutSessionsInput>
  }

  export type DocumentTypeCreateNestedOneWithoutCustomersInput = {
    create?: XOR<DocumentTypeCreateWithoutCustomersInput, DocumentTypeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutCustomersInput
    connect?: DocumentTypeWhereUniqueInput
  }

  export type AccountStatusCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AccountStatusCreateWithoutCustomersInput, AccountStatusUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountStatusCreateOrConnectWithoutCustomersInput
    connect?: AccountStatusWhereUniqueInput
  }

  export type ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput = {
    create?: XOR<ThemeCreateWithoutCustomerUsingThisThemeInput, ThemeUncheckedCreateWithoutCustomerUsingThisThemeInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutCustomerUsingThisThemeInput
    connect?: ThemeWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput> | SessionCreateWithoutCustomerInput[] | SessionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCustomerInput | SessionCreateOrConnectWithoutCustomerInput[]
    createMany?: SessionCreateManyCustomerInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput> | LogCreateWithoutCustomerInput[] | LogUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCustomerInput | LogCreateOrConnectWithoutCustomerInput[]
    createMany?: LogCreateManyCustomerInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPaidCustomerInput = {
    create?: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput> | PaymentCreateWithoutPaidCustomerInput[] | PaymentUncheckedCreateWithoutPaidCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaidCustomerInput | PaymentCreateOrConnectWithoutPaidCustomerInput[]
    createMany?: PaymentCreateManyPaidCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput> | SessionCreateWithoutCustomerInput[] | SessionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCustomerInput | SessionCreateOrConnectWithoutCustomerInput[]
    createMany?: SessionCreateManyCustomerInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput> | LogCreateWithoutCustomerInput[] | LogUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCustomerInput | LogCreateOrConnectWithoutCustomerInput[]
    createMany?: LogCreateManyCustomerInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput = {
    create?: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput> | PaymentCreateWithoutPaidCustomerInput[] | PaymentUncheckedCreateWithoutPaidCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaidCustomerInput | PaymentCreateOrConnectWithoutPaidCustomerInput[]
    createMany?: PaymentCreateManyPaidCustomerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<DocumentTypeCreateWithoutCustomersInput, DocumentTypeUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: DocumentTypeCreateOrConnectWithoutCustomersInput
    upsert?: DocumentTypeUpsertWithoutCustomersInput
    connect?: DocumentTypeWhereUniqueInput
    update?: XOR<XOR<DocumentTypeUpdateToOneWithWhereWithoutCustomersInput, DocumentTypeUpdateWithoutCustomersInput>, DocumentTypeUncheckedUpdateWithoutCustomersInput>
  }

  export type AccountStatusUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<AccountStatusCreateWithoutCustomersInput, AccountStatusUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AccountStatusCreateOrConnectWithoutCustomersInput
    upsert?: AccountStatusUpsertWithoutCustomersInput
    connect?: AccountStatusWhereUniqueInput
    update?: XOR<XOR<AccountStatusUpdateToOneWithWhereWithoutCustomersInput, AccountStatusUpdateWithoutCustomersInput>, AccountStatusUncheckedUpdateWithoutCustomersInput>
  }

  export type ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput = {
    create?: XOR<ThemeCreateWithoutCustomerUsingThisThemeInput, ThemeUncheckedCreateWithoutCustomerUsingThisThemeInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutCustomerUsingThisThemeInput
    upsert?: ThemeUpsertWithoutCustomerUsingThisThemeInput
    disconnect?: ThemeWhereInput | boolean
    delete?: ThemeWhereInput | boolean
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutCustomerUsingThisThemeInput, ThemeUpdateWithoutCustomerUsingThisThemeInput>, ThemeUncheckedUpdateWithoutCustomerUsingThisThemeInput>
  }

  export type SessionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput> | SessionCreateWithoutCustomerInput[] | SessionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCustomerInput | SessionCreateOrConnectWithoutCustomerInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCustomerInput | SessionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SessionCreateManyCustomerInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCustomerInput | SessionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCustomerInput | SessionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LogUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput> | LogCreateWithoutCustomerInput[] | LogUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCustomerInput | LogCreateOrConnectWithoutCustomerInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutCustomerInput | LogUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LogCreateManyCustomerInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutCustomerInput | LogUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LogUpdateManyWithWhereWithoutCustomerInput | LogUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPaidCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput> | PaymentCreateWithoutPaidCustomerInput[] | PaymentUncheckedCreateWithoutPaidCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaidCustomerInput | PaymentCreateOrConnectWithoutPaidCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaidCustomerInput | PaymentUpsertWithWhereUniqueWithoutPaidCustomerInput[]
    createMany?: PaymentCreateManyPaidCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaidCustomerInput | PaymentUpdateWithWhereUniqueWithoutPaidCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaidCustomerInput | PaymentUpdateManyWithWhereWithoutPaidCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput> | SessionCreateWithoutCustomerInput[] | SessionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCustomerInput | SessionCreateOrConnectWithoutCustomerInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCustomerInput | SessionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SessionCreateManyCustomerInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCustomerInput | SessionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCustomerInput | SessionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput> | LogCreateWithoutCustomerInput[] | LogUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: LogCreateOrConnectWithoutCustomerInput | LogCreateOrConnectWithoutCustomerInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutCustomerInput | LogUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: LogCreateManyCustomerInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutCustomerInput | LogUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: LogUpdateManyWithWhereWithoutCustomerInput | LogUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput = {
    create?: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput> | PaymentCreateWithoutPaidCustomerInput[] | PaymentUncheckedCreateWithoutPaidCustomerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaidCustomerInput | PaymentCreateOrConnectWithoutPaidCustomerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaidCustomerInput | PaymentUpsertWithWhereUniqueWithoutPaidCustomerInput[]
    createMany?: PaymentCreateManyPaidCustomerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaidCustomerInput | PaymentUpdateWithWhereUniqueWithoutPaidCustomerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaidCustomerInput | PaymentUpdateManyWithWhereWithoutPaidCustomerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOpenedCashBoxesInput = {
    create?: XOR<UserCreateWithoutOpenedCashBoxesInput, UserUncheckedCreateWithoutOpenedCashBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedCashBoxesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClosedCashBoxesInput = {
    create?: XOR<UserCreateWithoutClosedCashBoxesInput, UserUncheckedCreateWithoutClosedCashBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedCashBoxesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutCashBoxInput = {
    create?: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput> | PaymentCreateWithoutCashBoxInput[] | PaymentUncheckedCreateWithoutCashBoxInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashBoxInput | PaymentCreateOrConnectWithoutCashBoxInput[]
    createMany?: PaymentCreateManyCashBoxInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCashBoxInput = {
    create?: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput> | PaymentCreateWithoutCashBoxInput[] | PaymentUncheckedCreateWithoutCashBoxInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashBoxInput | PaymentCreateOrConnectWithoutCashBoxInput[]
    createMany?: PaymentCreateManyCashBoxInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutOpenedCashBoxesNestedInput = {
    create?: XOR<UserCreateWithoutOpenedCashBoxesInput, UserUncheckedCreateWithoutOpenedCashBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpenedCashBoxesInput
    upsert?: UserUpsertWithoutOpenedCashBoxesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpenedCashBoxesInput, UserUpdateWithoutOpenedCashBoxesInput>, UserUncheckedUpdateWithoutOpenedCashBoxesInput>
  }

  export type UserUpdateOneWithoutClosedCashBoxesNestedInput = {
    create?: XOR<UserCreateWithoutClosedCashBoxesInput, UserUncheckedCreateWithoutClosedCashBoxesInput>
    connectOrCreate?: UserCreateOrConnectWithoutClosedCashBoxesInput
    upsert?: UserUpsertWithoutClosedCashBoxesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClosedCashBoxesInput, UserUpdateWithoutClosedCashBoxesInput>, UserUncheckedUpdateWithoutClosedCashBoxesInput>
  }

  export type PaymentUpdateManyWithoutCashBoxNestedInput = {
    create?: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput> | PaymentCreateWithoutCashBoxInput[] | PaymentUncheckedCreateWithoutCashBoxInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashBoxInput | PaymentCreateOrConnectWithoutCashBoxInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCashBoxInput | PaymentUpsertWithWhereUniqueWithoutCashBoxInput[]
    createMany?: PaymentCreateManyCashBoxInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCashBoxInput | PaymentUpdateWithWhereUniqueWithoutCashBoxInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCashBoxInput | PaymentUpdateManyWithWhereWithoutCashBoxInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCashBoxNestedInput = {
    create?: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput> | PaymentCreateWithoutCashBoxInput[] | PaymentUncheckedCreateWithoutCashBoxInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCashBoxInput | PaymentCreateOrConnectWithoutCashBoxInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCashBoxInput | PaymentUpsertWithWhereUniqueWithoutCashBoxInput[]
    createMany?: PaymentCreateManyCashBoxInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCashBoxInput | PaymentUpdateWithWhereUniqueWithoutCashBoxInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCashBoxInput | PaymentUpdateManyWithWhereWithoutCashBoxInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TableCreateNestedManyWithoutStatusInput = {
    create?: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput> | TableCreateWithoutStatusInput[] | TableUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TableCreateOrConnectWithoutStatusInput | TableCreateOrConnectWithoutStatusInput[]
    createMany?: TableCreateManyStatusInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput> | TableCreateWithoutStatusInput[] | TableUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TableCreateOrConnectWithoutStatusInput | TableCreateOrConnectWithoutStatusInput[]
    createMany?: TableCreateManyStatusInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput> | TableCreateWithoutStatusInput[] | TableUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TableCreateOrConnectWithoutStatusInput | TableCreateOrConnectWithoutStatusInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutStatusInput | TableUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TableCreateManyStatusInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutStatusInput | TableUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TableUpdateManyWithWhereWithoutStatusInput | TableUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput> | TableCreateWithoutStatusInput[] | TableUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: TableCreateOrConnectWithoutStatusInput | TableCreateOrConnectWithoutStatusInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutStatusInput | TableUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: TableCreateManyStatusInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutStatusInput | TableUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: TableUpdateManyWithWhereWithoutStatusInput | TableUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableCreateNestedManyWithoutZoneInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TableUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutZoneInput | TableUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutZoneInput | TableUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TableUpdateManyWithWhereWithoutZoneInput | TableUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput> | TableCreateWithoutZoneInput[] | TableUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: TableCreateOrConnectWithoutZoneInput | TableCreateOrConnectWithoutZoneInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutZoneInput | TableUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: TableCreateManyZoneInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutZoneInput | TableUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: TableUpdateManyWithWhereWithoutZoneInput | TableUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type RestaurantZoneCreateNestedOneWithoutTablesInput = {
    create?: XOR<RestaurantZoneCreateWithoutTablesInput, RestaurantZoneUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantZoneCreateOrConnectWithoutTablesInput
    connect?: RestaurantZoneWhereUniqueInput
  }

  export type TableStatusCreateNestedOneWithoutTablesInput = {
    create?: XOR<TableStatusCreateWithoutTablesInput, TableStatusUncheckedCreateWithoutTablesInput>
    connectOrCreate?: TableStatusCreateOrConnectWithoutTablesInput
    connect?: TableStatusWhereUniqueInput
  }

  export type TableSessionCreateNestedManyWithoutTableInput = {
    create?: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput> | TableSessionCreateWithoutTableInput[] | TableSessionUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutTableInput | TableSessionCreateOrConnectWithoutTableInput[]
    createMany?: TableSessionCreateManyTableInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type CombineTableItemCreateNestedManyWithoutTableInput = {
    create?: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput> | CombineTableItemCreateWithoutTableInput[] | CombineTableItemUncheckedCreateWithoutTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutTableInput | CombineTableItemCreateOrConnectWithoutTableInput[]
    createMany?: CombineTableItemCreateManyTableInputEnvelope
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
  }

  export type TableSessionUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput> | TableSessionCreateWithoutTableInput[] | TableSessionUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutTableInput | TableSessionCreateOrConnectWithoutTableInput[]
    createMany?: TableSessionCreateManyTableInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type CombineTableItemUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput> | CombineTableItemCreateWithoutTableInput[] | CombineTableItemUncheckedCreateWithoutTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutTableInput | CombineTableItemCreateOrConnectWithoutTableInput[]
    createMany?: CombineTableItemCreateManyTableInputEnvelope
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
  }

  export type RestaurantZoneUpdateOneWithoutTablesNestedInput = {
    create?: XOR<RestaurantZoneCreateWithoutTablesInput, RestaurantZoneUncheckedCreateWithoutTablesInput>
    connectOrCreate?: RestaurantZoneCreateOrConnectWithoutTablesInput
    upsert?: RestaurantZoneUpsertWithoutTablesInput
    disconnect?: RestaurantZoneWhereInput | boolean
    delete?: RestaurantZoneWhereInput | boolean
    connect?: RestaurantZoneWhereUniqueInput
    update?: XOR<XOR<RestaurantZoneUpdateToOneWithWhereWithoutTablesInput, RestaurantZoneUpdateWithoutTablesInput>, RestaurantZoneUncheckedUpdateWithoutTablesInput>
  }

  export type TableStatusUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<TableStatusCreateWithoutTablesInput, TableStatusUncheckedCreateWithoutTablesInput>
    connectOrCreate?: TableStatusCreateOrConnectWithoutTablesInput
    upsert?: TableStatusUpsertWithoutTablesInput
    connect?: TableStatusWhereUniqueInput
    update?: XOR<XOR<TableStatusUpdateToOneWithWhereWithoutTablesInput, TableStatusUpdateWithoutTablesInput>, TableStatusUncheckedUpdateWithoutTablesInput>
  }

  export type TableSessionUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput> | TableSessionCreateWithoutTableInput[] | TableSessionUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutTableInput | TableSessionCreateOrConnectWithoutTableInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutTableInput | TableSessionUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableSessionCreateManyTableInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutTableInput | TableSessionUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutTableInput | TableSessionUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type CombineTableItemUpdateManyWithoutTableNestedInput = {
    create?: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput> | CombineTableItemCreateWithoutTableInput[] | CombineTableItemUncheckedCreateWithoutTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutTableInput | CombineTableItemCreateOrConnectWithoutTableInput[]
    upsert?: CombineTableItemUpsertWithWhereUniqueWithoutTableInput | CombineTableItemUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: CombineTableItemCreateManyTableInputEnvelope
    set?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    disconnect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    delete?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    update?: CombineTableItemUpdateWithWhereUniqueWithoutTableInput | CombineTableItemUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: CombineTableItemUpdateManyWithWhereWithoutTableInput | CombineTableItemUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
  }

  export type TableSessionUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput> | TableSessionCreateWithoutTableInput[] | TableSessionUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutTableInput | TableSessionCreateOrConnectWithoutTableInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutTableInput | TableSessionUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableSessionCreateManyTableInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutTableInput | TableSessionUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutTableInput | TableSessionUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type CombineTableItemUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput> | CombineTableItemCreateWithoutTableInput[] | CombineTableItemUncheckedCreateWithoutTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutTableInput | CombineTableItemCreateOrConnectWithoutTableInput[]
    upsert?: CombineTableItemUpsertWithWhereUniqueWithoutTableInput | CombineTableItemUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: CombineTableItemCreateManyTableInputEnvelope
    set?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    disconnect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    delete?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    update?: CombineTableItemUpdateWithWhereUniqueWithoutTableInput | CombineTableItemUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: CombineTableItemUpdateManyWithWhereWithoutTableInput | CombineTableItemUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCombinedTablesInput = {
    create?: XOR<UserCreateWithoutCombinedTablesInput, UserUncheckedCreateWithoutCombinedTablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombinedTablesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReleasedTablesInput = {
    create?: XOR<UserCreateWithoutReleasedTablesInput, UserUncheckedCreateWithoutReleasedTablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReleasedTablesInput
    connect?: UserWhereUniqueInput
  }

  export type CombineTableItemCreateNestedManyWithoutCombineTableInput = {
    create?: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput> | CombineTableItemCreateWithoutCombineTableInput[] | CombineTableItemUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutCombineTableInput | CombineTableItemCreateOrConnectWithoutCombineTableInput[]
    createMany?: CombineTableItemCreateManyCombineTableInputEnvelope
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
  }

  export type TableSessionCreateNestedManyWithoutCombineTableInput = {
    create?: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput> | TableSessionCreateWithoutCombineTableInput[] | TableSessionUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCombineTableInput | TableSessionCreateOrConnectWithoutCombineTableInput[]
    createMany?: TableSessionCreateManyCombineTableInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type CombineTableItemUncheckedCreateNestedManyWithoutCombineTableInput = {
    create?: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput> | CombineTableItemCreateWithoutCombineTableInput[] | CombineTableItemUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutCombineTableInput | CombineTableItemCreateOrConnectWithoutCombineTableInput[]
    createMany?: CombineTableItemCreateManyCombineTableInputEnvelope
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
  }

  export type TableSessionUncheckedCreateNestedManyWithoutCombineTableInput = {
    create?: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput> | TableSessionCreateWithoutCombineTableInput[] | TableSessionUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCombineTableInput | TableSessionCreateOrConnectWithoutCombineTableInput[]
    createMany?: TableSessionCreateManyCombineTableInputEnvelope
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCombinedTablesNestedInput = {
    create?: XOR<UserCreateWithoutCombinedTablesInput, UserUncheckedCreateWithoutCombinedTablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCombinedTablesInput
    upsert?: UserUpsertWithoutCombinedTablesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCombinedTablesInput, UserUpdateWithoutCombinedTablesInput>, UserUncheckedUpdateWithoutCombinedTablesInput>
  }

  export type UserUpdateOneWithoutReleasedTablesNestedInput = {
    create?: XOR<UserCreateWithoutReleasedTablesInput, UserUncheckedCreateWithoutReleasedTablesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReleasedTablesInput
    upsert?: UserUpsertWithoutReleasedTablesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReleasedTablesInput, UserUpdateWithoutReleasedTablesInput>, UserUncheckedUpdateWithoutReleasedTablesInput>
  }

  export type CombineTableItemUpdateManyWithoutCombineTableNestedInput = {
    create?: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput> | CombineTableItemCreateWithoutCombineTableInput[] | CombineTableItemUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutCombineTableInput | CombineTableItemCreateOrConnectWithoutCombineTableInput[]
    upsert?: CombineTableItemUpsertWithWhereUniqueWithoutCombineTableInput | CombineTableItemUpsertWithWhereUniqueWithoutCombineTableInput[]
    createMany?: CombineTableItemCreateManyCombineTableInputEnvelope
    set?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    disconnect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    delete?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    update?: CombineTableItemUpdateWithWhereUniqueWithoutCombineTableInput | CombineTableItemUpdateWithWhereUniqueWithoutCombineTableInput[]
    updateMany?: CombineTableItemUpdateManyWithWhereWithoutCombineTableInput | CombineTableItemUpdateManyWithWhereWithoutCombineTableInput[]
    deleteMany?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
  }

  export type TableSessionUpdateManyWithoutCombineTableNestedInput = {
    create?: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput> | TableSessionCreateWithoutCombineTableInput[] | TableSessionUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCombineTableInput | TableSessionCreateOrConnectWithoutCombineTableInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutCombineTableInput | TableSessionUpsertWithWhereUniqueWithoutCombineTableInput[]
    createMany?: TableSessionCreateManyCombineTableInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutCombineTableInput | TableSessionUpdateWithWhereUniqueWithoutCombineTableInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutCombineTableInput | TableSessionUpdateManyWithWhereWithoutCombineTableInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type CombineTableItemUncheckedUpdateManyWithoutCombineTableNestedInput = {
    create?: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput> | CombineTableItemCreateWithoutCombineTableInput[] | CombineTableItemUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: CombineTableItemCreateOrConnectWithoutCombineTableInput | CombineTableItemCreateOrConnectWithoutCombineTableInput[]
    upsert?: CombineTableItemUpsertWithWhereUniqueWithoutCombineTableInput | CombineTableItemUpsertWithWhereUniqueWithoutCombineTableInput[]
    createMany?: CombineTableItemCreateManyCombineTableInputEnvelope
    set?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    disconnect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    delete?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    connect?: CombineTableItemWhereUniqueInput | CombineTableItemWhereUniqueInput[]
    update?: CombineTableItemUpdateWithWhereUniqueWithoutCombineTableInput | CombineTableItemUpdateWithWhereUniqueWithoutCombineTableInput[]
    updateMany?: CombineTableItemUpdateManyWithWhereWithoutCombineTableInput | CombineTableItemUpdateManyWithWhereWithoutCombineTableInput[]
    deleteMany?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
  }

  export type TableSessionUncheckedUpdateManyWithoutCombineTableNestedInput = {
    create?: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput> | TableSessionCreateWithoutCombineTableInput[] | TableSessionUncheckedCreateWithoutCombineTableInput[]
    connectOrCreate?: TableSessionCreateOrConnectWithoutCombineTableInput | TableSessionCreateOrConnectWithoutCombineTableInput[]
    upsert?: TableSessionUpsertWithWhereUniqueWithoutCombineTableInput | TableSessionUpsertWithWhereUniqueWithoutCombineTableInput[]
    createMany?: TableSessionCreateManyCombineTableInputEnvelope
    set?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    disconnect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    delete?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    connect?: TableSessionWhereUniqueInput | TableSessionWhereUniqueInput[]
    update?: TableSessionUpdateWithWhereUniqueWithoutCombineTableInput | TableSessionUpdateWithWhereUniqueWithoutCombineTableInput[]
    updateMany?: TableSessionUpdateManyWithWhereWithoutCombineTableInput | TableSessionUpdateManyWithWhereWithoutCombineTableInput[]
    deleteMany?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
  }

  export type CombineTableCreateNestedOneWithoutTablesInput = {
    create?: XOR<CombineTableCreateWithoutTablesInput, CombineTableUncheckedCreateWithoutTablesInput>
    connectOrCreate?: CombineTableCreateOrConnectWithoutTablesInput
    connect?: CombineTableWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutCombineTableItemsInput = {
    create?: XOR<TableCreateWithoutCombineTableItemsInput, TableUncheckedCreateWithoutCombineTableItemsInput>
    connectOrCreate?: TableCreateOrConnectWithoutCombineTableItemsInput
    connect?: TableWhereUniqueInput
  }

  export type CombineTableUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<CombineTableCreateWithoutTablesInput, CombineTableUncheckedCreateWithoutTablesInput>
    connectOrCreate?: CombineTableCreateOrConnectWithoutTablesInput
    upsert?: CombineTableUpsertWithoutTablesInput
    connect?: CombineTableWhereUniqueInput
    update?: XOR<XOR<CombineTableUpdateToOneWithWhereWithoutTablesInput, CombineTableUpdateWithoutTablesInput>, CombineTableUncheckedUpdateWithoutTablesInput>
  }

  export type TableUpdateOneRequiredWithoutCombineTableItemsNestedInput = {
    create?: XOR<TableCreateWithoutCombineTableItemsInput, TableUncheckedCreateWithoutCombineTableItemsInput>
    connectOrCreate?: TableCreateOrConnectWithoutCombineTableItemsInput
    upsert?: TableUpsertWithoutCombineTableItemsInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutCombineTableItemsInput, TableUpdateWithoutCombineTableItemsInput>, TableUncheckedUpdateWithoutCombineTableItemsInput>
  }

  export type TableCreateNestedOneWithoutTableSessionsInput = {
    create?: XOR<TableCreateWithoutTableSessionsInput, TableUncheckedCreateWithoutTableSessionsInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableSessionsInput
    connect?: TableWhereUniqueInput
  }

  export type CombineTableCreateNestedOneWithoutTableSessionsInput = {
    create?: XOR<CombineTableCreateWithoutTableSessionsInput, CombineTableUncheckedCreateWithoutTableSessionsInput>
    connectOrCreate?: CombineTableCreateOrConnectWithoutTableSessionsInput
    connect?: CombineTableWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTablesSessionOpenedInput = {
    create?: XOR<UserCreateWithoutTablesSessionOpenedInput, UserUncheckedCreateWithoutTablesSessionOpenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTablesSessionOpenedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTablesSessionClosedInput = {
    create?: XOR<UserCreateWithoutTablesSessionClosedInput, UserUncheckedCreateWithoutTablesSessionClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTablesSessionClosedInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutTableSessionInput = {
    create?: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput> | OrderCreateWithoutTableSessionInput[] | OrderUncheckedCreateWithoutTableSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableSessionInput | OrderCreateOrConnectWithoutTableSessionInput[]
    createMany?: OrderCreateManyTableSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTableSessionInput = {
    create?: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput> | OrderCreateWithoutTableSessionInput[] | OrderUncheckedCreateWithoutTableSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableSessionInput | OrderCreateOrConnectWithoutTableSessionInput[]
    createMany?: OrderCreateManyTableSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TableUpdateOneWithoutTableSessionsNestedInput = {
    create?: XOR<TableCreateWithoutTableSessionsInput, TableUncheckedCreateWithoutTableSessionsInput>
    connectOrCreate?: TableCreateOrConnectWithoutTableSessionsInput
    upsert?: TableUpsertWithoutTableSessionsInput
    disconnect?: TableWhereInput | boolean
    delete?: TableWhereInput | boolean
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutTableSessionsInput, TableUpdateWithoutTableSessionsInput>, TableUncheckedUpdateWithoutTableSessionsInput>
  }

  export type CombineTableUpdateOneWithoutTableSessionsNestedInput = {
    create?: XOR<CombineTableCreateWithoutTableSessionsInput, CombineTableUncheckedCreateWithoutTableSessionsInput>
    connectOrCreate?: CombineTableCreateOrConnectWithoutTableSessionsInput
    upsert?: CombineTableUpsertWithoutTableSessionsInput
    disconnect?: CombineTableWhereInput | boolean
    delete?: CombineTableWhereInput | boolean
    connect?: CombineTableWhereUniqueInput
    update?: XOR<XOR<CombineTableUpdateToOneWithWhereWithoutTableSessionsInput, CombineTableUpdateWithoutTableSessionsInput>, CombineTableUncheckedUpdateWithoutTableSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput = {
    create?: XOR<UserCreateWithoutTablesSessionOpenedInput, UserUncheckedCreateWithoutTablesSessionOpenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTablesSessionOpenedInput
    upsert?: UserUpsertWithoutTablesSessionOpenedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTablesSessionOpenedInput, UserUpdateWithoutTablesSessionOpenedInput>, UserUncheckedUpdateWithoutTablesSessionOpenedInput>
  }

  export type UserUpdateOneWithoutTablesSessionClosedNestedInput = {
    create?: XOR<UserCreateWithoutTablesSessionClosedInput, UserUncheckedCreateWithoutTablesSessionClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTablesSessionClosedInput
    upsert?: UserUpsertWithoutTablesSessionClosedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTablesSessionClosedInput, UserUpdateWithoutTablesSessionClosedInput>, UserUncheckedUpdateWithoutTablesSessionClosedInput>
  }

  export type OrderUpdateManyWithoutTableSessionNestedInput = {
    create?: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput> | OrderCreateWithoutTableSessionInput[] | OrderUncheckedCreateWithoutTableSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableSessionInput | OrderCreateOrConnectWithoutTableSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTableSessionInput | OrderUpsertWithWhereUniqueWithoutTableSessionInput[]
    createMany?: OrderCreateManyTableSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTableSessionInput | OrderUpdateWithWhereUniqueWithoutTableSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTableSessionInput | OrderUpdateManyWithWhereWithoutTableSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTableSessionNestedInput = {
    create?: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput> | OrderCreateWithoutTableSessionInput[] | OrderUncheckedCreateWithoutTableSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableSessionInput | OrderCreateOrConnectWithoutTableSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTableSessionInput | OrderUpsertWithWhereUniqueWithoutTableSessionInput[]
    createMany?: OrderCreateManyTableSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTableSessionInput | OrderUpdateWithWhereUniqueWithoutTableSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTableSessionInput | OrderUpdateManyWithWhereWithoutTableSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProductStatusInput = {
    create?: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput> | ProductCreateWithoutProductStatusInput[] | ProductUncheckedCreateWithoutProductStatusInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductStatusInput | ProductCreateOrConnectWithoutProductStatusInput[]
    createMany?: ProductCreateManyProductStatusInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductStatusInput = {
    create?: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput> | ProductCreateWithoutProductStatusInput[] | ProductUncheckedCreateWithoutProductStatusInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductStatusInput | ProductCreateOrConnectWithoutProductStatusInput[]
    createMany?: ProductCreateManyProductStatusInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProductStatusNestedInput = {
    create?: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput> | ProductCreateWithoutProductStatusInput[] | ProductUncheckedCreateWithoutProductStatusInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductStatusInput | ProductCreateOrConnectWithoutProductStatusInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductStatusInput | ProductUpsertWithWhereUniqueWithoutProductStatusInput[]
    createMany?: ProductCreateManyProductStatusInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductStatusInput | ProductUpdateWithWhereUniqueWithoutProductStatusInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductStatusInput | ProductUpdateManyWithWhereWithoutProductStatusInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductStatusNestedInput = {
    create?: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput> | ProductCreateWithoutProductStatusInput[] | ProductUncheckedCreateWithoutProductStatusInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductStatusInput | ProductCreateOrConnectWithoutProductStatusInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductStatusInput | ProductUpsertWithWhereUniqueWithoutProductStatusInput[]
    createMany?: ProductCreateManyProductStatusInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductStatusInput | ProductUpdateWithWhereUniqueWithoutProductStatusInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductStatusInput | ProductUpdateManyWithWhereWithoutProductStatusInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput> | ProductCreateWithoutProductTypeInput[] | ProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductTypeInput | ProductCreateOrConnectWithoutProductTypeInput[]
    createMany?: ProductCreateManyProductTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput> | ProductCreateWithoutProductTypeInput[] | ProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductTypeInput | ProductCreateOrConnectWithoutProductTypeInput[]
    createMany?: ProductCreateManyProductTypeInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput> | ProductCreateWithoutProductTypeInput[] | ProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductTypeInput | ProductCreateOrConnectWithoutProductTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductTypeInput | ProductUpsertWithWhereUniqueWithoutProductTypeInput[]
    createMany?: ProductCreateManyProductTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductTypeInput | ProductUpdateWithWhereUniqueWithoutProductTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductTypeInput | ProductUpdateManyWithWhereWithoutProductTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput> | ProductCreateWithoutProductTypeInput[] | ProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductTypeInput | ProductCreateOrConnectWithoutProductTypeInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductTypeInput | ProductUpsertWithWhereUniqueWithoutProductTypeInput[]
    createMany?: ProductCreateManyProductTypeInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductTypeInput | ProductUpdateWithWhereUniqueWithoutProductTypeInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductTypeInput | ProductUpdateManyWithWhereWithoutProductTypeInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutProductCategoryInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput> | ProductCreateWithoutProductCategoryInput[] | ProductUncheckedCreateWithoutProductCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutProductCategoryInput | ProductCreateOrConnectWithoutProductCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutProductCategoryInput | ProductUpsertWithWhereUniqueWithoutProductCategoryInput[]
    createMany?: ProductCreateManyProductCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutProductCategoryInput | ProductUpdateWithWhereUniqueWithoutProductCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutProductCategoryInput | ProductUpdateManyWithWhereWithoutProductCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductTypeCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductTypeCreateWithoutProductsInput, ProductTypeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutProductsInput
    connect?: ProductTypeWhereUniqueInput
  }

  export type ProductCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductStatusCreateNestedOneWithoutProductsInput = {
    create?: XOR<ProductStatusCreateWithoutProductsInput, ProductStatusUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductStatusCreateOrConnectWithoutProductsInput
    connect?: ProductStatusWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductTypeUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductTypeCreateWithoutProductsInput, ProductTypeUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutProductsInput
    upsert?: ProductTypeUpsertWithoutProductsInput
    connect?: ProductTypeWhereUniqueInput
    update?: XOR<XOR<ProductTypeUpdateToOneWithWhereWithoutProductsInput, ProductTypeUpdateWithoutProductsInput>, ProductTypeUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductsInput
    upsert?: ProductCategoryUpsertWithoutProductsInput
    connect?: ProductCategoryWhereUniqueInput
    update?: XOR<XOR<ProductCategoryUpdateToOneWithWhereWithoutProductsInput, ProductCategoryUpdateWithoutProductsInput>, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateOneWithoutProductsNestedInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    upsert?: BrandUpsertWithoutProductsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductsInput, BrandUpdateWithoutProductsInput>, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type ProductStatusUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<ProductStatusCreateWithoutProductsInput, ProductStatusUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ProductStatusCreateOrConnectWithoutProductsInput
    upsert?: ProductStatusUpsertWithoutProductsInput
    connect?: ProductStatusWhereUniqueInput
    update?: XOR<XOR<ProductStatusUpdateToOneWithWhereWithoutProductsInput, ProductStatusUpdateWithoutProductsInput>, ProductStatusUncheckedUpdateWithoutProductsInput>
  }

  export type InventoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput> | InventoryCreateWithoutProductInput[] | InventoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutProductInput | InventoryCreateOrConnectWithoutProductInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutProductInput | InventoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: InventoryCreateManyProductInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutProductInput | InventoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutProductInput | InventoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStatusInput | OrderUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStatusInput | OrderUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStatusInput | OrderUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStatusInput | OrderUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStatusInput | OrderUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStatusInput | OrderUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderItemCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput> | OrderItemCreateWithoutStatusInput[] | OrderItemUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutStatusInput | OrderItemCreateOrConnectWithoutStatusInput[]
    createMany?: OrderItemCreateManyStatusInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput> | OrderItemCreateWithoutStatusInput[] | OrderItemUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutStatusInput | OrderItemCreateOrConnectWithoutStatusInput[]
    createMany?: OrderItemCreateManyStatusInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput> | OrderItemCreateWithoutStatusInput[] | OrderItemUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutStatusInput | OrderItemCreateOrConnectWithoutStatusInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutStatusInput | OrderItemUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderItemCreateManyStatusInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutStatusInput | OrderItemUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutStatusInput | OrderItemUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput> | OrderItemCreateWithoutStatusInput[] | OrderItemUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutStatusInput | OrderItemCreateOrConnectWithoutStatusInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutStatusInput | OrderItemUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderItemCreateManyStatusInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutStatusInput | OrderItemUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutStatusInput | OrderItemUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TableSessionCreateNestedOneWithoutOrdersInput = {
    create?: XOR<TableSessionCreateWithoutOrdersInput, TableSessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TableSessionCreateOrConnectWithoutOrdersInput
    connect?: TableSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersCreatedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderStatusCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersClosedInput = {
    create?: XOR<UserCreateWithoutOrdersClosedInput, UserUncheckedCreateWithoutOrdersClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersClosedInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type TableSessionUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<TableSessionCreateWithoutOrdersInput, TableSessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: TableSessionCreateOrConnectWithoutOrdersInput
    upsert?: TableSessionUpsertWithoutOrdersInput
    disconnect?: TableSessionWhereInput | boolean
    delete?: TableSessionWhereInput | boolean
    connect?: TableSessionWhereUniqueInput
    update?: XOR<XOR<TableSessionUpdateToOneWithWhereWithoutOrdersInput, TableSessionUpdateWithoutOrdersInput>, TableSessionUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersCreatedNestedInput = {
    create?: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersCreatedInput
    upsert?: UserUpsertWithoutOrdersCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersCreatedInput, UserUpdateWithoutOrdersCreatedInput>, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type CustomerUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrdersInput
    upsert?: CustomerUpsertWithoutOrdersInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrdersInput, CustomerUpdateWithoutOrdersInput>, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    upsert?: OrderStatusUpsertWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
    update?: XOR<XOR<OrderStatusUpdateToOneWithWhereWithoutOrdersInput, OrderStatusUpdateWithoutOrdersInput>, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneWithoutOrdersClosedNestedInput = {
    create?: XOR<UserCreateWithoutOrdersClosedInput, UserUncheckedCreateWithoutOrdersClosedInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersClosedInput
    upsert?: UserUpsertWithoutOrdersClosedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersClosedInput, UserUpdateWithoutOrdersClosedInput>, UserUncheckedUpdateWithoutOrdersClosedInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderItemStatusCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderItemStatusCreateWithoutOrderItemsInput, OrderItemStatusUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderItemStatusCreateOrConnectWithoutOrderItemsInput
    connect?: OrderItemStatusWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderItemStatusUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderItemStatusCreateWithoutOrderItemsInput, OrderItemStatusUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderItemStatusCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderItemStatusUpsertWithoutOrderItemsInput
    connect?: OrderItemStatusWhereUniqueInput
    update?: XOR<XOR<OrderItemStatusUpdateToOneWithWhereWithoutOrderItemsInput, OrderItemStatusUpdateWithoutOrderItemsInput>, OrderItemStatusUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PaymentCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type CashBoxCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<CashBoxCreateWithoutPaymentsInput, CashBoxUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CashBoxCreateOrConnectWithoutPaymentsInput
    connect?: CashBoxWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentsReceivedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPaymentsMadeInput = {
    create?: XOR<CustomerCreateWithoutPaymentsMadeInput, CustomerUncheckedCreateWithoutPaymentsMadeInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsMadeInput
    connect?: CustomerWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type CashBoxUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<CashBoxCreateWithoutPaymentsInput, CashBoxUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: CashBoxCreateOrConnectWithoutPaymentsInput
    upsert?: CashBoxUpsertWithoutPaymentsInput
    connect?: CashBoxWhereUniqueInput
    update?: XOR<XOR<CashBoxUpdateToOneWithWhereWithoutPaymentsInput, CashBoxUpdateWithoutPaymentsInput>, CashBoxUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentsInput
    upsert?: PaymentMethodUpsertWithoutPaymentsInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput, PaymentMethodUpdateWithoutPaymentsInput>, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsReceivedInput
    upsert?: UserUpsertWithoutPaymentsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsReceivedInput, UserUpdateWithoutPaymentsReceivedInput>, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type CustomerUpdateOneWithoutPaymentsMadeNestedInput = {
    create?: XOR<CustomerCreateWithoutPaymentsMadeInput, CustomerUncheckedCreateWithoutPaymentsMadeInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPaymentsMadeInput
    upsert?: CustomerUpsertWithoutPaymentsMadeInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPaymentsMadeInput, CustomerUpdateWithoutPaymentsMadeInput>, CustomerUncheckedUpdateWithoutPaymentsMadeInput>
  }

  export type InventoryMovementCreateNestedManyWithoutMovementTypeInput = {
    create?: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput> | InventoryMovementCreateWithoutMovementTypeInput[] | InventoryMovementUncheckedCreateWithoutMovementTypeInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMovementTypeInput | InventoryMovementCreateOrConnectWithoutMovementTypeInput[]
    createMany?: InventoryMovementCreateManyMovementTypeInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutMovementTypeInput = {
    create?: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput> | InventoryMovementCreateWithoutMovementTypeInput[] | InventoryMovementUncheckedCreateWithoutMovementTypeInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMovementTypeInput | InventoryMovementCreateOrConnectWithoutMovementTypeInput[]
    createMany?: InventoryMovementCreateManyMovementTypeInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUpdateManyWithoutMovementTypeNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput> | InventoryMovementCreateWithoutMovementTypeInput[] | InventoryMovementUncheckedCreateWithoutMovementTypeInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMovementTypeInput | InventoryMovementCreateOrConnectWithoutMovementTypeInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutMovementTypeInput | InventoryMovementUpsertWithWhereUniqueWithoutMovementTypeInput[]
    createMany?: InventoryMovementCreateManyMovementTypeInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutMovementTypeInput | InventoryMovementUpdateWithWhereUniqueWithoutMovementTypeInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutMovementTypeInput | InventoryMovementUpdateManyWithWhereWithoutMovementTypeInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutMovementTypeNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput> | InventoryMovementCreateWithoutMovementTypeInput[] | InventoryMovementUncheckedCreateWithoutMovementTypeInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutMovementTypeInput | InventoryMovementCreateOrConnectWithoutMovementTypeInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutMovementTypeInput | InventoryMovementUpsertWithWhereUniqueWithoutMovementTypeInput[]
    createMany?: InventoryMovementCreateManyMovementTypeInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutMovementTypeInput | InventoryMovementUpdateWithWhereUniqueWithoutMovementTypeInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutMovementTypeInput | InventoryMovementUpdateManyWithWhereWithoutMovementTypeInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInventoriesInput = {
    create?: XOR<ProductCreateWithoutInventoriesInput, ProductUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryMovementCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type InventoryMovementUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutInventoriesNestedInput = {
    create?: XOR<ProductCreateWithoutInventoriesInput, ProductUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInventoriesInput
    upsert?: ProductUpsertWithoutInventoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInventoriesInput, ProductUpdateWithoutInventoriesInput>, ProductUncheckedUpdateWithoutInventoriesInput>
  }

  export type InventoryMovementUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput | InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput | InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutInventoryInput | InventoryMovementUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryMovementUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput> | InventoryMovementCreateWithoutInventoryInput[] | InventoryMovementUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: InventoryMovementCreateOrConnectWithoutInventoryInput | InventoryMovementCreateOrConnectWithoutInventoryInput[]
    upsert?: InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput | InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: InventoryMovementCreateManyInventoryInputEnvelope
    set?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    disconnect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    delete?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    connect?: InventoryMovementWhereUniqueInput | InventoryMovementWhereUniqueInput[]
    update?: InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput | InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: InventoryMovementUpdateManyWithWhereWithoutInventoryInput | InventoryMovementUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<InventoryCreateWithoutInventoryMovementsInput, InventoryUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryMovementsInput
    connect?: InventoryWhereUniqueInput
  }

  export type InventoryMovementTypeCreateNestedOneWithoutMovementsInput = {
    create?: XOR<InventoryMovementTypeCreateWithoutMovementsInput, InventoryMovementTypeUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryMovementTypeCreateOrConnectWithoutMovementsInput
    connect?: InventoryMovementTypeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventoryMovementsInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<InventoryCreateWithoutInventoryMovementsInput, InventoryUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutInventoryMovementsInput
    upsert?: InventoryUpsertWithoutInventoryMovementsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutInventoryMovementsInput, InventoryUpdateWithoutInventoryMovementsInput>, InventoryUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type InventoryMovementTypeUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<InventoryMovementTypeCreateWithoutMovementsInput, InventoryMovementTypeUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: InventoryMovementTypeCreateOrConnectWithoutMovementsInput
    upsert?: InventoryMovementTypeUpsertWithoutMovementsInput
    connect?: InventoryMovementTypeWhereUniqueInput
    update?: XOR<XOR<InventoryMovementTypeUpdateToOneWithWhereWithoutMovementsInput, InventoryMovementTypeUpdateWithoutMovementsInput>, InventoryMovementTypeUncheckedUpdateWithoutMovementsInput>
  }

  export type UserUpdateOneRequiredWithoutInventoryMovementsNestedInput = {
    create?: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventoryMovementsInput
    upsert?: UserUpsertWithoutInventoryMovementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventoryMovementsInput, UserUpdateWithoutInventoryMovementsInput>, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutLogsInput = {
    create?: XOR<CustomerCreateWithoutLogsInput, CustomerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLogsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type CustomerUpdateOneWithoutLogsNestedInput = {
    create?: XOR<CustomerCreateWithoutLogsInput, CustomerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutLogsInput
    upsert?: CustomerUpsertWithoutLogsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutLogsInput, CustomerUpdateWithoutLogsInput>, CustomerUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserCreateWithoutCreatedThemesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutCreatedThemesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutCreatedThemesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedThemesInput, UserUncheckedCreateWithoutCreatedThemesInput>
  }

  export type UserCreateWithoutThemeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutThemeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutThemeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput>
  }

  export type UserCreateManyThemeInputEnvelope = {
    data: UserCreateManyThemeInput | UserCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutThemeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutThemeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutThemeInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput>
  }

  export type CustomerCreateManyThemeInputEnvelope = {
    data: CustomerCreateManyThemeInput | CustomerCreateManyThemeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedThemesInput = {
    update: XOR<UserUpdateWithoutCreatedThemesInput, UserUncheckedUpdateWithoutCreatedThemesInput>
    create: XOR<UserCreateWithoutCreatedThemesInput, UserUncheckedCreateWithoutCreatedThemesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedThemesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedThemesInput, UserUncheckedUpdateWithoutCreatedThemesInput>
  }

  export type UserUpdateWithoutCreatedThemesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedThemesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutThemeInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutThemeInput, UserUncheckedUpdateWithoutThemeInput>
    create: XOR<UserCreateWithoutThemeInput, UserUncheckedCreateWithoutThemeInput>
  }

  export type UserUpdateWithWhereUniqueWithoutThemeInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutThemeInput, UserUncheckedUpdateWithoutThemeInput>
  }

  export type UserUpdateManyWithWhereWithoutThemeInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutThemeInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    documentNumber?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    pin?: StringNullableFilter<"User"> | string | null
    fullName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    hireDate?: DateTimeNullableFilter<"User"> | Date | string | null
    salary?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: StringNullableFilter<"User"> | string | null
    emergencyContactPhone?: StringNullableFilter<"User"> | string | null
    documentTypeName?: StringFilter<"User"> | string
    roleName?: StringFilter<"User"> | string
    accountStatusCode?: StringFilter<"User"> | string
    themeName?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    createdBy?: StringFilter<"User"> | string
    updatedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    updatedBy?: StringNullableFilter<"User"> | string | null
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
  }

  export type CustomerUpsertWithWhereUniqueWithoutThemeInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutThemeInput, CustomerUncheckedUpdateWithoutThemeInput>
    create: XOR<CustomerCreateWithoutThemeInput, CustomerUncheckedCreateWithoutThemeInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutThemeInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutThemeInput, CustomerUncheckedUpdateWithoutThemeInput>
  }

  export type CustomerUpdateManyWithWhereWithoutThemeInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutThemeInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    documentNumber?: StringFilter<"Customer"> | string
    username?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    password?: StringNullableFilter<"Customer"> | string | null
    fullName?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    documentTypeName?: StringFilter<"Customer"> | string
    accountStatusCode?: StringFilter<"Customer"> | string
    themeName?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    createdBy?: StringFilter<"Customer"> | string
    updatedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    updatedBy?: StringNullableFilter<"Customer"> | string | null
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    deletedBy?: StringNullableFilter<"Customer"> | string | null
  }

  export type CustomerCreateWithoutDocumentTypeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDocumentTypeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDocumentTypeInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput>
  }

  export type CustomerCreateManyDocumentTypeInputEnvelope = {
    data: CustomerCreateManyDocumentTypeInput | CustomerCreateManyDocumentTypeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDocumentTypeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutDocumentTypeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutDocumentTypeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput>
  }

  export type UserCreateManyDocumentTypeInputEnvelope = {
    data: UserCreateManyDocumentTypeInput | UserCreateManyDocumentTypeInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutDocumentTypeInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutDocumentTypeInput, CustomerUncheckedUpdateWithoutDocumentTypeInput>
    create: XOR<CustomerCreateWithoutDocumentTypeInput, CustomerUncheckedCreateWithoutDocumentTypeInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutDocumentTypeInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutDocumentTypeInput, CustomerUncheckedUpdateWithoutDocumentTypeInput>
  }

  export type CustomerUpdateManyWithWhereWithoutDocumentTypeInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutDocumentTypeInput>
  }

  export type UserUpsertWithWhereUniqueWithoutDocumentTypeInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDocumentTypeInput, UserUncheckedUpdateWithoutDocumentTypeInput>
    create: XOR<UserCreateWithoutDocumentTypeInput, UserUncheckedCreateWithoutDocumentTypeInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDocumentTypeInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDocumentTypeInput, UserUncheckedUpdateWithoutDocumentTypeInput>
  }

  export type UserUpdateManyWithWhereWithoutDocumentTypeInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDocumentTypeInput>
  }

  export type UserCreateWithoutAccountStatusInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutAccountStatusInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutAccountStatusInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput>
  }

  export type UserCreateManyAccountStatusInputEnvelope = {
    data: UserCreateManyAccountStatusInput | UserCreateManyAccountStatusInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutAccountStatusInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAccountStatusInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAccountStatusInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput>
  }

  export type CustomerCreateManyAccountStatusInputEnvelope = {
    data: CustomerCreateManyAccountStatusInput | CustomerCreateManyAccountStatusInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutAccountStatusInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAccountStatusInput, UserUncheckedUpdateWithoutAccountStatusInput>
    create: XOR<UserCreateWithoutAccountStatusInput, UserUncheckedCreateWithoutAccountStatusInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAccountStatusInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAccountStatusInput, UserUncheckedUpdateWithoutAccountStatusInput>
  }

  export type UserUpdateManyWithWhereWithoutAccountStatusInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAccountStatusInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutAccountStatusInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAccountStatusInput, CustomerUncheckedUpdateWithoutAccountStatusInput>
    create: XOR<CustomerCreateWithoutAccountStatusInput, CustomerUncheckedCreateWithoutAccountStatusInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAccountStatusInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAccountStatusInput, CustomerUncheckedUpdateWithoutAccountStatusInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAccountStatusInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutAccountStatusInput>
  }

  export type PermissionCreateWithoutCategoryInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    rolePermissions?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateWithoutCategoryInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionCreateOrConnectWithoutCategoryInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput>
  }

  export type PermissionCreateManyCategoryInputEnvelope = {
    data: PermissionCreateManyCategoryInput | PermissionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PermissionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutCategoryInput, PermissionUncheckedUpdateWithoutCategoryInput>
    create: XOR<PermissionCreateWithoutCategoryInput, PermissionUncheckedCreateWithoutCategoryInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutCategoryInput, PermissionUncheckedUpdateWithoutCategoryInput>
  }

  export type PermissionUpdateManyWithWhereWithoutCategoryInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    code?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    categoryCode?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    createdBy?: StringFilter<"Permission"> | string
    updatedAt?: DateTimeNullableFilter<"Permission"> | Date | string | null
    updatedBy?: StringNullableFilter<"Permission"> | string | null
  }

  export type PermissionCategoryCreateWithoutPermissionsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionCategoryUncheckedCreateWithoutPermissionsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionCategoryCreateOrConnectWithoutPermissionsInput = {
    where: PermissionCategoryWhereUniqueInput
    create: XOR<PermissionCategoryCreateWithoutPermissionsInput, PermissionCategoryUncheckedCreateWithoutPermissionsInput>
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    role: RoleCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: number
    roleName: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCategoryUpsertWithoutPermissionsInput = {
    update: XOR<PermissionCategoryUpdateWithoutPermissionsInput, PermissionCategoryUncheckedUpdateWithoutPermissionsInput>
    create: XOR<PermissionCategoryCreateWithoutPermissionsInput, PermissionCategoryUncheckedCreateWithoutPermissionsInput>
    where?: PermissionCategoryWhereInput
  }

  export type PermissionCategoryUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: PermissionCategoryWhereInput
    data: XOR<PermissionCategoryUpdateWithoutPermissionsInput, PermissionCategoryUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionCategoryUpdateWithoutPermissionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCategoryUncheckedUpdateWithoutPermissionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: IntFilter<"RolePermission"> | number
    roleName?: StringFilter<"RolePermission"> | string
    permissionCode?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    createdBy?: StringFilter<"RolePermission"> | string
    updatedAt?: DateTimeNullableFilter<"RolePermission"> | Date | string | null
    updatedBy?: StringNullableFilter<"RolePermission"> | string | null
  }

  export type RolePermissionCreateWithoutRoleInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    permission: PermissionCreateNestedOneWithoutRolePermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: number
    permissionCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRoleInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type RoleCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutRolePermissionsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutRolePermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
  }

  export type PermissionCreateWithoutRolePermissionsInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    category: PermissionCategoryCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutRolePermissionsInput = {
    code: string
    name: string
    description?: string | null
    categoryCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionCreateOrConnectWithoutRolePermissionsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
  }

  export type RoleUpsertWithoutRolePermissionsInput = {
    update: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<RoleCreateWithoutRolePermissionsInput, RoleUncheckedCreateWithoutRolePermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolePermissionsInput, RoleUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type RoleUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolePermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolePermissionsInput = {
    update: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
    create: XOR<PermissionCreateWithoutRolePermissionsInput, PermissionUncheckedCreateWithoutRolePermissionsInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolePermissionsInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolePermissionsInput, PermissionUncheckedUpdateWithoutRolePermissionsInput>
  }

  export type PermissionUpdateWithoutRolePermissionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    category?: PermissionCategoryUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateWithoutRolePermissionsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    categoryCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTypeCreateWithoutUsersInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customers?: CustomerCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateWithoutUsersInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customers?: CustomerUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeCreateOrConnectWithoutUsersInput = {
    where: DocumentTypeWhereUniqueInput
    create: XOR<DocumentTypeCreateWithoutUsersInput, DocumentTypeUncheckedCreateWithoutUsersInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    rolePermissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    rolePermissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type AccountStatusCreateWithoutUsersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    customers?: CustomerCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusUncheckedCreateWithoutUsersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    customers?: CustomerUncheckedCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusCreateOrConnectWithoutUsersInput = {
    where: AccountStatusWhereUniqueInput
    create: XOR<AccountStatusCreateWithoutUsersInput, AccountStatusUncheckedCreateWithoutUsersInput>
  }

  export type ThemeCreateWithoutUsersUsingThisThemeInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    user?: UserCreateNestedOneWithoutCreatedThemesInput
    customerUsingThisTheme?: CustomerCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutUsersUsingThisThemeInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customerUsingThisTheme?: CustomerUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutUsersUsingThisThemeInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutUsersUsingThisThemeInput, ThemeUncheckedCreateWithoutUsersUsingThisThemeInput>
  }

  export type CashBoxCreateWithoutOpenerInput = {
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    closer?: UserCreateNestedOneWithoutClosedCashBoxesInput
    payments?: PaymentCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxUncheckedCreateWithoutOpenerInput = {
    id?: number
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxCreateOrConnectWithoutOpenerInput = {
    where: CashBoxWhereUniqueInput
    create: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput>
  }

  export type CashBoxCreateManyOpenerInputEnvelope = {
    data: CashBoxCreateManyOpenerInput | CashBoxCreateManyOpenerInput[]
    skipDuplicates?: boolean
  }

  export type CashBoxCreateWithoutCloserInput = {
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    opener: UserCreateNestedOneWithoutOpenedCashBoxesInput
    payments?: PaymentCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxUncheckedCreateWithoutCloserInput = {
    id?: number
    openerUserDocument: string
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payments?: PaymentUncheckedCreateNestedManyWithoutCashBoxInput
  }

  export type CashBoxCreateOrConnectWithoutCloserInput = {
    where: CashBoxWhereUniqueInput
    create: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput>
  }

  export type CashBoxCreateManyCloserInputEnvelope = {
    data: CashBoxCreateManyCloserInput | CashBoxCreateManyCloserInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementCreateWithoutUserInput = {
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventory: InventoryCreateNestedOneWithoutInventoryMovementsInput
    movementType: InventoryMovementTypeCreateNestedOneWithoutMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutUserInput = {
    id?: number
    inventoryId: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementCreateOrConnectWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementCreateManyUserInputEnvelope = {
    data: InventoryMovementCreateManyUserInput | InventoryMovementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    createdAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    customerDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    customer?: CustomerCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    customerDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CombineTableCreateWithoutCombinerInput = {
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    releaser?: UserCreateNestedOneWithoutReleasedTablesInput
    tables?: CombineTableItemCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUncheckedCreateWithoutCombinerInput = {
    id?: number
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: CombineTableItemUncheckedCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableCreateOrConnectWithoutCombinerInput = {
    where: CombineTableWhereUniqueInput
    create: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput>
  }

  export type CombineTableCreateManyCombinerInputEnvelope = {
    data: CombineTableCreateManyCombinerInput | CombineTableCreateManyCombinerInput[]
    skipDuplicates?: boolean
  }

  export type CombineTableCreateWithoutReleaserInput = {
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combiner: UserCreateNestedOneWithoutCombinedTablesInput
    tables?: CombineTableItemCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUncheckedCreateWithoutReleaserInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: CombineTableItemUncheckedCreateNestedManyWithoutCombineTableInput
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableCreateOrConnectWithoutReleaserInput = {
    where: CombineTableWhereUniqueInput
    create: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput>
  }

  export type CombineTableCreateManyReleaserInputEnvelope = {
    data: CombineTableCreateManyReleaserInput | CombineTableCreateManyReleaserInput[]
    skipDuplicates?: boolean
  }

  export type TableSessionCreateWithoutOpenerInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table?: TableCreateNestedOneWithoutTableSessionsInput
    combineTable?: CombineTableCreateNestedOneWithoutTableSessionsInput
    closer?: UserCreateNestedOneWithoutTablesSessionClosedInput
    orders?: OrderCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUncheckedCreateWithoutOpenerInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionCreateOrConnectWithoutOpenerInput = {
    where: TableSessionWhereUniqueInput
    create: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput>
  }

  export type TableSessionCreateManyOpenerInputEnvelope = {
    data: TableSessionCreateManyOpenerInput | TableSessionCreateManyOpenerInput[]
    skipDuplicates?: boolean
  }

  export type TableSessionCreateWithoutCloserInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table?: TableCreateNestedOneWithoutTableSessionsInput
    combineTable?: CombineTableCreateNestedOneWithoutTableSessionsInput
    opener: UserCreateNestedOneWithoutTablesSessionOpenedInput
    orders?: OrderCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUncheckedCreateWithoutCloserInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionCreateOrConnectWithoutCloserInput = {
    where: TableSessionWhereUniqueInput
    create: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput>
  }

  export type TableSessionCreateManyCloserInputEnvelope = {
    data: TableSessionCreateManyCloserInput | TableSessionCreateManyCloserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCreatorInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCreatorInput = {
    code: string
    tableSessionId?: number | null
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCreatorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput>
  }

  export type OrderCreateManyCreatorInputEnvelope = {
    data: OrderCreateManyCreatorInput | OrderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCloserInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCloserInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCloserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput>
  }

  export type OrderCreateManyCloserInputEnvelope = {
    data: OrderCreateManyCloserInput | OrderCreateManyCloserInput[]
    skipDuplicates?: boolean
  }

  export type ThemeCreateWithoutUserInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    usersUsingThisTheme?: UserCreateNestedManyWithoutThemeInput
    customerUsingThisTheme?: CustomerCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutUserInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    usersUsingThisTheme?: UserUncheckedCreateNestedManyWithoutThemeInput
    customerUsingThisTheme?: CustomerUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutUserInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput>
  }

  export type ThemeCreateManyUserInputEnvelope = {
    data: ThemeCreateManyUserInput | ThemeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReceiveUserInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutPaymentInput
    cashBox: CashBoxCreateNestedOneWithoutPaymentsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
    paidCustomer?: CustomerCreateNestedOneWithoutPaymentsMadeInput
  }

  export type PaymentUncheckedCreateWithoutReceiveUserInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutReceiveUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput>
  }

  export type PaymentCreateManyReceiveUserInputEnvelope = {
    data: PaymentCreateManyReceiveUserInput | PaymentCreateManyReceiveUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTypeUpsertWithoutUsersInput = {
    update: XOR<DocumentTypeUpdateWithoutUsersInput, DocumentTypeUncheckedUpdateWithoutUsersInput>
    create: XOR<DocumentTypeCreateWithoutUsersInput, DocumentTypeUncheckedCreateWithoutUsersInput>
    where?: DocumentTypeWhereInput
  }

  export type DocumentTypeUpdateToOneWithWhereWithoutUsersInput = {
    where?: DocumentTypeWhereInput
    data: XOR<DocumentTypeUpdateWithoutUsersInput, DocumentTypeUncheckedUpdateWithoutUsersInput>
  }

  export type DocumentTypeUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type AccountStatusUpsertWithoutUsersInput = {
    update: XOR<AccountStatusUpdateWithoutUsersInput, AccountStatusUncheckedUpdateWithoutUsersInput>
    create: XOR<AccountStatusCreateWithoutUsersInput, AccountStatusUncheckedCreateWithoutUsersInput>
    where?: AccountStatusWhereInput
  }

  export type AccountStatusUpdateToOneWithWhereWithoutUsersInput = {
    where?: AccountStatusWhereInput
    data: XOR<AccountStatusUpdateWithoutUsersInput, AccountStatusUncheckedUpdateWithoutUsersInput>
  }

  export type AccountStatusUpdateWithoutUsersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUpdateManyWithoutAccountStatusNestedInput
  }

  export type AccountStatusUncheckedUpdateWithoutUsersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customers?: CustomerUncheckedUpdateManyWithoutAccountStatusNestedInput
  }

  export type ThemeUpsertWithoutUsersUsingThisThemeInput = {
    update: XOR<ThemeUpdateWithoutUsersUsingThisThemeInput, ThemeUncheckedUpdateWithoutUsersUsingThisThemeInput>
    create: XOR<ThemeCreateWithoutUsersUsingThisThemeInput, ThemeUncheckedCreateWithoutUsersUsingThisThemeInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutUsersUsingThisThemeInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutUsersUsingThisThemeInput, ThemeUncheckedUpdateWithoutUsersUsingThisThemeInput>
  }

  export type ThemeUpdateWithoutUsersUsingThisThemeInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCreatedThemesNestedInput
    customerUsingThisTheme?: CustomerUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutUsersUsingThisThemeInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customerUsingThisTheme?: CustomerUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type CashBoxUpsertWithWhereUniqueWithoutOpenerInput = {
    where: CashBoxWhereUniqueInput
    update: XOR<CashBoxUpdateWithoutOpenerInput, CashBoxUncheckedUpdateWithoutOpenerInput>
    create: XOR<CashBoxCreateWithoutOpenerInput, CashBoxUncheckedCreateWithoutOpenerInput>
  }

  export type CashBoxUpdateWithWhereUniqueWithoutOpenerInput = {
    where: CashBoxWhereUniqueInput
    data: XOR<CashBoxUpdateWithoutOpenerInput, CashBoxUncheckedUpdateWithoutOpenerInput>
  }

  export type CashBoxUpdateManyWithWhereWithoutOpenerInput = {
    where: CashBoxScalarWhereInput
    data: XOR<CashBoxUpdateManyMutationInput, CashBoxUncheckedUpdateManyWithoutOpenerInput>
  }

  export type CashBoxScalarWhereInput = {
    AND?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
    OR?: CashBoxScalarWhereInput[]
    NOT?: CashBoxScalarWhereInput | CashBoxScalarWhereInput[]
    id?: IntFilter<"CashBox"> | number
    openerUserDocument?: StringFilter<"CashBox"> | string
    openedAt?: DateTimeFilter<"CashBox"> | Date | string
    initialAmount?: DecimalFilter<"CashBox"> | Decimal | DecimalJsLike | number | string
    closerUserDocument?: StringNullableFilter<"CashBox"> | string | null
    closedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    finalAmount?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    totalSales?: DecimalNullableFilter<"CashBox"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"CashBox"> | string | null
    updatedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    updatedBy?: StringNullableFilter<"CashBox"> | string | null
    deletedAt?: DateTimeNullableFilter<"CashBox"> | Date | string | null
    deletedBy?: StringNullableFilter<"CashBox"> | string | null
  }

  export type CashBoxUpsertWithWhereUniqueWithoutCloserInput = {
    where: CashBoxWhereUniqueInput
    update: XOR<CashBoxUpdateWithoutCloserInput, CashBoxUncheckedUpdateWithoutCloserInput>
    create: XOR<CashBoxCreateWithoutCloserInput, CashBoxUncheckedCreateWithoutCloserInput>
  }

  export type CashBoxUpdateWithWhereUniqueWithoutCloserInput = {
    where: CashBoxWhereUniqueInput
    data: XOR<CashBoxUpdateWithoutCloserInput, CashBoxUncheckedUpdateWithoutCloserInput>
  }

  export type CashBoxUpdateManyWithWhereWithoutCloserInput = {
    where: CashBoxScalarWhereInput
    data: XOR<CashBoxUpdateManyMutationInput, CashBoxUncheckedUpdateManyWithoutCloserInput>
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryMovementCreateWithoutUserInput, InventoryMovementUncheckedCreateWithoutUserInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutUserInput, InventoryMovementUncheckedUpdateWithoutUserInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutUserInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryMovementScalarWhereInput = {
    AND?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    OR?: InventoryMovementScalarWhereInput[]
    NOT?: InventoryMovementScalarWhereInput | InventoryMovementScalarWhereInput[]
    id?: IntFilter<"InventoryMovement"> | number
    inventoryId?: IntFilter<"InventoryMovement"> | number
    movementTypeCode?: StringFilter<"InventoryMovement"> | string
    quantityMovement?: IntFilter<"InventoryMovement"> | number
    reasonDescription?: StringFilter<"InventoryMovement"> | string
    userDocumentNumber?: StringFilter<"InventoryMovement"> | string
    createdAt?: DateTimeFilter<"InventoryMovement"> | Date | string
    createdBy?: StringFilter<"InventoryMovement"> | string
    updatedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    updatedBy?: StringNullableFilter<"InventoryMovement"> | string | null
    deletedAt?: DateTimeNullableFilter<"InventoryMovement"> | Date | string | null
    deletedBy?: StringNullableFilter<"InventoryMovement"> | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    entityName?: StringFilter<"Log"> | string
    entityId?: StringNullableFilter<"Log"> | string | null
    action?: StringFilter<"Log"> | string
    message?: StringNullableFilter<"Log"> | string | null
    userDocumentNumber?: StringNullableFilter<"Log"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Log"> | string | null
    createdAt?: DateTimeFilter<"Log"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userDocumentNumber?: StringNullableFilter<"Session"> | string | null
    customerDocumentNumber?: StringNullableFilter<"Session"> | string | null
    token?: StringFilter<"Session"> | string
    deviceInfo?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    isActive?: BoolFilter<"Session"> | boolean
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    closedBy?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    createdBy?: StringFilter<"Session"> | string
    updatedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    updatedBy?: StringNullableFilter<"Session"> | string | null
    deletedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    deletedBy?: StringNullableFilter<"Session"> | string | null
  }

  export type CombineTableUpsertWithWhereUniqueWithoutCombinerInput = {
    where: CombineTableWhereUniqueInput
    update: XOR<CombineTableUpdateWithoutCombinerInput, CombineTableUncheckedUpdateWithoutCombinerInput>
    create: XOR<CombineTableCreateWithoutCombinerInput, CombineTableUncheckedCreateWithoutCombinerInput>
  }

  export type CombineTableUpdateWithWhereUniqueWithoutCombinerInput = {
    where: CombineTableWhereUniqueInput
    data: XOR<CombineTableUpdateWithoutCombinerInput, CombineTableUncheckedUpdateWithoutCombinerInput>
  }

  export type CombineTableUpdateManyWithWhereWithoutCombinerInput = {
    where: CombineTableScalarWhereInput
    data: XOR<CombineTableUpdateManyMutationInput, CombineTableUncheckedUpdateManyWithoutCombinerInput>
  }

  export type CombineTableScalarWhereInput = {
    AND?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
    OR?: CombineTableScalarWhereInput[]
    NOT?: CombineTableScalarWhereInput | CombineTableScalarWhereInput[]
    id?: IntFilter<"CombineTable"> | number
    name?: StringFilter<"CombineTable"> | string
    combinerUserDocument?: StringFilter<"CombineTable"> | string
    combineAt?: DateTimeFilter<"CombineTable"> | Date | string
    isActive?: BoolFilter<"CombineTable"> | boolean
    releaserUserDocument?: StringNullableFilter<"CombineTable"> | string | null
    releasedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTable"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTable"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTable"> | string | null
  }

  export type CombineTableUpsertWithWhereUniqueWithoutReleaserInput = {
    where: CombineTableWhereUniqueInput
    update: XOR<CombineTableUpdateWithoutReleaserInput, CombineTableUncheckedUpdateWithoutReleaserInput>
    create: XOR<CombineTableCreateWithoutReleaserInput, CombineTableUncheckedCreateWithoutReleaserInput>
  }

  export type CombineTableUpdateWithWhereUniqueWithoutReleaserInput = {
    where: CombineTableWhereUniqueInput
    data: XOR<CombineTableUpdateWithoutReleaserInput, CombineTableUncheckedUpdateWithoutReleaserInput>
  }

  export type CombineTableUpdateManyWithWhereWithoutReleaserInput = {
    where: CombineTableScalarWhereInput
    data: XOR<CombineTableUpdateManyMutationInput, CombineTableUncheckedUpdateManyWithoutReleaserInput>
  }

  export type TableSessionUpsertWithWhereUniqueWithoutOpenerInput = {
    where: TableSessionWhereUniqueInput
    update: XOR<TableSessionUpdateWithoutOpenerInput, TableSessionUncheckedUpdateWithoutOpenerInput>
    create: XOR<TableSessionCreateWithoutOpenerInput, TableSessionUncheckedCreateWithoutOpenerInput>
  }

  export type TableSessionUpdateWithWhereUniqueWithoutOpenerInput = {
    where: TableSessionWhereUniqueInput
    data: XOR<TableSessionUpdateWithoutOpenerInput, TableSessionUncheckedUpdateWithoutOpenerInput>
  }

  export type TableSessionUpdateManyWithWhereWithoutOpenerInput = {
    where: TableSessionScalarWhereInput
    data: XOR<TableSessionUpdateManyMutationInput, TableSessionUncheckedUpdateManyWithoutOpenerInput>
  }

  export type TableSessionScalarWhereInput = {
    AND?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
    OR?: TableSessionScalarWhereInput[]
    NOT?: TableSessionScalarWhereInput | TableSessionScalarWhereInput[]
    id?: IntFilter<"TableSession"> | number
    tableId?: IntNullableFilter<"TableSession"> | number | null
    combineTableId?: IntNullableFilter<"TableSession"> | number | null
    openerUserDocument?: StringFilter<"TableSession"> | string
    openedAt?: DateTimeFilter<"TableSession"> | Date | string
    numberPeople?: IntFilter<"TableSession"> | number
    isActive?: BoolFilter<"TableSession"> | boolean
    closerUserDocument?: StringNullableFilter<"TableSession"> | string | null
    closedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    updatedBy?: StringNullableFilter<"TableSession"> | string | null
    deletedAt?: DateTimeNullableFilter<"TableSession"> | Date | string | null
    deletedBy?: StringNullableFilter<"TableSession"> | string | null
  }

  export type TableSessionUpsertWithWhereUniqueWithoutCloserInput = {
    where: TableSessionWhereUniqueInput
    update: XOR<TableSessionUpdateWithoutCloserInput, TableSessionUncheckedUpdateWithoutCloserInput>
    create: XOR<TableSessionCreateWithoutCloserInput, TableSessionUncheckedCreateWithoutCloserInput>
  }

  export type TableSessionUpdateWithWhereUniqueWithoutCloserInput = {
    where: TableSessionWhereUniqueInput
    data: XOR<TableSessionUpdateWithoutCloserInput, TableSessionUncheckedUpdateWithoutCloserInput>
  }

  export type TableSessionUpdateManyWithWhereWithoutCloserInput = {
    where: TableSessionScalarWhereInput
    data: XOR<TableSessionUpdateManyMutationInput, TableSessionUncheckedUpdateManyWithoutCloserInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCreatorInput, OrderUncheckedUpdateWithoutCreatorInput>
    create: XOR<OrderCreateWithoutCreatorInput, OrderUncheckedCreateWithoutCreatorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCreatorInput, OrderUncheckedUpdateWithoutCreatorInput>
  }

  export type OrderUpdateManyWithWhereWithoutCreatorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    code?: StringFilter<"Order"> | string
    tableSessionId?: IntNullableFilter<"Order"> | number | null
    creatorUserDocument?: StringFilter<"Order"> | string
    createdAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    customerDocumentNumber?: StringFilter<"Order"> | string
    subtotalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"Order"> | string
    closerUserDocument?: StringNullableFilter<"Order"> | string | null
    closedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    updatedBy?: StringNullableFilter<"Order"> | string | null
    deletedAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deletedBy?: StringNullableFilter<"Order"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutCloserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCloserInput, OrderUncheckedUpdateWithoutCloserInput>
    create: XOR<OrderCreateWithoutCloserInput, OrderUncheckedCreateWithoutCloserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCloserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCloserInput, OrderUncheckedUpdateWithoutCloserInput>
  }

  export type OrderUpdateManyWithWhereWithoutCloserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCloserInput>
  }

  export type ThemeUpsertWithWhereUniqueWithoutUserInput = {
    where: ThemeWhereUniqueInput
    update: XOR<ThemeUpdateWithoutUserInput, ThemeUncheckedUpdateWithoutUserInput>
    create: XOR<ThemeCreateWithoutUserInput, ThemeUncheckedCreateWithoutUserInput>
  }

  export type ThemeUpdateWithWhereUniqueWithoutUserInput = {
    where: ThemeWhereUniqueInput
    data: XOR<ThemeUpdateWithoutUserInput, ThemeUncheckedUpdateWithoutUserInput>
  }

  export type ThemeUpdateManyWithWhereWithoutUserInput = {
    where: ThemeScalarWhereInput
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyWithoutUserInput>
  }

  export type ThemeScalarWhereInput = {
    AND?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    OR?: ThemeScalarWhereInput[]
    NOT?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    name?: StringFilter<"Theme"> | string
    primaryColor?: StringFilter<"Theme"> | string
    secondaryColor?: StringFilter<"Theme"> | string
    accentColor?: StringFilter<"Theme"> | string
    neutralColor?: StringFilter<"Theme"> | string
    isSystem?: BoolFilter<"Theme"> | boolean
    isPublic?: BoolFilter<"Theme"> | boolean
    createdUserDocument?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    updatedBy?: StringNullableFilter<"Theme"> | string | null
    deletedAt?: DateTimeNullableFilter<"Theme"> | Date | string | null
    deletedBy?: StringNullableFilter<"Theme"> | string | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutReceiveUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReceiveUserInput, PaymentUncheckedUpdateWithoutReceiveUserInput>
    create: XOR<PaymentCreateWithoutReceiveUserInput, PaymentUncheckedCreateWithoutReceiveUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReceiveUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReceiveUserInput, PaymentUncheckedUpdateWithoutReceiveUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReceiveUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReceiveUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    orderCode?: StringFilter<"Payment"> | string
    cashBoxId?: IntFilter<"Payment"> | number
    totalAmount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFilter<"Payment"> | string
    receivedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    changeAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: StringNullableFilter<"Payment"> | string | null
    notes?: StringNullableFilter<"Payment"> | string | null
    receiveUserDocument?: StringFilter<"Payment"> | string
    paidCustomerDocument?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    createdBy?: StringFilter<"Payment"> | string
    updatedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    updatedBy?: StringNullableFilter<"Payment"> | string | null
    deletedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payment"> | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type CustomerCreateWithoutSessionsInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSessionsInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSessionsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSessionsInput, CustomerUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type CustomerUpsertWithoutSessionsInput = {
    update: XOR<CustomerUpdateWithoutSessionsInput, CustomerUncheckedUpdateWithoutSessionsInput>
    create: XOR<CustomerCreateWithoutSessionsInput, CustomerUncheckedCreateWithoutSessionsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSessionsInput, CustomerUncheckedUpdateWithoutSessionsInput>
  }

  export type CustomerUpdateWithoutSessionsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSessionsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type DocumentTypeCreateWithoutCustomersInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeUncheckedCreateWithoutCustomersInput = {
    name: string
    description?: string | null
    digitLength: number
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutDocumentTypeInput
  }

  export type DocumentTypeCreateOrConnectWithoutCustomersInput = {
    where: DocumentTypeWhereUniqueInput
    create: XOR<DocumentTypeCreateWithoutCustomersInput, DocumentTypeUncheckedCreateWithoutCustomersInput>
  }

  export type AccountStatusCreateWithoutCustomersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    users?: UserCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusUncheckedCreateWithoutCustomersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    users?: UserUncheckedCreateNestedManyWithoutAccountStatusInput
  }

  export type AccountStatusCreateOrConnectWithoutCustomersInput = {
    where: AccountStatusWhereUniqueInput
    create: XOR<AccountStatusCreateWithoutCustomersInput, AccountStatusUncheckedCreateWithoutCustomersInput>
  }

  export type ThemeCreateWithoutCustomerUsingThisThemeInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    user?: UserCreateNestedOneWithoutCreatedThemesInput
    usersUsingThisTheme?: UserCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateWithoutCustomerUsingThisThemeInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdUserDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    usersUsingThisTheme?: UserUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeCreateOrConnectWithoutCustomerUsingThisThemeInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutCustomerUsingThisThemeInput, ThemeUncheckedCreateWithoutCustomerUsingThisThemeInput>
  }

  export type SessionCreateWithoutCustomerInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    user?: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateWithoutCustomerInput = {
    id?: string
    userDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionCreateOrConnectWithoutCustomerInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput>
  }

  export type SessionCreateManyCustomerInputEnvelope = {
    data: SessionCreateManyCustomerInput | SessionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutCustomerInput = {
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateWithoutCustomerInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    userDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type LogCreateOrConnectWithoutCustomerInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput>
  }

  export type LogCreateManyCustomerInputEnvelope = {
    data: LogCreateManyCustomerInput | LogCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPaidCustomerInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutPaymentInput
    cashBox: CashBoxCreateNestedOneWithoutPaymentsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
    receiveUser: UserCreateNestedOneWithoutPaymentsReceivedInput
  }

  export type PaymentUncheckedCreateWithoutPaidCustomerInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutPaidCustomerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput>
  }

  export type PaymentCreateManyPaidCustomerInputEnvelope = {
    data: PaymentCreateManyPaidCustomerInput | PaymentCreateManyPaidCustomerInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTypeUpsertWithoutCustomersInput = {
    update: XOR<DocumentTypeUpdateWithoutCustomersInput, DocumentTypeUncheckedUpdateWithoutCustomersInput>
    create: XOR<DocumentTypeCreateWithoutCustomersInput, DocumentTypeUncheckedCreateWithoutCustomersInput>
    where?: DocumentTypeWhereInput
  }

  export type DocumentTypeUpdateToOneWithWhereWithoutCustomersInput = {
    where?: DocumentTypeWhereInput
    data: XOR<DocumentTypeUpdateWithoutCustomersInput, DocumentTypeUncheckedUpdateWithoutCustomersInput>
  }

  export type DocumentTypeUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutDocumentTypeNestedInput
  }

  export type DocumentTypeUncheckedUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    digitLength?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutDocumentTypeNestedInput
  }

  export type AccountStatusUpsertWithoutCustomersInput = {
    update: XOR<AccountStatusUpdateWithoutCustomersInput, AccountStatusUncheckedUpdateWithoutCustomersInput>
    create: XOR<AccountStatusCreateWithoutCustomersInput, AccountStatusUncheckedCreateWithoutCustomersInput>
    where?: AccountStatusWhereInput
  }

  export type AccountStatusUpdateToOneWithWhereWithoutCustomersInput = {
    where?: AccountStatusWhereInput
    data: XOR<AccountStatusUpdateWithoutCustomersInput, AccountStatusUncheckedUpdateWithoutCustomersInput>
  }

  export type AccountStatusUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutAccountStatusNestedInput
  }

  export type AccountStatusUncheckedUpdateWithoutCustomersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutAccountStatusNestedInput
  }

  export type ThemeUpsertWithoutCustomerUsingThisThemeInput = {
    update: XOR<ThemeUpdateWithoutCustomerUsingThisThemeInput, ThemeUncheckedUpdateWithoutCustomerUsingThisThemeInput>
    create: XOR<ThemeCreateWithoutCustomerUsingThisThemeInput, ThemeUncheckedCreateWithoutCustomerUsingThisThemeInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutCustomerUsingThisThemeInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutCustomerUsingThisThemeInput, ThemeUncheckedUpdateWithoutCustomerUsingThisThemeInput>
  }

  export type ThemeUpdateWithoutCustomerUsingThisThemeInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutCreatedThemesNestedInput
    usersUsingThisTheme?: UserUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutCustomerUsingThisThemeInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usersUsingThisTheme?: UserUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type SessionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutCustomerInput, SessionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SessionCreateWithoutCustomerInput, SessionUncheckedCreateWithoutCustomerInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutCustomerInput, SessionUncheckedUpdateWithoutCustomerInput>
  }

  export type SessionUpdateManyWithWhereWithoutCustomerInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type LogUpsertWithWhereUniqueWithoutCustomerInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutCustomerInput, LogUncheckedUpdateWithoutCustomerInput>
    create: XOR<LogCreateWithoutCustomerInput, LogUncheckedCreateWithoutCustomerInput>
  }

  export type LogUpdateWithWhereUniqueWithoutCustomerInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutCustomerInput, LogUncheckedUpdateWithoutCustomerInput>
  }

  export type LogUpdateManyWithWhereWithoutCustomerInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaidCustomerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaidCustomerInput, PaymentUncheckedUpdateWithoutPaidCustomerInput>
    create: XOR<PaymentCreateWithoutPaidCustomerInput, PaymentUncheckedCreateWithoutPaidCustomerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaidCustomerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaidCustomerInput, PaymentUncheckedUpdateWithoutPaidCustomerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaidCustomerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaidCustomerInput>
  }

  export type UserCreateWithoutOpenedCashBoxesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutOpenedCashBoxesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutOpenedCashBoxesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpenedCashBoxesInput, UserUncheckedCreateWithoutOpenedCashBoxesInput>
  }

  export type UserCreateWithoutClosedCashBoxesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutClosedCashBoxesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutClosedCashBoxesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClosedCashBoxesInput, UserUncheckedCreateWithoutClosedCashBoxesInput>
  }

  export type PaymentCreateWithoutCashBoxInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutPaymentInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
    receiveUser: UserCreateNestedOneWithoutPaymentsReceivedInput
    paidCustomer?: CustomerCreateNestedOneWithoutPaymentsMadeInput
  }

  export type PaymentUncheckedCreateWithoutCashBoxInput = {
    id?: number
    orderCode: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutCashBoxInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput>
  }

  export type PaymentCreateManyCashBoxInputEnvelope = {
    data: PaymentCreateManyCashBoxInput | PaymentCreateManyCashBoxInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOpenedCashBoxesInput = {
    update: XOR<UserUpdateWithoutOpenedCashBoxesInput, UserUncheckedUpdateWithoutOpenedCashBoxesInput>
    create: XOR<UserCreateWithoutOpenedCashBoxesInput, UserUncheckedCreateWithoutOpenedCashBoxesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpenedCashBoxesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpenedCashBoxesInput, UserUncheckedUpdateWithoutOpenedCashBoxesInput>
  }

  export type UserUpdateWithoutOpenedCashBoxesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOpenedCashBoxesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUpsertWithoutClosedCashBoxesInput = {
    update: XOR<UserUpdateWithoutClosedCashBoxesInput, UserUncheckedUpdateWithoutClosedCashBoxesInput>
    create: XOR<UserCreateWithoutClosedCashBoxesInput, UserUncheckedCreateWithoutClosedCashBoxesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClosedCashBoxesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClosedCashBoxesInput, UserUncheckedUpdateWithoutClosedCashBoxesInput>
  }

  export type UserUpdateWithoutClosedCashBoxesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClosedCashBoxesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutCashBoxInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCashBoxInput, PaymentUncheckedUpdateWithoutCashBoxInput>
    create: XOR<PaymentCreateWithoutCashBoxInput, PaymentUncheckedCreateWithoutCashBoxInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCashBoxInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCashBoxInput, PaymentUncheckedUpdateWithoutCashBoxInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCashBoxInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCashBoxInput>
  }

  export type TableCreateWithoutStatusInput = {
    name: string
    capacity?: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    zone?: RestaurantZoneCreateNestedOneWithoutTablesInput
    tableSessions?: TableSessionCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutStatusInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutStatusInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput>
  }

  export type TableCreateManyStatusInputEnvelope = {
    data: TableCreateManyStatusInput | TableCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type TableUpsertWithWhereUniqueWithoutStatusInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutStatusInput, TableUncheckedUpdateWithoutStatusInput>
    create: XOR<TableCreateWithoutStatusInput, TableUncheckedCreateWithoutStatusInput>
  }

  export type TableUpdateWithWhereUniqueWithoutStatusInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutStatusInput, TableUncheckedUpdateWithoutStatusInput>
  }

  export type TableUpdateManyWithWhereWithoutStatusInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutStatusInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    id?: IntFilter<"Table"> | number
    name?: StringFilter<"Table"> | string
    capacity?: IntFilter<"Table"> | number
    zoneName?: StringNullableFilter<"Table"> | string | null
    statusCode?: StringFilter<"Table"> | string
    createdAt?: DateTimeFilter<"Table"> | Date | string
    createdBy?: StringFilter<"Table"> | string
    updatedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    updatedBy?: StringNullableFilter<"Table"> | string | null
    deletedAt?: DateTimeNullableFilter<"Table"> | Date | string | null
    deletedBy?: StringNullableFilter<"Table"> | string | null
  }

  export type TableCreateWithoutZoneInput = {
    name: string
    capacity?: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    status?: TableStatusCreateNestedOneWithoutTablesInput
    tableSessions?: TableSessionCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutZoneInput = {
    id?: number
    name: string
    capacity?: number
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutTableInput
    combineTableItems?: CombineTableItemUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutZoneInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput>
  }

  export type TableCreateManyZoneInputEnvelope = {
    data: TableCreateManyZoneInput | TableCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type TableUpsertWithWhereUniqueWithoutZoneInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutZoneInput, TableUncheckedUpdateWithoutZoneInput>
    create: XOR<TableCreateWithoutZoneInput, TableUncheckedCreateWithoutZoneInput>
  }

  export type TableUpdateWithWhereUniqueWithoutZoneInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutZoneInput, TableUncheckedUpdateWithoutZoneInput>
  }

  export type TableUpdateManyWithWhereWithoutZoneInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutZoneInput>
  }

  export type RestaurantZoneCreateWithoutTablesInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RestaurantZoneUncheckedCreateWithoutTablesInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RestaurantZoneCreateOrConnectWithoutTablesInput = {
    where: RestaurantZoneWhereUniqueInput
    create: XOR<RestaurantZoneCreateWithoutTablesInput, RestaurantZoneUncheckedCreateWithoutTablesInput>
  }

  export type TableStatusCreateWithoutTablesInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type TableStatusUncheckedCreateWithoutTablesInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type TableStatusCreateOrConnectWithoutTablesInput = {
    where: TableStatusWhereUniqueInput
    create: XOR<TableStatusCreateWithoutTablesInput, TableStatusUncheckedCreateWithoutTablesInput>
  }

  export type TableSessionCreateWithoutTableInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combineTable?: CombineTableCreateNestedOneWithoutTableSessionsInput
    opener: UserCreateNestedOneWithoutTablesSessionOpenedInput
    closer?: UserCreateNestedOneWithoutTablesSessionClosedInput
    orders?: OrderCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUncheckedCreateWithoutTableInput = {
    id?: number
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionCreateOrConnectWithoutTableInput = {
    where: TableSessionWhereUniqueInput
    create: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput>
  }

  export type TableSessionCreateManyTableInputEnvelope = {
    data: TableSessionCreateManyTableInput | TableSessionCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type CombineTableItemCreateWithoutTableInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combineTable: CombineTableCreateNestedOneWithoutTablesInput
  }

  export type CombineTableItemUncheckedCreateWithoutTableInput = {
    id?: number
    combineTableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemCreateOrConnectWithoutTableInput = {
    where: CombineTableItemWhereUniqueInput
    create: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput>
  }

  export type CombineTableItemCreateManyTableInputEnvelope = {
    data: CombineTableItemCreateManyTableInput | CombineTableItemCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type RestaurantZoneUpsertWithoutTablesInput = {
    update: XOR<RestaurantZoneUpdateWithoutTablesInput, RestaurantZoneUncheckedUpdateWithoutTablesInput>
    create: XOR<RestaurantZoneCreateWithoutTablesInput, RestaurantZoneUncheckedCreateWithoutTablesInput>
    where?: RestaurantZoneWhereInput
  }

  export type RestaurantZoneUpdateToOneWithWhereWithoutTablesInput = {
    where?: RestaurantZoneWhereInput
    data: XOR<RestaurantZoneUpdateWithoutTablesInput, RestaurantZoneUncheckedUpdateWithoutTablesInput>
  }

  export type RestaurantZoneUpdateWithoutTablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RestaurantZoneUncheckedUpdateWithoutTablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableStatusUpsertWithoutTablesInput = {
    update: XOR<TableStatusUpdateWithoutTablesInput, TableStatusUncheckedUpdateWithoutTablesInput>
    create: XOR<TableStatusCreateWithoutTablesInput, TableStatusUncheckedCreateWithoutTablesInput>
    where?: TableStatusWhereInput
  }

  export type TableStatusUpdateToOneWithWhereWithoutTablesInput = {
    where?: TableStatusWhereInput
    data: XOR<TableStatusUpdateWithoutTablesInput, TableStatusUncheckedUpdateWithoutTablesInput>
  }

  export type TableStatusUpdateWithoutTablesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableStatusUncheckedUpdateWithoutTablesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionUpsertWithWhereUniqueWithoutTableInput = {
    where: TableSessionWhereUniqueInput
    update: XOR<TableSessionUpdateWithoutTableInput, TableSessionUncheckedUpdateWithoutTableInput>
    create: XOR<TableSessionCreateWithoutTableInput, TableSessionUncheckedCreateWithoutTableInput>
  }

  export type TableSessionUpdateWithWhereUniqueWithoutTableInput = {
    where: TableSessionWhereUniqueInput
    data: XOR<TableSessionUpdateWithoutTableInput, TableSessionUncheckedUpdateWithoutTableInput>
  }

  export type TableSessionUpdateManyWithWhereWithoutTableInput = {
    where: TableSessionScalarWhereInput
    data: XOR<TableSessionUpdateManyMutationInput, TableSessionUncheckedUpdateManyWithoutTableInput>
  }

  export type CombineTableItemUpsertWithWhereUniqueWithoutTableInput = {
    where: CombineTableItemWhereUniqueInput
    update: XOR<CombineTableItemUpdateWithoutTableInput, CombineTableItemUncheckedUpdateWithoutTableInput>
    create: XOR<CombineTableItemCreateWithoutTableInput, CombineTableItemUncheckedCreateWithoutTableInput>
  }

  export type CombineTableItemUpdateWithWhereUniqueWithoutTableInput = {
    where: CombineTableItemWhereUniqueInput
    data: XOR<CombineTableItemUpdateWithoutTableInput, CombineTableItemUncheckedUpdateWithoutTableInput>
  }

  export type CombineTableItemUpdateManyWithWhereWithoutTableInput = {
    where: CombineTableItemScalarWhereInput
    data: XOR<CombineTableItemUpdateManyMutationInput, CombineTableItemUncheckedUpdateManyWithoutTableInput>
  }

  export type CombineTableItemScalarWhereInput = {
    AND?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
    OR?: CombineTableItemScalarWhereInput[]
    NOT?: CombineTableItemScalarWhereInput | CombineTableItemScalarWhereInput[]
    id?: IntFilter<"CombineTableItem"> | number
    combineTableId?: IntFilter<"CombineTableItem"> | number
    tableId?: IntFilter<"CombineTableItem"> | number
    createdAt?: DateTimeFilter<"CombineTableItem"> | Date | string
    createdBy?: StringFilter<"CombineTableItem"> | string
    updatedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"CombineTableItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"CombineTableItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"CombineTableItem"> | string | null
  }

  export type UserCreateWithoutCombinedTablesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutCombinedTablesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutCombinedTablesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCombinedTablesInput, UserUncheckedCreateWithoutCombinedTablesInput>
  }

  export type UserCreateWithoutReleasedTablesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutReleasedTablesInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutReleasedTablesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReleasedTablesInput, UserUncheckedCreateWithoutReleasedTablesInput>
  }

  export type CombineTableItemCreateWithoutCombineTableInput = {
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table: TableCreateNestedOneWithoutCombineTableItemsInput
  }

  export type CombineTableItemUncheckedCreateWithoutCombineTableInput = {
    id?: number
    tableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemCreateOrConnectWithoutCombineTableInput = {
    where: CombineTableItemWhereUniqueInput
    create: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput>
  }

  export type CombineTableItemCreateManyCombineTableInputEnvelope = {
    data: CombineTableItemCreateManyCombineTableInput | CombineTableItemCreateManyCombineTableInput[]
    skipDuplicates?: boolean
  }

  export type TableSessionCreateWithoutCombineTableInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table?: TableCreateNestedOneWithoutTableSessionsInput
    opener: UserCreateNestedOneWithoutTablesSessionOpenedInput
    closer?: UserCreateNestedOneWithoutTablesSessionClosedInput
    orders?: OrderCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionUncheckedCreateWithoutCombineTableInput = {
    id?: number
    tableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orders?: OrderUncheckedCreateNestedManyWithoutTableSessionInput
  }

  export type TableSessionCreateOrConnectWithoutCombineTableInput = {
    where: TableSessionWhereUniqueInput
    create: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput>
  }

  export type TableSessionCreateManyCombineTableInputEnvelope = {
    data: TableSessionCreateManyCombineTableInput | TableSessionCreateManyCombineTableInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCombinedTablesInput = {
    update: XOR<UserUpdateWithoutCombinedTablesInput, UserUncheckedUpdateWithoutCombinedTablesInput>
    create: XOR<UserCreateWithoutCombinedTablesInput, UserUncheckedCreateWithoutCombinedTablesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCombinedTablesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCombinedTablesInput, UserUncheckedUpdateWithoutCombinedTablesInput>
  }

  export type UserUpdateWithoutCombinedTablesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCombinedTablesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUpsertWithoutReleasedTablesInput = {
    update: XOR<UserUpdateWithoutReleasedTablesInput, UserUncheckedUpdateWithoutReleasedTablesInput>
    create: XOR<UserCreateWithoutReleasedTablesInput, UserUncheckedCreateWithoutReleasedTablesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReleasedTablesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReleasedTablesInput, UserUncheckedUpdateWithoutReleasedTablesInput>
  }

  export type UserUpdateWithoutReleasedTablesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReleasedTablesInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type CombineTableItemUpsertWithWhereUniqueWithoutCombineTableInput = {
    where: CombineTableItemWhereUniqueInput
    update: XOR<CombineTableItemUpdateWithoutCombineTableInput, CombineTableItemUncheckedUpdateWithoutCombineTableInput>
    create: XOR<CombineTableItemCreateWithoutCombineTableInput, CombineTableItemUncheckedCreateWithoutCombineTableInput>
  }

  export type CombineTableItemUpdateWithWhereUniqueWithoutCombineTableInput = {
    where: CombineTableItemWhereUniqueInput
    data: XOR<CombineTableItemUpdateWithoutCombineTableInput, CombineTableItemUncheckedUpdateWithoutCombineTableInput>
  }

  export type CombineTableItemUpdateManyWithWhereWithoutCombineTableInput = {
    where: CombineTableItemScalarWhereInput
    data: XOR<CombineTableItemUpdateManyMutationInput, CombineTableItemUncheckedUpdateManyWithoutCombineTableInput>
  }

  export type TableSessionUpsertWithWhereUniqueWithoutCombineTableInput = {
    where: TableSessionWhereUniqueInput
    update: XOR<TableSessionUpdateWithoutCombineTableInput, TableSessionUncheckedUpdateWithoutCombineTableInput>
    create: XOR<TableSessionCreateWithoutCombineTableInput, TableSessionUncheckedCreateWithoutCombineTableInput>
  }

  export type TableSessionUpdateWithWhereUniqueWithoutCombineTableInput = {
    where: TableSessionWhereUniqueInput
    data: XOR<TableSessionUpdateWithoutCombineTableInput, TableSessionUncheckedUpdateWithoutCombineTableInput>
  }

  export type TableSessionUpdateManyWithWhereWithoutCombineTableInput = {
    where: TableSessionScalarWhereInput
    data: XOR<TableSessionUpdateManyMutationInput, TableSessionUncheckedUpdateManyWithoutCombineTableInput>
  }

  export type CombineTableCreateWithoutTablesInput = {
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combiner: UserCreateNestedOneWithoutCombinedTablesInput
    releaser?: UserCreateNestedOneWithoutReleasedTablesInput
    tableSessions?: TableSessionCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUncheckedCreateWithoutTablesInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableCreateOrConnectWithoutTablesInput = {
    where: CombineTableWhereUniqueInput
    create: XOR<CombineTableCreateWithoutTablesInput, CombineTableUncheckedCreateWithoutTablesInput>
  }

  export type TableCreateWithoutCombineTableItemsInput = {
    name: string
    capacity?: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    zone?: RestaurantZoneCreateNestedOneWithoutTablesInput
    status?: TableStatusCreateNestedOneWithoutTablesInput
    tableSessions?: TableSessionCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutCombineTableItemsInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSessions?: TableSessionUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutCombineTableItemsInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutCombineTableItemsInput, TableUncheckedCreateWithoutCombineTableItemsInput>
  }

  export type CombineTableUpsertWithoutTablesInput = {
    update: XOR<CombineTableUpdateWithoutTablesInput, CombineTableUncheckedUpdateWithoutTablesInput>
    create: XOR<CombineTableCreateWithoutTablesInput, CombineTableUncheckedCreateWithoutTablesInput>
    where?: CombineTableWhereInput
  }

  export type CombineTableUpdateToOneWithWhereWithoutTablesInput = {
    where?: CombineTableWhereInput
    data: XOR<CombineTableUpdateWithoutTablesInput, CombineTableUncheckedUpdateWithoutTablesInput>
  }

  export type CombineTableUpdateWithoutTablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combiner?: UserUpdateOneRequiredWithoutCombinedTablesNestedInput
    releaser?: UserUpdateOneWithoutReleasedTablesNestedInput
    tableSessions?: TableSessionUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateWithoutTablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSessions?: TableSessionUncheckedUpdateManyWithoutCombineTableNestedInput
  }

  export type TableUpsertWithoutCombineTableItemsInput = {
    update: XOR<TableUpdateWithoutCombineTableItemsInput, TableUncheckedUpdateWithoutCombineTableItemsInput>
    create: XOR<TableCreateWithoutCombineTableItemsInput, TableUncheckedCreateWithoutCombineTableItemsInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutCombineTableItemsInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutCombineTableItemsInput, TableUncheckedUpdateWithoutCombineTableItemsInput>
  }

  export type TableUpdateWithoutCombineTableItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: RestaurantZoneUpdateOneWithoutTablesNestedInput
    status?: TableStatusUpdateOneRequiredWithoutTablesNestedInput
    tableSessions?: TableSessionUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutCombineTableItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSessions?: TableSessionUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateWithoutTableSessionsInput = {
    name: string
    capacity?: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    zone?: RestaurantZoneCreateNestedOneWithoutTablesInput
    status?: TableStatusCreateNestedOneWithoutTablesInput
    combineTableItems?: CombineTableItemCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutTableSessionsInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combineTableItems?: CombineTableItemUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutTableSessionsInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutTableSessionsInput, TableUncheckedCreateWithoutTableSessionsInput>
  }

  export type CombineTableCreateWithoutTableSessionsInput = {
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    combiner: UserCreateNestedOneWithoutCombinedTablesInput
    releaser?: UserCreateNestedOneWithoutReleasedTablesInput
    tables?: CombineTableItemCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableUncheckedCreateWithoutTableSessionsInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tables?: CombineTableItemUncheckedCreateNestedManyWithoutCombineTableInput
  }

  export type CombineTableCreateOrConnectWithoutTableSessionsInput = {
    where: CombineTableWhereUniqueInput
    create: XOR<CombineTableCreateWithoutTableSessionsInput, CombineTableUncheckedCreateWithoutTableSessionsInput>
  }

  export type UserCreateWithoutTablesSessionOpenedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutTablesSessionOpenedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutTablesSessionOpenedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTablesSessionOpenedInput, UserUncheckedCreateWithoutTablesSessionOpenedInput>
  }

  export type UserCreateWithoutTablesSessionClosedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutTablesSessionClosedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutTablesSessionClosedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTablesSessionClosedInput, UserUncheckedCreateWithoutTablesSessionClosedInput>
  }

  export type OrderCreateWithoutTableSessionInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTableSessionInput = {
    code: string
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTableSessionInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput>
  }

  export type OrderCreateManyTableSessionInputEnvelope = {
    data: OrderCreateManyTableSessionInput | OrderCreateManyTableSessionInput[]
    skipDuplicates?: boolean
  }

  export type TableUpsertWithoutTableSessionsInput = {
    update: XOR<TableUpdateWithoutTableSessionsInput, TableUncheckedUpdateWithoutTableSessionsInput>
    create: XOR<TableCreateWithoutTableSessionsInput, TableUncheckedCreateWithoutTableSessionsInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutTableSessionsInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutTableSessionsInput, TableUncheckedUpdateWithoutTableSessionsInput>
  }

  export type TableUpdateWithoutTableSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: RestaurantZoneUpdateOneWithoutTablesNestedInput
    status?: TableStatusUpdateOneRequiredWithoutTablesNestedInput
    combineTableItems?: CombineTableItemUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutTableSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combineTableItems?: CombineTableItemUncheckedUpdateManyWithoutTableNestedInput
  }

  export type CombineTableUpsertWithoutTableSessionsInput = {
    update: XOR<CombineTableUpdateWithoutTableSessionsInput, CombineTableUncheckedUpdateWithoutTableSessionsInput>
    create: XOR<CombineTableCreateWithoutTableSessionsInput, CombineTableUncheckedCreateWithoutTableSessionsInput>
    where?: CombineTableWhereInput
  }

  export type CombineTableUpdateToOneWithWhereWithoutTableSessionsInput = {
    where?: CombineTableWhereInput
    data: XOR<CombineTableUpdateWithoutTableSessionsInput, CombineTableUncheckedUpdateWithoutTableSessionsInput>
  }

  export type CombineTableUpdateWithoutTableSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combiner?: UserUpdateOneRequiredWithoutCombinedTablesNestedInput
    releaser?: UserUpdateOneWithoutReleasedTablesNestedInput
    tables?: CombineTableItemUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateWithoutTableSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: CombineTableItemUncheckedUpdateManyWithoutCombineTableNestedInput
  }

  export type UserUpsertWithoutTablesSessionOpenedInput = {
    update: XOR<UserUpdateWithoutTablesSessionOpenedInput, UserUncheckedUpdateWithoutTablesSessionOpenedInput>
    create: XOR<UserCreateWithoutTablesSessionOpenedInput, UserUncheckedCreateWithoutTablesSessionOpenedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTablesSessionOpenedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTablesSessionOpenedInput, UserUncheckedUpdateWithoutTablesSessionOpenedInput>
  }

  export type UserUpdateWithoutTablesSessionOpenedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTablesSessionOpenedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUpsertWithoutTablesSessionClosedInput = {
    update: XOR<UserUpdateWithoutTablesSessionClosedInput, UserUncheckedUpdateWithoutTablesSessionClosedInput>
    create: XOR<UserCreateWithoutTablesSessionClosedInput, UserUncheckedCreateWithoutTablesSessionClosedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTablesSessionClosedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTablesSessionClosedInput, UserUncheckedUpdateWithoutTablesSessionClosedInput>
  }

  export type UserUpdateWithoutTablesSessionClosedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTablesSessionClosedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutTableSessionInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTableSessionInput, OrderUncheckedUpdateWithoutTableSessionInput>
    create: XOR<OrderCreateWithoutTableSessionInput, OrderUncheckedCreateWithoutTableSessionInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTableSessionInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTableSessionInput, OrderUncheckedUpdateWithoutTableSessionInput>
  }

  export type OrderUpdateManyWithWhereWithoutTableSessionInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTableSessionInput>
  }

  export type ProductCreateWithoutBrandInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    offerPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFilter<"Product"> | string
    productCategoryName?: StringFilter<"Product"> | string
    brandName?: StringNullableFilter<"Product"> | string | null
    productStatusCode?: StringFilter<"Product"> | string
    mainImageId?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    createdBy?: StringFilter<"Product"> | string
    updatedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    updatedBy?: StringNullableFilter<"Product"> | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableFilter<"Product"> | string | null
  }

  export type ProductCreateWithoutProductStatusInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductStatusInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductStatusInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput>
  }

  export type ProductCreateManyProductStatusInputEnvelope = {
    data: ProductCreateManyProductStatusInput | ProductCreateManyProductStatusInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductStatusInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductStatusInput, ProductUncheckedUpdateWithoutProductStatusInput>
    create: XOR<ProductCreateWithoutProductStatusInput, ProductUncheckedCreateWithoutProductStatusInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductStatusInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductStatusInput, ProductUncheckedUpdateWithoutProductStatusInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductStatusInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductStatusInput>
  }

  export type ProductCreateWithoutProductTypeInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductTypeInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductCreateManyProductTypeInputEnvelope = {
    data: ProductCreateManyProductTypeInput | ProductCreateManyProductTypeInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductTypeInput, ProductUncheckedUpdateWithoutProductTypeInput>
    create: XOR<ProductCreateWithoutProductTypeInput, ProductUncheckedCreateWithoutProductTypeInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductTypeInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductTypeInput, ProductUncheckedUpdateWithoutProductTypeInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductTypeInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductTypeInput>
  }

  export type ProductCreateWithoutProductCategoryInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCategoryInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductCreateManyProductCategoryInputEnvelope = {
    data: ProductCreateManyProductCategoryInput | ProductCreateManyProductCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
    create: XOR<ProductCreateWithoutProductCategoryInput, ProductUncheckedCreateWithoutProductCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutProductCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutProductCategoryInput, ProductUncheckedUpdateWithoutProductCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutProductCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductCategoryInput>
  }

  export type ProductTypeCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductTypeUncheckedCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductTypeCreateOrConnectWithoutProductsInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutProductsInput, ProductTypeUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductCategoryUncheckedCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductCategoryCreateOrConnectWithoutProductsInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
  }

  export type BrandCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BrandUncheckedCreateWithoutProductsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type BrandCreateOrConnectWithoutProductsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
  }

  export type ProductStatusCreateWithoutProductsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ProductStatusUncheckedCreateWithoutProductsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type ProductStatusCreateOrConnectWithoutProductsInput = {
    where: ProductStatusWhereUniqueInput
    create: XOR<ProductStatusCreateWithoutProductsInput, ProductStatusUncheckedCreateWithoutProductsInput>
  }

  export type InventoryCreateWithoutProductInput = {
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutProductInput = {
    id?: number
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutProductInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryCreateManyProductInputEnvelope = {
    data: InventoryCreateManyProductInput | InventoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    status?: OrderItemStatusCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderCode: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTypeUpsertWithoutProductsInput = {
    update: XOR<ProductTypeUpdateWithoutProductsInput, ProductTypeUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductTypeCreateWithoutProductsInput, ProductTypeUncheckedCreateWithoutProductsInput>
    where?: ProductTypeWhereInput
  }

  export type ProductTypeUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductTypeWhereInput
    data: XOR<ProductTypeUpdateWithoutProductsInput, ProductTypeUncheckedUpdateWithoutProductsInput>
  }

  export type ProductTypeUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductTypeUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUpsertWithoutProductsInput = {
    update: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductCategoryCreateWithoutProductsInput, ProductCategoryUncheckedCreateWithoutProductsInput>
    where?: ProductCategoryWhereInput
  }

  export type ProductCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductCategoryWhereInput
    data: XOR<ProductCategoryUpdateWithoutProductsInput, ProductCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUpsertWithoutProductsInput = {
    update: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BrandUncheckedUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductStatusUpsertWithoutProductsInput = {
    update: XOR<ProductStatusUpdateWithoutProductsInput, ProductStatusUncheckedUpdateWithoutProductsInput>
    create: XOR<ProductStatusCreateWithoutProductsInput, ProductStatusUncheckedCreateWithoutProductsInput>
    where?: ProductStatusWhereInput
  }

  export type ProductStatusUpdateToOneWithWhereWithoutProductsInput = {
    where?: ProductStatusWhereInput
    data: XOR<ProductStatusUpdateWithoutProductsInput, ProductStatusUncheckedUpdateWithoutProductsInput>
  }

  export type ProductStatusUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductStatusUncheckedUpdateWithoutProductsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryUpsertWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
    create: XOR<InventoryCreateWithoutProductInput, InventoryUncheckedCreateWithoutProductInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutProductInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutProductInput, InventoryUncheckedUpdateWithoutProductInput>
  }

  export type InventoryUpdateManyWithWhereWithoutProductInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutProductInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: IntFilter<"Inventory"> | number
    productId?: IntFilter<"Inventory"> | number
    currentQuantity?: IntFilter<"Inventory"> | number
    minimumStock?: IntFilter<"Inventory"> | number
    storageLocation?: StringNullableFilter<"Inventory"> | string | null
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    createdBy?: StringFilter<"Inventory"> | string
    updatedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    updatedBy?: StringNullableFilter<"Inventory"> | string | null
    deletedAt?: DateTimeNullableFilter<"Inventory"> | Date | string | null
    deletedBy?: StringNullableFilter<"Inventory"> | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderCode?: StringFilter<"OrderItem"> | string
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    discount?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    statusCode?: StringFilter<"OrderItem"> | string
    specialInstructions?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    createdBy?: StringFilter<"OrderItem"> | string
    updatedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    updatedBy?: StringNullableFilter<"OrderItem"> | string | null
    deletedAt?: DateTimeNullableFilter<"OrderItem"> | Date | string | null
    deletedBy?: StringNullableFilter<"OrderItem"> | string | null
  }

  export type OrderCreateWithoutStatusInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStatusInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStatusInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput>
  }

  export type OrderCreateManyStatusInputEnvelope = {
    data: OrderCreateManyStatusInput | OrderCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutStatusInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStatusInput, OrderUncheckedUpdateWithoutStatusInput>
    create: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStatusInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStatusInput, OrderUncheckedUpdateWithoutStatusInput>
  }

  export type OrderUpdateManyWithWhereWithoutStatusInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStatusInput>
  }

  export type OrderItemCreateWithoutStatusInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutStatusInput = {
    id?: number
    orderCode: string
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemCreateOrConnectWithoutStatusInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput>
  }

  export type OrderItemCreateManyStatusInputEnvelope = {
    data: OrderItemCreateManyStatusInput | OrderItemCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemUpsertWithWhereUniqueWithoutStatusInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutStatusInput, OrderItemUncheckedUpdateWithoutStatusInput>
    create: XOR<OrderItemCreateWithoutStatusInput, OrderItemUncheckedCreateWithoutStatusInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutStatusInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutStatusInput, OrderItemUncheckedUpdateWithoutStatusInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutStatusInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutStatusInput>
  }

  export type TableSessionCreateWithoutOrdersInput = {
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    table?: TableCreateNestedOneWithoutTableSessionsInput
    combineTable?: CombineTableCreateNestedOneWithoutTableSessionsInput
    opener: UserCreateNestedOneWithoutTablesSessionOpenedInput
    closer?: UserCreateNestedOneWithoutTablesSessionClosedInput
  }

  export type TableSessionUncheckedCreateWithoutOrdersInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionCreateOrConnectWithoutOrdersInput = {
    where: TableSessionWhereUniqueInput
    create: XOR<TableSessionCreateWithoutOrdersInput, TableSessionUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersCreatedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutOrdersCreatedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutOrdersCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
  }

  export type CustomerCreateWithoutOrdersInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrdersInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusCreateWithoutOrdersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderStatusUncheckedCreateWithoutOrdersInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderStatusCreateOrConnectWithoutOrdersInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersClosedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutOrdersClosedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutOrdersClosedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersClosedInput, UserUncheckedCreateWithoutOrdersClosedInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    product: ProductCreateNestedOneWithoutOrderItemsInput
    status?: OrderItemStatusCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    cashBox: CashBoxCreateNestedOneWithoutPaymentsInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentsInput
    receiveUser: UserCreateNestedOneWithoutPaymentsReceivedInput
    paidCustomer?: CustomerCreateNestedOneWithoutPaymentsMadeInput
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: number
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type TableSessionUpsertWithoutOrdersInput = {
    update: XOR<TableSessionUpdateWithoutOrdersInput, TableSessionUncheckedUpdateWithoutOrdersInput>
    create: XOR<TableSessionCreateWithoutOrdersInput, TableSessionUncheckedCreateWithoutOrdersInput>
    where?: TableSessionWhereInput
  }

  export type TableSessionUpdateToOneWithWhereWithoutOrdersInput = {
    where?: TableSessionWhereInput
    data: XOR<TableSessionUpdateWithoutOrdersInput, TableSessionUncheckedUpdateWithoutOrdersInput>
  }

  export type TableSessionUpdateWithoutOrdersInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutTableSessionsNestedInput
    combineTable?: CombineTableUpdateOneWithoutTableSessionsNestedInput
    opener?: UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput
    closer?: UserUpdateOneWithoutTablesSessionClosedNestedInput
  }

  export type TableSessionUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutOrdersCreatedInput = {
    update: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
    create: XOR<UserCreateWithoutOrdersCreatedInput, UserUncheckedCreateWithoutOrdersCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersCreatedInput, UserUncheckedUpdateWithoutOrdersCreatedInput>
  }

  export type UserUpdateWithoutOrdersCreatedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersCreatedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type CustomerUpsertWithoutOrdersInput = {
    update: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomerCreateWithoutOrdersInput, CustomerUncheckedCreateWithoutOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrdersInput, CustomerUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateWithoutOrdersInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrdersInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type OrderStatusUpsertWithoutOrdersInput = {
    update: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    where?: OrderStatusWhereInput
  }

  export type OrderStatusUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OrderStatusWhereInput
    data: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusUncheckedUpdateWithoutOrdersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutOrdersClosedInput = {
    update: XOR<UserUpdateWithoutOrdersClosedInput, UserUncheckedUpdateWithoutOrdersClosedInput>
    create: XOR<UserCreateWithoutOrdersClosedInput, UserUncheckedCreateWithoutOrdersClosedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersClosedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersClosedInput, UserUncheckedUpdateWithoutOrdersClosedInput>
  }

  export type UserUpdateWithoutOrdersClosedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersClosedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateWithoutOrderInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    cashBox?: CashBoxUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    receiveUser?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    paidCustomer?: CustomerUpdateOneWithoutPaymentsMadeNestedInput
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateWithoutOrderItemsInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    inventories?: InventoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventories?: InventoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderItemStatusCreateWithoutOrderItemsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderItemStatusUncheckedCreateWithoutOrderItemsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type OrderItemStatusCreateOrConnectWithoutOrderItemsInput = {
    where: OrderItemStatusWhereUniqueInput
    create: XOR<OrderItemStatusCreateWithoutOrderItemsInput, OrderItemStatusUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderItemStatusUpsertWithoutOrderItemsInput = {
    update: XOR<OrderItemStatusUpdateWithoutOrderItemsInput, OrderItemStatusUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderItemStatusCreateWithoutOrderItemsInput, OrderItemStatusUncheckedCreateWithoutOrderItemsInput>
    where?: OrderItemStatusWhereInput
  }

  export type OrderItemStatusUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderItemStatusWhereInput
    data: XOR<OrderItemStatusUpdateWithoutOrderItemsInput, OrderItemStatusUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderItemStatusUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemStatusUncheckedUpdateWithoutOrderItemsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateWithoutPaymentMethodInput = {
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    order: OrderCreateNestedOneWithoutPaymentInput
    cashBox: CashBoxCreateNestedOneWithoutPaymentsInput
    receiveUser: UserCreateNestedOneWithoutPaymentsReceivedInput
    paidCustomer?: CustomerCreateNestedOneWithoutPaymentsMadeInput
  }

  export type PaymentUncheckedCreateWithoutPaymentMethodInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentCreateManyPaymentMethodInputEnvelope = {
    data: PaymentCreateManyPaymentMethodInput | PaymentCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type OrderCreateWithoutPaymentInput = {
    code: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    tableSession?: TableSessionCreateNestedOneWithoutOrdersInput
    creator: UserCreateNestedOneWithoutOrdersCreatedInput
    customer: CustomerCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    closer?: UserCreateNestedOneWithoutOrdersClosedInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type CashBoxCreateWithoutPaymentsInput = {
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    opener: UserCreateNestedOneWithoutOpenedCashBoxesInput
    closer?: UserCreateNestedOneWithoutClosedCashBoxesInput
  }

  export type CashBoxUncheckedCreateWithoutPaymentsInput = {
    id?: number
    openerUserDocument: string
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CashBoxCreateOrConnectWithoutPaymentsInput = {
    where: CashBoxWhereUniqueInput
    create: XOR<CashBoxCreateWithoutPaymentsInput, CashBoxUncheckedCreateWithoutPaymentsInput>
  }

  export type PaymentMethodCreateWithoutPaymentsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentsInput = {
    name: string
    description?: string | null
    color?: string | null
    isActive?: boolean
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentsInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
  }

  export type UserCreateWithoutPaymentsReceivedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsReceivedInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
  }

  export type CustomerCreateWithoutPaymentsMadeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    logs?: LogCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPaymentsMadeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    logs?: LogUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPaymentsMadeInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPaymentsMadeInput, CustomerUncheckedCreateWithoutPaymentsMadeInput>
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CashBoxUpsertWithoutPaymentsInput = {
    update: XOR<CashBoxUpdateWithoutPaymentsInput, CashBoxUncheckedUpdateWithoutPaymentsInput>
    create: XOR<CashBoxCreateWithoutPaymentsInput, CashBoxUncheckedCreateWithoutPaymentsInput>
    where?: CashBoxWhereInput
  }

  export type CashBoxUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: CashBoxWhereInput
    data: XOR<CashBoxUpdateWithoutPaymentsInput, CashBoxUncheckedUpdateWithoutPaymentsInput>
  }

  export type CashBoxUpdateWithoutPaymentsInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    opener?: UserUpdateOneRequiredWithoutOpenedCashBoxesNestedInput
    closer?: UserUpdateOneWithoutClosedCashBoxesNestedInput
  }

  export type CashBoxUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUpsertWithoutPaymentsInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PaymentMethodCreateWithoutPaymentsInput, PaymentMethodUncheckedCreateWithoutPaymentsInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentsInput, PaymentMethodUncheckedUpdateWithoutPaymentsInput>
  }

  export type PaymentMethodUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutPaymentsReceivedInput = {
    update: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
    create: XOR<UserCreateWithoutPaymentsReceivedInput, UserUncheckedCreateWithoutPaymentsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsReceivedInput, UserUncheckedUpdateWithoutPaymentsReceivedInput>
  }

  export type UserUpdateWithoutPaymentsReceivedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsReceivedInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerUpsertWithoutPaymentsMadeInput = {
    update: XOR<CustomerUpdateWithoutPaymentsMadeInput, CustomerUncheckedUpdateWithoutPaymentsMadeInput>
    create: XOR<CustomerCreateWithoutPaymentsMadeInput, CustomerUncheckedCreateWithoutPaymentsMadeInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPaymentsMadeInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPaymentsMadeInput, CustomerUncheckedUpdateWithoutPaymentsMadeInput>
  }

  export type CustomerUpdateWithoutPaymentsMadeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPaymentsMadeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InventoryMovementCreateWithoutMovementTypeInput = {
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    inventory: InventoryCreateNestedOneWithoutInventoryMovementsInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutMovementTypeInput = {
    id?: number
    inventoryId: number
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementCreateOrConnectWithoutMovementTypeInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput>
  }

  export type InventoryMovementCreateManyMovementTypeInputEnvelope = {
    data: InventoryMovementCreateManyMovementTypeInput | InventoryMovementCreateManyMovementTypeInput[]
    skipDuplicates?: boolean
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutMovementTypeInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutMovementTypeInput, InventoryMovementUncheckedUpdateWithoutMovementTypeInput>
    create: XOR<InventoryMovementCreateWithoutMovementTypeInput, InventoryMovementUncheckedCreateWithoutMovementTypeInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutMovementTypeInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutMovementTypeInput, InventoryMovementUncheckedUpdateWithoutMovementTypeInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutMovementTypeInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutMovementTypeInput>
  }

  export type ProductCreateWithoutInventoriesInput = {
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    productType: ProductTypeCreateNestedOneWithoutProductsInput
    productCategory: ProductCategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    productStatus?: ProductStatusCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutInventoriesInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutInventoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInventoriesInput, ProductUncheckedCreateWithoutInventoriesInput>
  }

  export type InventoryMovementCreateWithoutInventoryInput = {
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    movementType: InventoryMovementTypeCreateNestedOneWithoutMovementsInput
    user: UserCreateNestedOneWithoutInventoryMovementsInput
  }

  export type InventoryMovementUncheckedCreateWithoutInventoryInput = {
    id?: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementCreateOrConnectWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    create: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryMovementCreateManyInventoryInputEnvelope = {
    data: InventoryMovementCreateManyInventoryInput | InventoryMovementCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutInventoriesInput = {
    update: XOR<ProductUpdateWithoutInventoriesInput, ProductUncheckedUpdateWithoutInventoriesInput>
    create: XOR<ProductCreateWithoutInventoriesInput, ProductUncheckedCreateWithoutInventoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInventoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInventoriesInput, ProductUncheckedUpdateWithoutInventoriesInput>
  }

  export type ProductUpdateWithoutInventoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type InventoryMovementUpsertWithWhereUniqueWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    update: XOR<InventoryMovementUpdateWithoutInventoryInput, InventoryMovementUncheckedUpdateWithoutInventoryInput>
    create: XOR<InventoryMovementCreateWithoutInventoryInput, InventoryMovementUncheckedCreateWithoutInventoryInput>
  }

  export type InventoryMovementUpdateWithWhereUniqueWithoutInventoryInput = {
    where: InventoryMovementWhereUniqueInput
    data: XOR<InventoryMovementUpdateWithoutInventoryInput, InventoryMovementUncheckedUpdateWithoutInventoryInput>
  }

  export type InventoryMovementUpdateManyWithWhereWithoutInventoryInput = {
    where: InventoryMovementScalarWhereInput
    data: XOR<InventoryMovementUpdateManyMutationInput, InventoryMovementUncheckedUpdateManyWithoutInventoryInput>
  }

  export type InventoryCreateWithoutInventoryMovementsInput = {
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    product: ProductCreateNestedOneWithoutInventoriesInput
  }

  export type InventoryUncheckedCreateWithoutInventoryMovementsInput = {
    id?: number
    productId: number
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryCreateOrConnectWithoutInventoryMovementsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutInventoryMovementsInput, InventoryUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type InventoryMovementTypeCreateWithoutMovementsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type InventoryMovementTypeUncheckedCreateWithoutMovementsInput = {
    code: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type InventoryMovementTypeCreateOrConnectWithoutMovementsInput = {
    where: InventoryMovementTypeWhereUniqueInput
    create: XOR<InventoryMovementTypeCreateWithoutMovementsInput, InventoryMovementTypeUncheckedCreateWithoutMovementsInput>
  }

  export type UserCreateWithoutInventoryMovementsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    logs?: LogCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutInventoryMovementsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutInventoryMovementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
  }

  export type InventoryUpsertWithoutInventoryMovementsInput = {
    update: XOR<InventoryUpdateWithoutInventoryMovementsInput, InventoryUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<InventoryCreateWithoutInventoryMovementsInput, InventoryUncheckedCreateWithoutInventoryMovementsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutInventoryMovementsInput, InventoryUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type InventoryUpdateWithoutInventoryMovementsInput = {
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutInventoriesNestedInput
  }

  export type InventoryUncheckedUpdateWithoutInventoryMovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementTypeUpsertWithoutMovementsInput = {
    update: XOR<InventoryMovementTypeUpdateWithoutMovementsInput, InventoryMovementTypeUncheckedUpdateWithoutMovementsInput>
    create: XOR<InventoryMovementTypeCreateWithoutMovementsInput, InventoryMovementTypeUncheckedCreateWithoutMovementsInput>
    where?: InventoryMovementTypeWhereInput
  }

  export type InventoryMovementTypeUpdateToOneWithWhereWithoutMovementsInput = {
    where?: InventoryMovementTypeWhereInput
    data: XOR<InventoryMovementTypeUpdateWithoutMovementsInput, InventoryMovementTypeUncheckedUpdateWithoutMovementsInput>
  }

  export type InventoryMovementTypeUpdateWithoutMovementsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementTypeUncheckedUpdateWithoutMovementsInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutInventoryMovementsInput = {
    update: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
    create: XOR<UserCreateWithoutInventoryMovementsInput, UserUncheckedCreateWithoutInventoryMovementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventoryMovementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventoryMovementsInput, UserUncheckedUpdateWithoutInventoryMovementsInput>
  }

  export type UserUpdateWithoutInventoryMovementsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInventoryMovementsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutUsersInput
    role: RoleCreateNestedOneWithoutUsersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutUsersInput
    theme?: ThemeCreateNestedOneWithoutUsersUsingThisThemeInput
    openedCashBoxes?: CashBoxCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentCreateNestedManyWithoutReceiveUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    openedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutOpenerInput
    closedCashBoxes?: CashBoxUncheckedCreateNestedManyWithoutCloserInput
    inventoryMovements?: InventoryMovementUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    combinedTables?: CombineTableUncheckedCreateNestedManyWithoutCombinerInput
    releasedTables?: CombineTableUncheckedCreateNestedManyWithoutReleaserInput
    tablesSessionOpened?: TableSessionUncheckedCreateNestedManyWithoutOpenerInput
    tablesSessionClosed?: TableSessionUncheckedCreateNestedManyWithoutCloserInput
    ordersCreated?: OrderUncheckedCreateNestedManyWithoutCreatorInput
    ordersClosed?: OrderUncheckedCreateNestedManyWithoutCloserInput
    createdThemes?: ThemeUncheckedCreateNestedManyWithoutUserInput
    paymentsReceived?: PaymentUncheckedCreateNestedManyWithoutReceiveUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type CustomerCreateWithoutLogsInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    documentType: DocumentTypeCreateNestedOneWithoutCustomersInput
    accountStatus?: AccountStatusCreateNestedOneWithoutCustomersInput
    theme?: ThemeCreateNestedOneWithoutCustomerUsingThisThemeInput
    sessions?: SessionCreateNestedManyWithoutCustomerInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerUncheckedCreateWithoutLogsInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutCustomerInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    paymentsMade?: PaymentUncheckedCreateNestedManyWithoutPaidCustomerInput
  }

  export type CustomerCreateOrConnectWithoutLogsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutLogsInput, CustomerUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type CustomerUpsertWithoutLogsInput = {
    update: XOR<CustomerUpdateWithoutLogsInput, CustomerUncheckedUpdateWithoutLogsInput>
    create: XOR<CustomerCreateWithoutLogsInput, CustomerUncheckedCreateWithoutLogsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutLogsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutLogsInput, CustomerUncheckedUpdateWithoutLogsInput>
  }

  export type CustomerUpdateWithoutLogsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutLogsInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type UserCreateManyThemeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    accountStatusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CustomerCreateManyThemeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    accountStatusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserUpdateWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpdateWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutThemeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerCreateManyDocumentTypeInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserCreateManyDocumentTypeInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    roleName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CustomerUpdateWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: AccountStatusUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDocumentTypeInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    roleName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyAccountStatusInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    roleName: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CustomerCreateManyAccountStatusInput = {
    documentNumber: string
    username?: string | null
    email?: string | null
    password?: string | null
    fullName: string
    phoneNumber?: string | null
    documentTypeName: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type UserUpdateWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    roleName?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUpdateWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutCustomersNestedInput
    theme?: ThemeUpdateOneWithoutCustomerUsingThisThemeNestedInput
    sessions?: SessionUpdateManyWithoutCustomerNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    logs?: LogUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutCustomerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    logs?: LogUncheckedUpdateManyWithoutCustomerNestedInput
    paymentsMade?: PaymentUncheckedUpdateManyWithoutPaidCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutAccountStatusInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionCreateManyCategoryInput = {
    code: string
    name: string
    description?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type PermissionUpdateWithoutCategoryInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateWithoutCategoryInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rolePermissions?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateManyWithoutCategoryInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: number
    roleName: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    role?: RoleUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: number
    permissionCode: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
  }

  export type UserCreateManyRoleInput = {
    documentNumber: string
    username: string
    email: string
    password: string
    pin?: string | null
    fullName: string
    phoneNumber?: string | null
    birthDate?: Date | string | null
    hireDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    documentTypeName: string
    accountStatusCode?: string
    themeName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: PermissionUpdateOneRequiredWithoutRolePermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    permissionCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutRoleInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: DocumentTypeUpdateOneRequiredWithoutUsersNestedInput
    accountStatus?: AccountStatusUpdateOneRequiredWithoutUsersNestedInput
    theme?: ThemeUpdateOneWithoutUsersUsingThisThemeNestedInput
    openedCashBoxes?: CashBoxUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    openedCashBoxes?: CashBoxUncheckedUpdateManyWithoutOpenerNestedInput
    closedCashBoxes?: CashBoxUncheckedUpdateManyWithoutCloserNestedInput
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    combinedTables?: CombineTableUncheckedUpdateManyWithoutCombinerNestedInput
    releasedTables?: CombineTableUncheckedUpdateManyWithoutReleaserNestedInput
    tablesSessionOpened?: TableSessionUncheckedUpdateManyWithoutOpenerNestedInput
    tablesSessionClosed?: TableSessionUncheckedUpdateManyWithoutCloserNestedInput
    ordersCreated?: OrderUncheckedUpdateManyWithoutCreatorNestedInput
    ordersClosed?: OrderUncheckedUpdateManyWithoutCloserNestedInput
    createdThemes?: ThemeUncheckedUpdateManyWithoutUserNestedInput
    paymentsReceived?: PaymentUncheckedUpdateManyWithoutReceiveUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    documentNumber?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    documentTypeName?: StringFieldUpdateOperationsInput | string
    accountStatusCode?: StringFieldUpdateOperationsInput | string
    themeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashBoxCreateManyOpenerInput = {
    id?: number
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CashBoxCreateManyCloserInput = {
    id?: number
    openerUserDocument: string
    openedAt?: Date | string
    initialAmount: Decimal | DecimalJsLike | number | string
    closedAt?: Date | string | null
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    totalSales?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementCreateManyUserInput = {
    id?: number
    inventoryId: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogCreateManyUserInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    customerDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    customerDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableCreateManyCombinerInput = {
    id?: number
    name: string
    combineAt?: Date | string
    isActive?: boolean
    releaserUserDocument?: string | null
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableCreateManyReleaserInput = {
    id?: number
    name: string
    combinerUserDocument: string
    combineAt?: Date | string
    isActive?: boolean
    releasedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionCreateManyOpenerInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionCreateManyCloserInput = {
    id?: number
    tableId?: number | null
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderCreateManyCreatorInput = {
    code: string
    tableSessionId?: number | null
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderCreateManyCloserInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ThemeCreateManyUserInput = {
    name: string
    primaryColor: string
    secondaryColor: string
    accentColor: string
    neutralColor: string
    isSystem?: boolean
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentCreateManyReceiveUserInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CashBoxUpdateWithoutOpenerInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    closer?: UserUpdateOneWithoutClosedCashBoxesNestedInput
    payments?: PaymentUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxUncheckedUpdateWithoutOpenerInput = {
    id?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxUncheckedUpdateManyWithoutOpenerInput = {
    id?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashBoxUpdateWithoutCloserInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    opener?: UserUpdateOneRequiredWithoutOpenedCashBoxesNestedInput
    payments?: PaymentUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxUncheckedUpdateWithoutCloserInput = {
    id?: IntFieldUpdateOperationsInput | number
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    payments?: PaymentUncheckedUpdateManyWithoutCashBoxNestedInput
  }

  export type CashBoxUncheckedUpdateManyWithoutCloserInput = {
    id?: IntFieldUpdateOperationsInput | number
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    initialAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalSales?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementUpdateWithoutUserInput = {
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: InventoryUpdateOneRequiredWithoutInventoryMovementsNestedInput
    movementType?: InventoryMovementTypeUpdateOneRequiredWithoutMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUpdateWithoutUserInput = {
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: CustomerUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableUpdateWithoutCombinerInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    releaser?: UserUpdateOneWithoutReleasedTablesNestedInput
    tables?: CombineTableItemUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateWithoutCombinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: CombineTableItemUncheckedUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUncheckedUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateManyWithoutCombinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releaserUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableUpdateWithoutReleaserInput = {
    name?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combiner?: UserUpdateOneRequiredWithoutCombinedTablesNestedInput
    tables?: CombineTableItemUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateWithoutReleaserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: CombineTableItemUncheckedUpdateManyWithoutCombineTableNestedInput
    tableSessions?: TableSessionUncheckedUpdateManyWithoutCombineTableNestedInput
  }

  export type CombineTableUncheckedUpdateManyWithoutReleaserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    combinerUserDocument?: StringFieldUpdateOperationsInput | string
    combineAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionUpdateWithoutOpenerInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutTableSessionsNestedInput
    combineTable?: CombineTableUpdateOneWithoutTableSessionsNestedInput
    closer?: UserUpdateOneWithoutTablesSessionClosedNestedInput
    orders?: OrderUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateWithoutOpenerInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateManyWithoutOpenerInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionUpdateWithoutCloserInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutTableSessionsNestedInput
    combineTable?: CombineTableUpdateOneWithoutTableSessionsNestedInput
    opener?: UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput
    orders?: OrderUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateWithoutCloserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateManyWithoutCloserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutCreatorInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCreatorInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCreatorInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutCloserInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCloserInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCloserInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ThemeUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usersUsingThisTheme?: UserUpdateManyWithoutThemeNestedInput
    customerUsingThisTheme?: CustomerUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    usersUsingThisTheme?: UserUncheckedUpdateManyWithoutThemeNestedInput
    customerUsingThisTheme?: CustomerUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    primaryColor?: StringFieldUpdateOperationsInput | string
    secondaryColor?: StringFieldUpdateOperationsInput | string
    accentColor?: StringFieldUpdateOperationsInput | string
    neutralColor?: StringFieldUpdateOperationsInput | string
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUpdateWithoutReceiveUserInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
    cashBox?: CashBoxUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    paidCustomer?: CustomerUpdateOneWithoutPaymentsMadeNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReceiveUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutReceiveUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateManyCustomerInput = {
    id?: string
    userDocumentNumber?: string | null
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    isActive?: boolean
    expiresAt: Date | string
    closedAt?: Date | string | null
    closedBy?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderCreateManyCustomerInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type LogCreateManyCustomerInput = {
    id?: number
    entityName: string
    entityId?: string | null
    action: string
    message?: string | null
    userDocumentNumber?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyPaidCustomerInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type SessionUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutCustomerInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUpdateWithoutCustomerInput = {
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityName?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    userDocumentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPaidCustomerInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
    cashBox?: CashBoxUpdateOneRequiredWithoutPaymentsNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    receiveUser?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaidCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutPaidCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyCashBoxInput = {
    id?: number
    orderCode: string
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodName: string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateWithoutCashBoxInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentsNestedInput
    receiveUser?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    paidCustomer?: CustomerUpdateOneWithoutPaymentsMadeNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCashBoxInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutCashBoxInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodName?: StringFieldUpdateOperationsInput | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableCreateManyStatusInput = {
    id?: number
    name: string
    capacity?: number
    zoneName?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableUpdateWithoutStatusInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: RestaurantZoneUpdateOneWithoutTablesNestedInput
    tableSessions?: TableSessionUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSessions?: TableSessionUncheckedUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    zoneName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableCreateManyZoneInput = {
    id?: number
    name: string
    capacity?: number
    statusCode?: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableUpdateWithoutZoneInput = {
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: TableStatusUpdateOneRequiredWithoutTablesNestedInput
    tableSessions?: TableSessionUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSessions?: TableSessionUncheckedUpdateManyWithoutTableNestedInput
    combineTableItems?: CombineTableItemUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutZoneInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    statusCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionCreateManyTableInput = {
    id?: number
    combineTableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemCreateManyTableInput = {
    id?: number
    combineTableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionUpdateWithoutTableInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combineTable?: CombineTableUpdateOneWithoutTableSessionsNestedInput
    opener?: UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput
    closer?: UserUpdateOneWithoutTablesSessionClosedNestedInput
    orders?: OrderUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemUpdateWithoutTableInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    combineTable?: CombineTableUpdateOneRequiredWithoutTablesNestedInput
  }

  export type CombineTableItemUncheckedUpdateWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemUncheckedUpdateManyWithoutTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    combineTableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemCreateManyCombineTableInput = {
    id?: number
    tableId: number
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type TableSessionCreateManyCombineTableInput = {
    id?: number
    tableId?: number | null
    openerUserDocument: string
    openedAt?: Date | string
    numberPeople?: number
    isActive?: boolean
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type CombineTableItemUpdateWithoutCombineTableInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneRequiredWithoutCombineTableItemsNestedInput
  }

  export type CombineTableItemUncheckedUpdateWithoutCombineTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CombineTableItemUncheckedUpdateManyWithoutCombineTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableSessionUpdateWithoutCombineTableInput = {
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    table?: TableUpdateOneWithoutTableSessionsNestedInput
    opener?: UserUpdateOneRequiredWithoutTablesSessionOpenedNestedInput
    closer?: UserUpdateOneWithoutTablesSessionClosedNestedInput
    orders?: OrderUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateWithoutCombineTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: OrderUncheckedUpdateManyWithoutTableSessionNestedInput
  }

  export type TableSessionUncheckedUpdateManyWithoutCombineTableInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableId?: NullableIntFieldUpdateOperationsInput | number | null
    openerUserDocument?: StringFieldUpdateOperationsInput | string
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numberPeople?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyTableSessionInput = {
    code: string
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    statusCode: string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderUpdateWithoutTableSessionInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTableSessionInput = {
    code?: StringFieldUpdateOperationsInput | string
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTableSessionInput = {
    code?: StringFieldUpdateOperationsInput | string
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyBrandInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyProductStatusInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    productCategoryName: string
    brandName?: string | null
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductUpdateWithoutProductStatusInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyProductTypeInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productCategoryName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductUpdateWithoutProductTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productCategory?: ProductCategoryUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productCategoryName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateManyProductCategoryInput = {
    id?: number
    name: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    offerPrice?: Decimal | DecimalJsLike | number | string | null
    productTypeName: string
    brandName?: string | null
    productStatusCode?: string
    mainImageId?: number | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type ProductUpdateWithoutProductCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    productType?: ProductTypeUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    productStatus?: ProductStatusUpdateOneRequiredWithoutProductsNestedInput
    inventories?: InventoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventories?: InventoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutProductCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    offerPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    productTypeName?: StringFieldUpdateOperationsInput | string
    brandName?: NullableStringFieldUpdateOperationsInput | string | null
    productStatusCode?: StringFieldUpdateOperationsInput | string
    mainImageId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryCreateManyProductInput = {
    id?: number
    currentQuantity?: number
    minimumStock?: number
    storageLocation?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderCode: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryUpdateWithoutProductInput = {
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryMovements?: InventoryMovementUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventoryMovements?: InventoryMovementUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentQuantity?: IntFieldUpdateOperationsInput | number
    minimumStock?: IntFieldUpdateOperationsInput | number
    storageLocation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    status?: OrderItemStatusUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyStatusInput = {
    code: string
    tableSessionId?: number | null
    creatorUserDocument: string
    createdAt?: Date | string | null
    customerDocumentNumber: string
    subtotalAmount?: Decimal | DecimalJsLike | number | string
    taxAmount?: Decimal | DecimalJsLike | number | string
    totalAmount?: Decimal | DecimalJsLike | number | string
    closerUserDocument?: string | null
    closedAt?: Date | string | null
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderUpdateWithoutStatusInput = {
    code?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    tableSession?: TableSessionUpdateOneWithoutOrdersNestedInput
    creator?: UserUpdateOneRequiredWithoutOrdersCreatedNestedInput
    customer?: CustomerUpdateOneRequiredWithoutOrdersNestedInput
    closer?: UserUpdateOneWithoutOrdersClosedNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStatusInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStatusInput = {
    code?: StringFieldUpdateOperationsInput | string
    tableSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    creatorUserDocument?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerDocumentNumber?: StringFieldUpdateOperationsInput | string
    subtotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    closerUserDocument?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyStatusInput = {
    id?: number
    orderCode: string
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemUpdateWithoutStatusInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    subTotal: Decimal | DecimalJsLike | number | string
    discount?: Decimal | DecimalJsLike | number | string
    statusCode?: string
    specialInstructions?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
    status?: OrderItemStatusUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statusCode?: StringFieldUpdateOperationsInput | string
    specialInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyPaymentMethodInput = {
    id?: number
    orderCode: string
    cashBoxId: number
    totalAmount: Decimal | DecimalJsLike | number | string
    receivedAmount?: Decimal | DecimalJsLike | number | string | null
    changeAmount?: Decimal | DecimalJsLike | number | string | null
    transactionNumber?: string | null
    notes?: string | null
    receiveUserDocument: string
    paidCustomerDocument?: string | null
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type PaymentUpdateWithoutPaymentMethodInput = {
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
    cashBox?: CashBoxUpdateOneRequiredWithoutPaymentsNestedInput
    receiveUser?: UserUpdateOneRequiredWithoutPaymentsReceivedNestedInput
    paidCustomer?: CustomerUpdateOneWithoutPaymentsMadeNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderCode?: StringFieldUpdateOperationsInput | string
    cashBoxId?: IntFieldUpdateOperationsInput | number
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    receivedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    transactionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiveUserDocument?: StringFieldUpdateOperationsInput | string
    paidCustomerDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementCreateManyMovementTypeInput = {
    id?: number
    inventoryId: number
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementUpdateWithoutMovementTypeInput = {
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    inventory?: InventoryUpdateOneRequiredWithoutInventoryMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutMovementTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementUncheckedUpdateManyWithoutMovementTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementCreateManyInventoryInput = {
    id?: number
    movementTypeCode: string
    quantityMovement: number
    reasonDescription: string
    userDocumentNumber: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string | null
    updatedBy?: string | null
    deletedAt?: Date | string | null
    deletedBy?: string | null
  }

  export type InventoryMovementUpdateWithoutInventoryInput = {
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    movementType?: InventoryMovementTypeUpdateOneRequiredWithoutMovementsNestedInput
    user?: UserUpdateOneRequiredWithoutInventoryMovementsNestedInput
  }

  export type InventoryMovementUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InventoryMovementUncheckedUpdateManyWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    movementTypeCode?: StringFieldUpdateOperationsInput | string
    quantityMovement?: IntFieldUpdateOperationsInput | number
    reasonDescription?: StringFieldUpdateOperationsInput | string
    userDocumentNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}